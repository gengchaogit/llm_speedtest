<!DOCTYPE html>
<html lang="en">
<!-- Original Author: çº¸é¸¢éšé£ (Bilibili), DeepSeek-R1-0528-->
<!-- v2.0 (chao modded version):
    Get the latest updates from:
    https://github.com/gengchaogit/llm_speedtest
    1. (v2.0) [API Stats Enhancement] Display complete usage statistics in test details (prompt_tokens, completion_tokens, reasoning_tokens, etc.)
    2. (v2.0) [Streaming Usage Support] Add stream_options parameter to get usage info in streaming responses
    3. (v2.0) [Reasoning Model Optimization] Auto-detect reasoning content and estimate reasoning_tokens (when API doesn't provide)
    4. (v2.0) [Timing Info] Support displaying llama.cpp/Ollama detailed timing stats (prompt_eval_duration, eval_duration, etc.)
    5. (v2.0) [Dynamic Field Display] Auto-display all available stat fields returned by API (timings, cached_tokens, etc.)
    6. (v2.0) [Storage Optimization] Friendly prompt when history storage is full, guide users to clean old records
    7. (v2.0) [Fix] Fixed concurrency and timeout showing undefined/NaN when loading history records
    8. (v2.0) [Fix] Fixed saveCurrentConfig undefined error
-->

<!-- v1.9 (chao modded version):
    1. (v1.9) [History Management] Auto-save test results to localStorage (up to 20 records)
    2. (v1.9) [History Panel] Beautiful modal interface to view all historical tests
    3. (v1.9) [Detail View] View complete configuration, statistics, and test results
    4. (v1.9) [Individual Export] Export history records as CSV files
    5. (v1.9) [Record Management] Delete individual records or clear all
    6. (v1.9) [History Comparison] Select multiple history records and generate comparison charts
    7. (v1.9) [Data Persistence] All history records saved in localStorage
    8. (v1.9) [Full Bilingual] All history features fully support Chinese/English switching
-->

<!-- v1.8 (chao modded version):
    1. (v1.8) Add chart export button
    2. (v1.8) Add multiple CSV import for comparison
    3. (v1.8) Combined chart export: Export Prefill and Decode charts as one image
    4. (v1.8) Comparison labels: Use CSV filenames as legend labels
    5. (v1.8) Comparison export: Export comparison charts with auto-generated filenames
    6. (v1.8) [Important Fix] Support reasoning models: Parse usage field for accurate token stats
    7. (v1.8) Add token estimation fallback: Use character estimation when API doesn't return usage
    8. (v1.8) [Critical Fix] Prefill speed calculation error: Use actual prompt_tokens from API
    9. (v1.8) [Compatibility Fix] Support multiple streaming response formats
    10. (v1.8) Auto-save/restore all config parameters
    11. (v1.8) [Reasoning Model Fix] Correctly calculate reasoning+completion total tokens
    12. (v1.8) [Performance Optimization] Prioritize server-returned real GPU processing time
-->

<!-- v1.7 (chaoåŸºäºåŸç‰ˆé­”æ”¹ç‰ˆ-qqç¾¤:1028429001):
    1. ä¸ºæ¯ä¸ªè¯·æ±‚å¢åŠ 3æ¬¡é‡è¯•ï¼ˆé—´éš”1.5ç§’ï¼‰ï¼Œä»¥è¿‡æ»¤æ‰ç¬æ—¶/å¶å‘çš„æœåŠ¡å™¨å¤±è´¥ã€‚
    2. è‡ªåŠ¨æ˜¾ç¤ºå›¾è¡¨ï¼Œæ— éœ€ç‚¹å‡»
    3. å°† Prefill å’Œ Decode é€Ÿåº¦åˆ†ç¦»åˆ°ä¸¤å¼ å›¾è¡¨
    4. ä¿®å¤é«˜å¹¶å‘ä¸‹ Promise.all ç†”æ–­é—®é¢˜ (ä½¿ç”¨ Promise.allSettled)
    5. å¢åŠ  AbortController å®ç°çš„è¯·æ±‚è¶…æ—¶
    6. ä¿å­˜å½“å‰é…ç½®åˆ° localStorage
-->
<!-- æœ¬å·¥å…·é€šè¿‡æµè§ˆå™¨æœ¬åœ°ç¦»çº¿è¿è¡Œ -->

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Local LLM Inference Speed Test Tool v2.0</title>
    <!-- å¼•å…¥ Chart.js ç”¨äºç»˜å›¾ -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
    <style>
        :root {
            --primary-color: #1a73e8;
            --success-color: #98c379;
            --error-color: #e06c75;
            --info-color: #61afef;
            --dark-bg: #282c34;
            --dark-row: #2f343a;
            --light-bg: #f4f7f9;
            --border-color: #e0e0e0;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background-color: var(--light-bg);
            color: #333;
            line-height: 1.6;
            padding: 20px;
            max-width: 1000px;
            margin: 0 auto;
        }

        .container {
            background: #fff;
            padding: 25px;
            border-radius: 8px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
            margin-bottom: 30px;
        }

        h1 {
            color: var(--primary-color);
            padding-bottom: 10px;
            margin-top: 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .api-selector {
            display: flex;
            margin-bottom: 20px;
            border-radius: 5px;
            overflow: hidden;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        .api-option {
            flex: 1;
            text-align: center;
            padding: 12px;
            background: #fff;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 1px solid var(--border-color);
        }

        .api-option:first-child {
            border-radius: 5px 0 0 5px;
        }

        .api-option:last-child {
            border-radius: 0 5px 5px 0;
        }

        .api-option.active {
            background-color: var(--primary-color);
            color: white;
            font-weight: bold;
            border-color: var(--primary-color);
        }

        .api-option:hover:not(.active) {
            background-color: #f0f7ff;
        }

        .config-section {
            margin-bottom: 20px;
        }

        h2 {
            color: #444;
            font-size: 1.2em;
            margin-bottom: 15px;
            padding-bottom: 5px;
            border-bottom: 1px dashed var(--border-color);
        }

        .form-row {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 15px;
        }

        .form-group {
            flex: 1;
            min-width: 200px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
        }

        .form-group input,
        .form-group select {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 1em;
        }

        button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 12px 20px;
            font-size: 1em;
            font-weight: 600;
            border-radius: 5px;
            cursor: pointer;
            transition: filter 0.1s, transform 0.1s;
            margin-top: 10px;
        }

        button:hover {
            filter: brightness(0.95);
        }

        button:active {
            transform: scale(0.98);
        }

        button:disabled {
            background-color: #a0a0a0 !important;
            cursor: not-allowed;
        }

        #results {
            background-color: var(--dark-bg);
            color: #abb2bf;
            padding: 15px;
            border-radius: 5px;
            min-height: 150px;
            margin-top: 20px;
            overflow-x: auto;
        }

        #results table {
            width: 100%;
            border-collapse: collapse;
            margin: 0;
            font-family: "Courier New", Courier, monospace;
            font-size: 0.85em; /* ç¨å¾®å‡å°å­—ä½“ */
            table-layout: fixed;
        }

        #results th,
        #results td {
            border: 1px solid #444;
            padding: 6px 4px; /* å‡å°å†…è¾¹è· */
            text-align: left;
            color: #abb2bf;
            white-space: normal;
            word-break: break-word;
        }

        #results th {
            background-color: #333;
            color: #f8f8f2;
            position: sticky;
            top: 0;
            z-index: 1;
            font-size: 0.9em;
        }

        /* æç¤ºè¯é•¿åº¦ */
        #results th:nth-child(1),
        #results td:nth-child(1) {
            width: 11%;
        }

        /* é¢„å¡«å……è€—æ—¶ */
        #results th:nth-child(2),
        #results td:nth-child(2) {
            width: 13%;
        }

        /* é¢„å¡«å……é€Ÿåº¦ */
        #results th:nth-child(3),
        #results td:nth-child(3) {
            width: 13%;
        }

        /* è¾“å‡ºé•¿åº¦ */
        #results th:nth-child(4),
        #results td:nth-child(4) {
            width: 11%;
        }

        /* è¾“å‡ºè€—æ—¶ */
        #results th:nth-child(5),
        #results td:nth-child(5) {
            width: 13%;
        }

        /* è¾“å‡ºé€Ÿåº¦ */
        #results th:nth-child(6),
        #results td:nth-child(6) {
            width: 13%;
        }

        /* çŠ¶æ€ */
        #results th:nth-child(7),
        #results td:nth-child(7) {
            width: 16%;
        }

        /* è¯¦æƒ…æŒ‰é’® */
        #results th:nth-child(8),
        #results td:nth-child(8) {
            width: 10%;
            text-align: center;
            padding: 4px 2px;
        }

        #results tr:nth-child(even) {
            background-color: var(--dark-row);
        }

        .success {
            color: var(--success-color);
        }

        .error {
            color: var(--error-color);
        }

        .info {
            color: var(--info-color);
            padding: 5px 0;
            text-align: center;
        }

        .notes {
            color: var(--info-color);
            padding-bottom: 5px;
        }

        #markdownOutputHidden {
            position: absolute;
            left: -9999px;
            width: 1px;
            height: 1px;
            overflow: hidden;
            white-space: pre;
        }

        .progress-container {
            margin: 15px 0;
            background-color: #e0e0e0;
            border-radius: 5px;
            height: 10px;
            overflow: hidden;
        }

        .progress-bar {
            height: 100%;
            background-color: var(--primary-color);
            transition: width 0.3s ease;
        }

        .action-buttons {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .action-buttons button {
            flex: 1;
        }

        .api-description {
            margin-top: 10px;
            margin-bottom: 10px;
            padding: 15px;
            background-color: #f0f7ff;
            border-radius: 5px;
            border-left: 4px solid var(--primary-color);
        }

        .api-description h3 {
            color: var(--primary-color);
            margin-bottom: 10px;
        }

        .api-description ul {
            padding-left: 20px;
        }

        .api-description li {
            margin-bottom: 8px;
        }

        .logo {
            font-size: 24px;
        }

        .lang-toggle {
            margin-left: auto;
            padding: 8px 16px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        .lang-toggle:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }

        .lang-toggle:active {
            transform: translateY(0);
        }

        .concurrent-stats {
            background-color: #2c3e50;
            padding: 10px;
            border-radius: 5px;
            margin-top: 15px;
            font-family: monospace;
        }

        .concurrent-stats h3 {
            color: #61afef;
            margin-bottom: 8px;
            font-size: 1.1em;
        }

        .concurrent-stats .stat-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }

        .concurrent-stats .stat-value {
            color: #98c379;
        }

        /* v1.9: å†å²è®°å½•æ¨¡æ€æ¡†æ ·å¼ */
        .history-modal {
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0, 0, 0, 0.6);
            animation: fadeIn 0.3s;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .history-modal-content {
            background-color: #fefefe;
            margin: 3% auto;
            padding: 0;
            border-radius: 8px;
            width: 90%;
            max-width: 1000px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            animation: slideDown 0.3s;
        }

        @keyframes slideDown {
            from {
                transform: translateY(-50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .history-modal-header {
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 8px 8px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .history-modal-header h2 {
            margin: 0;
            font-size: 1.5em;
        }

        .history-modal-close {
            color: white;
            font-size: 32px;
            font-weight: bold;
            cursor: pointer;
            transition: color 0.3s;
        }

        .history-modal-close:hover {
            color: #ffeb3b;
        }

        .history-modal-body {
            padding: 20px;
            max-height: 70vh;
            overflow-y: auto;
        }

        .history-actions {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .history-actions-left {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .history-btn-primary {
            background: #3498db;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
        }

        .history-btn-primary:hover {
            background: #2980b9;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(52, 152, 219, 0.3);
        }

        .history-btn-primary:disabled {
            background: #95a5a6;
            cursor: not-allowed;
            transform: none;
        }

        .history-btn-danger {
            background: #e74c3c;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
        }

        .history-btn-danger:hover {
            background: #c0392b;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(231, 76, 60, 0.3);
        }

        .history-btn-secondary {
            background: #95a5a6;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
        }

        .history-btn-secondary:hover {
            background: #7f8c8d;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(149, 165, 166, 0.3);
        }

        .history-btn-back {
            background: #95a5a6;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            margin-bottom: 15px;
            transition: all 0.3s;
        }

        .history-btn-back:hover {
            background: #7f8c8d;
            transform: translateX(-3px);
        }

        .history-record {
            background: #f8f9fa;
            border-left: 4px solid #667eea;
            padding: 15px;
            margin-bottom: 15px;
            border-radius: 5px;
            transition: all 0.3s;
            display: flex;
            gap: 15px;
        }

        .history-record:hover {
            background: #e9ecef;
            transform: translateX(5px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .history-record-checkbox {
            flex-shrink: 0;
            display: flex;
            align-items: flex-start;
            padding-top: 5px;
        }

        .history-record-checkbox input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .history-record-content {
            flex: 1;
        }

        .history-record-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 10px;
        }

        .history-record-time {
            font-weight: bold;
            color: #2c3e50;
            font-size: 1.1em;
        }

        .history-record-info {
            color: #555;
            font-size: 0.9em;
            line-height: 1.6;
        }

        .history-record-info div {
            margin-bottom: 5px;
        }

        .history-record-actions {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .history-record-btn {
            padding: 6px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.3s;
        }

        .history-record-btn-view {
            background: #3498db;
            color: white;
        }

        .history-record-btn-view:hover {
            background: #2980b9;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(52, 152, 219, 0.3);
        }

        .history-record-btn-load {
            background: #9b59b6;
            color: white;
        }

        .history-record-btn-load:hover {
            background: #8e44ad;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(155, 89, 182, 0.3);
        }

        .history-record-btn-export {
            background: #27ae60;
            color: white;
        }

        .history-record-btn-export:hover {
            background: #229954;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(39, 174, 96, 0.3);
        }

        .history-record-btn-delete {
            background: #e74c3c;
            color: white;
        }

        .history-record-btn-delete:hover {
            background: #c0392b;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(231, 76, 60, 0.3);
        }

        .history-empty {
            text-align: center;
            padding: 40px;
            color: #95a5a6;
            font-size: 1.2em;
        }

        /* v1.9: è¯¦æƒ…å¼¹çª—æ ·å¼ */
        .detail-button {
            padding: 6px 12px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.3s;
        }

        .detail-button:hover {
            background: #2980b9;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(52, 152, 219, 0.3);
        }

        .detail-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            z-index: 2000;
            display: flex;
            justify-content: center;
            align-items: center;
            animation: fadeIn 0.3s;
        }

        .detail-dialog {
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            width: 95%;
            max-width: 1400px; /* å¢åŠ å®½åº¦ */
            max-height: 90vh;
            overflow: auto;
            animation: slideDown 0.3s;
        }

        .detail-header {
            padding: 20px;
            background: linear-gradient(135deg, #3498db 0%, #2c3e50 100%);
            color: white;
            border-radius: 8px 8px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .detail-title {
            font-size: 1.5em;
            font-weight: bold;
            margin: 0;
        }

        .detail-header-actions {
            display: flex;
            gap: 10px;
        }

        .detail-close-button,
        .detail-copy-button {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
        }

        .detail-close-button {
            background: #e74c3c;
            color: white;
        }

        .detail-close-button:hover {
            background: #c0392b;
        }

        .detail-copy-button {
            background: #27ae60;
            color: white;
        }

        .detail-copy-button:hover {
            background: #229954;
        }

        .detail-body {
            padding: 20px;
        }

        .detail-section {
            margin-bottom: 25px;
            background: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            border-left: 4px solid #3498db;
        }

        .detail-section-title {
            font-size: 1.2em;
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #ddd;
        }

        .detail-row {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 10px;
        }

        .detail-field {
            flex: 1;
            min-width: 200px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .detail-field-label {
            font-weight: bold;
            color: #34495e;
            white-space: nowrap;
        }

        .detail-field-value {
            background: white;
            padding: 6px 12px;
            border-radius: 4px;
            color: #2c3e50;
            border: 1px solid #ddd;
        }

        .detail-block {
            margin-top: 15px;
        }

        .detail-block-label {
            font-weight: bold;
            color: #34495e;
            margin-bottom: 8px;
        }

        /* è¯¦æƒ…å†…å®¹å—æ ·å¼ */
        .detail-content-block {
            background: white;
            padding: 15px;
            border-radius: 6px;
            border-left: 4px solid #ddd;
            font-family: 'Courier New', Consolas, monospace;
            font-size: 14px;
            line-height: 1.6;
            max-height: 400px;
            overflow-y: auto;
            overflow-x: auto;
        }

        .detail-content-block pre {
            margin: 0;
            white-space: pre-wrap;
            word-wrap: break-word;
            word-break: break-word;
            overflow-wrap: break-word;
        }

        .detail-prompt-content {
            border-left-color: #f39c12;
            background: #fffbf0;
        }

        .detail-output-content {
            border-left-color: #27ae60;
            background: #f0fff4;
        }

        .detail-reasoning-content {
            border-left-color: #9b59b6;
            background: #f5f0ff;
        }

        .detail-subsection-title {
            font-size: 1em;
            font-weight: bold;
            color: #2c3e50;
            margin-top: 15px;
            margin-bottom: 10px;
        }

        .detail-concurrent-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .detail-concurrent-item {
            background: white;
            padding: 12px;
            border-radius: 4px;
            border: 1px solid #ddd;
        }

        .detail-concurrent-item-title {
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 8px;
            padding-bottom: 8px;
            border-bottom: 1px solid #eee;
        }

        #chartContainer {
            margin-top: 30px;
            background: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
        }

        #chartContainer h3 {
             color: #333;
             margin-bottom: 10px;
             text-align: center;
        }

        #outputChart {
            margin-top: 25px;
        }

        @media (max-width: 768px) {
            .form-row {
                flex-direction: column;
                gap: 10px;
            }

            .action-buttons {
                flex-direction: column;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <h1><span class="logo">ğŸš€</span> <span id="pageTitle">å¤§æ¨¡å‹ Prefill & Decode æ€§èƒ½æµ‹è¯•å·¥å…· v1.8 (chaoé­”æ”¹ç‰ˆ-åŠ ç»˜å›¾ä¿®bug-è‡ªåŠ¨ä¿å­˜api)</span><button class="lang-toggle" id="langToggle">English</button></h1>

        <div class="api-selector">
            <div class="api-option active" data-type="openai">OpenAIå…¼å®¹æ¥å£</div>
            <div class="api-option" data-type="ollama">Ollamaæ¥å£</div>
        </div>

        <div class="api-description" id="apiDescription">
            <h3>OpenAIå…¼å®¹æ¥å£æµ‹è¯•è¯´æ˜</h3>
            <ul>
                <li>ä½¿ç”¨æµå¼å“åº”(stream=true)æµ‹é‡é¦–å­—å»¶è¿Ÿ</li>
                <li>é¢„å¡«å……é€Ÿåº¦ = æç¤ºè¯é•¿åº¦ / (é¦–å­—åˆ°è¾¾æ—¶é—´ - è¯·æ±‚å¼€å§‹æ—¶é—´)</li>
                <li>è¾“å‡ºé€Ÿåº¦ = è¾“å‡ºtokenæ•° / (è¾“å‡ºå®Œæˆæ—¶é—´ - é¦–å­—åˆ°è¾¾æ—¶é—´)</li>
                <li>é€‚ç”¨äºæ‰€æœ‰å…¼å®¹OpenAI APIçš„å¤§æ¨¡å‹æœåŠ¡</li>
                <li><strong> æ”¯æŒæ€è€ƒæ¨¡å‹</strong>ï¼ˆDeepSeek-R1ã€Qwen-QwQç­‰ï¼‰ï¼šè‡ªåŠ¨ç»Ÿè®¡æ€»ååï¼ˆæ€è€ƒ+ç­”æ¡ˆtokensï¼‰</li>
            </ul>
        </div>

        <div class="config-section">
            <h2>API ä¿¡æ¯</h2>
            <div class="form-row">
                <div class="form-group">
                    <label for="apiUrl">API åœ°å€</label>
                    <input type="text" id="apiUrl" value="">
                </div>
                <div class="form-group">
                    <label for="modelName">æ¨¡å‹åç§°</label>
                    <input type="text" id="modelName" value="">
                </div>
            </div>
            <div class="form-row">
                <div class="form-group">
                    <label for="apiKey">API-Key</label>
                    <input type="text" id="apiKey" value="" placeholder="æœªè®¾ç½® API-Key åˆ™ç•™ç©º">
                </div>
            </div>
            <div class="form-row">
                <div class="form-group">
                    <label for="notes">å¤‡æ³¨</label>
                    <input type="text" id="notes" value="" placeholder="è¯·å¡«å†™è®¾å¤‡ä¿¡æ¯ã€æ¨¡å‹ä¿¡æ¯ã€æ¨¡å‹æ¨ç†æ¡†æ¶ï¼Œä»¥ä¾¿åœ¨ç»“æœä¸­æ˜¾ç¤º">
                </div>
            </div>
        </div>

        <div class="config-section">
            <h2>æµ‹è¯•å‚æ•°é…ç½®</h2>
            <div class="form-row">
                <div class="form-group">
                    <label for="minLength">æœ€å°æç¤ºè¯é•¿åº¦</label>
                    <input type="number" id="minLength" value="" step="128">
                </div>
                <div class="form-group">
                    <label for="maxLength">æœ€å¤§æç¤ºè¯é•¿åº¦</label>
                    <input type="number" id="maxLength" value="" step="128">
                </div>
                <div class="form-group">
                    <label for="step">æ­¥é•¿</label>
                    <input type="number" id="step" value="" step="128">
                </div>
                <div class="form-group">
                    <label for="outputLength">æœŸæœ›è¾“å‡ºé•¿åº¦</label>
                    <input type="number" id="outputLength" value="" min="1">
                </div>
            </div>
            <div class="form-row">
                <div class="form-group">
                    <label for="concurrency">å¹¶å‘æ•°</label>
                    <input type="number" id="concurrency" value="1" min="1" max="50">
                </div>
                <div class="form-group">
                    <label for="timeout">è¯·æ±‚è¶…æ—¶ (ms)</label>
                    <input type="number" id="timeout" value="" min="1000" step="1000">
                </div>
                <div class="form-group">
                    <label for="temperatureInput">Temperature</label>
                    <input type="number" id="temperatureInput" value="" step="0.1" min="0" max="2">
                </div>
                <div class="form-group">
                    <label for="topPInput">Top P</label>
                    <input type="number" id="topPInput" value="" step="0.01" min="0" max="1">
                </div>
            </div>
            <div class="form-row">
                 <div class="form-group">
                    <label for="presencePenaltyInput">Presence Penalty</label>
                    <input type="number" id="presencePenaltyInput" value="" step="0.1" min="-2" max="2">
                </div>
                <div class="form-group">
                    <label for="frequencyPenaltyInput">Frequency Penalty</label>
                    <input type="number" id="frequencyPenaltyInput" value="" step="0.1" min="-2" max="2">
                </div>
            </div>
        </div>

        <h2>æ‰§è¡Œæµ‹è¯•</h2>
        <div class="action-buttons">
            <button id="startTest" style="background: #349bea;">å¼€å§‹æµ‹è¯•</button>
            <button id="stopTest" style="display: none; background: #E74C3C;">åœæ­¢æµ‹è¯•</button>
            <button id="copyMarkdown" style="display: none; background: #4CAF50;">å¤åˆ¶ Markdown è¡¨æ ¼</button>
            <button id="exportCSV" style="display: none; background: #4eb8a6;">å¯¼å‡º CSV æ•°æ®</button>
            <!-- v1.8: åˆå¹¶å›¾è¡¨å¯¼å‡º -->
            <button id="exportCombinedChart" style="display: none; background: #f39c12;">å¯¼å‡ºä¸€å¼ å›¾è¡¨</button>
            <!-- v1.9: å†å²è®°å½• -->
            <button id="viewHistory" style="background: #9b59b6;">ğŸ“š æŸ¥çœ‹å†å²è®°å½•</button>
            <!-- v1.9.1: é‡ç½®å‚æ•° -->
            <button id="resetParams" style="background: #e67e22;">ğŸ”„ é‡ç½®å‚æ•°</button>
        </div>
        <div class="progress-container">
            <div id="progressBar" class="progress-bar" style="width: 0%"></div>
        </div>

        <!-- v1.8: æ–°å¢å¯¹æ¯”åŠŸèƒ½ -->
        <div class="config-section">
            <h2>å¤šç»“æœå¯¹æ¯”</h2>
            <div class="form-group">
                <label for="importFiles">å¯¼å…¥CSVç»“æœæ–‡ä»¶ (å¯å¤šé€‰)</label>
                <input type="file" id="importFiles" multiple accept=".csv" style="padding: 5px;">
            </div>
            <button id="startComparison" style="background: #27ae60;">ç”Ÿæˆå¯¹æ¯”å›¾è¡¨</button>
            <p class="notes" style="margin-top: 10px;">è¯´æ˜ï¼šå…ˆâ€œå¼€å§‹æµ‹è¯•â€è¿è¡Œä¸€æ¬¡ï¼Œç„¶åå†å¯¼å…¥å…¶ä»–CSVæ–‡ä»¶ï¼Œç‚¹å‡»â€œç”Ÿæˆå¯¹æ¯”å›¾è¡¨â€</p>
        </div>

        <div id="results">
            <p class="info">ç­‰å¾…å¼€å§‹æµ‹è¯•...</p>
        </div>

        <!-- ç»˜å›¾åŒºåŸŸï¼šåŒ…å«ä¸¤ä¸ª canvas -->
        <div id="chartContainer" style="display: none;">
            <h3>é¢„å¡«å…… (Prefill) åå</h3>
            <canvas id="prefillChart"></canvas>

            <h3 style="margin-top: 25px;">è¾“å‡º (Decode) åå</h3>
            <canvas id="outputChart"></canvas>
        </div>

        <!-- v1.8: æ–°çš„å¯¹æ¯”ç»˜å›¾åŒºåŸŸ -->
        <div id="comparisonChartContainer" style="display: none; margin-top: 30px; background: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 4px 10px rgba(0,0,0,0.1);">
            <h3>å¯¹æ¯” - é¢„å¡«å…… (Prefill) åå</h3>
            <canvas id="comparisonPrefillChart"></canvas>

            <h3 style="margin-top: 25px;">å¯¹æ¯” - è¾“å‡º (Decode) åå</h3>
            <canvas id="comparisonOutputChart"></canvas>

            <!-- v1.8: å¯¹æ¯”å›¾è¡¨å¯¼å‡ºæŒ‰é’® -->
            <button id="exportComparisonChart" style="display: none; background: #8e44ad; margin-top: 15px;">å¯¼å‡ºä¸€å¼ å¯¹æ¯”å›¾</button>
        </div>


        <textarea id="markdownOutputHidden"></textarea>

        <!-- v1.9: å†å²è®°å½•æ¨¡æ€æ¡† -->
        <div id="historyModal" class="history-modal" style="display: none;">
            <div class="history-modal-content">
                <div class="history-modal-header">
                    <h2 id="historyModalTitle">æµ‹è¯•å†å²è®°å½•</h2>
                    <span class="history-modal-close">&times;</span>
                </div>
                <div class="history-modal-body">
                    <div id="historyListView">
                        <div class="history-actions">
                            <div class="history-actions-left">
                                <button id="generateHistoryComparison" class="history-btn-primary" disabled>ç”Ÿæˆå¯¹æ¯”å›¾è¡¨</button>
                                <button id="selectAllHistory" class="history-btn-secondary" style="margin-left: 10px;">å…¨é€‰</button>
                                <button id="deselectAllHistory" class="history-btn-secondary">åé€‰</button>
                                <button id="deleteSelectedHistory" class="history-btn-danger" style="margin-left: 10px;" disabled>åˆ é™¤é€‰ä¸­</button>
                                <span id="selectedCount" style="color: #666; font-size: 14px; margin-left: 10px;">å·²é€‰æ‹© 0 æ¡</span>
                            </div>
                            <button id="clearAllHistory" class="history-btn-danger">æ¸…ç©ºå…¨éƒ¨</button>
                        </div>
                        <div id="historyList"></div>
                    </div>
                    <div id="historyDetailView" style="display: none;">
                        <button id="backToHistoryList" class="history-btn-back">â† è¿”å›åˆ—è¡¨</button>
                        <div id="historyDetailContent"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ===============================================================================
        // è¯­è¨€åˆ‡æ¢åŠŸèƒ½ (Language Toggle)
        // ===============================================================================
        const translations = {
            'zh': {
                pageTitle: 'å¤§æ¨¡å‹ Prefill & Decode æ€§èƒ½æµ‹è¯•å·¥å…· v1.8 (chaoé­”æ”¹ç‰ˆ-åŠ ç»˜å›¾ä¿®bug-è‡ªåŠ¨ä¿å­˜api)',
                langToggle: 'English',
                apiOpenAI: 'OpenAIå…¼å®¹æ¥å£',
                apiOllama: 'Ollamaæ¥å£',
                apiDescOpenAITitle: 'OpenAIå…¼å®¹æ¥å£æµ‹è¯•è¯´æ˜',
                apiDescOpenAI1: 'ä½¿ç”¨æµå¼å“åº”(stream=true)æµ‹é‡é¦–å­—å»¶è¿Ÿ',
                apiDescOpenAI2: 'é¢„å¡«å……é€Ÿåº¦ = æç¤ºè¯é•¿åº¦ / (é¦–å­—åˆ°è¾¾æ—¶é—´ - è¯·æ±‚å¼€å§‹æ—¶é—´)',
                apiDescOpenAI3: 'è¾“å‡ºé€Ÿåº¦ = è¾“å‡ºtokenæ•° / (è¾“å‡ºå®Œæˆæ—¶é—´ - é¦–å­—åˆ°è¾¾æ—¶é—´)',
                apiDescOpenAI4: 'é€‚ç”¨äºæ‰€æœ‰å…¼å®¹OpenAI APIçš„å¤§æ¨¡å‹æœåŠ¡',
                apiDescOpenAI5: '<strong> æ”¯æŒæ€è€ƒæ¨¡å‹</strong>ï¼ˆDeepSeek-R1ã€Qwen-QwQç­‰ï¼‰ï¼šè‡ªåŠ¨ç»Ÿè®¡æ€»ååï¼ˆæ€è€ƒ+ç­”æ¡ˆtokensï¼‰',
                apiDescOllamaTitle: 'Ollamaæ¥å£æµ‹è¯•è¯´æ˜',
                apiDescOllama1: 'ä½¿ç”¨éæµå¼è¯·æ±‚(stream=false)',
                apiDescOllama2: 'ç›´æ¥ä½¿ç”¨APIè¿”å›çš„prompt_eval_durationå’Œeval_durationæŒ‡æ ‡',
                apiDescOllama3: 'é¢„å¡«å……é€Ÿåº¦ = æç¤ºè¯é•¿åº¦ / (prompt_eval_duration / 1000)',
                apiDescOllama4: 'è¾“å‡ºé€Ÿåº¦ = è¾“å‡ºtokenæ•° / (eval_duration / 1000)',
                apiDescOllama5: '<strong> æ”¯æŒæ€è€ƒæ¨¡å‹</strong>ï¼ševal_countè‡ªåŠ¨åŒ…å«æ‰€æœ‰è¾“å‡ºtokens',
                sectionApiInfo: 'API ä¿¡æ¯',
                labelApiUrl: 'API åœ°å€',
                labelModelName: 'æ¨¡å‹åç§°',
                labelApiKey: 'API-Key',
                placeholderApiKey: 'æœªè®¾ç½® API-Key åˆ™ç•™ç©º',
                labelNotes: 'å¤‡æ³¨',
                placeholderNotes: 'è¯·å¡«å†™è®¾å¤‡ä¿¡æ¯ã€æ¨¡å‹ä¿¡æ¯ã€æ¨¡å‹æ¨ç†æ¡†æ¶ï¼Œä»¥ä¾¿åœ¨ç»“æœä¸­æ˜¾ç¤º',
                sectionTestParams: 'æµ‹è¯•å‚æ•°é…ç½®',
                labelMinLength: 'æœ€å°æç¤ºè¯é•¿åº¦',
                labelMaxLength: 'æœ€å¤§æç¤ºè¯é•¿åº¦',
                labelStep: 'æ­¥é•¿',
                labelOutputLength: 'æœŸæœ›è¾“å‡ºé•¿åº¦',
                labelConcurrency: 'å¹¶å‘æ•°',
                labelTimeout: 'è¯·æ±‚è¶…æ—¶ (ms)',
                sectionExecTest: 'æ‰§è¡Œæµ‹è¯•',
                btnStartTest: 'å¼€å§‹æµ‹è¯•',
                btnStopTest: 'åœæ­¢æµ‹è¯•',
                btnCopyMarkdown: 'å¤åˆ¶ Markdown è¡¨æ ¼',
                btnExportCSV: 'å¯¼å‡º CSV æ•°æ®',
                btnExportCombinedChart: 'å¯¼å‡ºä¸€å¼ å›¾è¡¨',
                btnResetParams: 'ğŸ”„ é‡ç½®å‚æ•°',
                sectionComparison: 'å¤šç»“æœå¯¹æ¯”',
                labelImportFiles: 'å¯¼å…¥CSVç»“æœæ–‡ä»¶ (å¯å¤šé€‰)',
                btnStartComparison: 'ç”Ÿæˆå¯¹æ¯”å›¾è¡¨',
                comparisonNote: 'è¯´æ˜ï¼šå…ˆ"å¼€å§‹æµ‹è¯•"è¿è¡Œä¸€æ¬¡ï¼Œç„¶åå†å¯¼å…¥å…¶ä»–CSVæ–‡ä»¶ï¼Œç‚¹å‡»"ç”Ÿæˆå¯¹æ¯”å›¾è¡¨"',
                msgWaiting: 'ç­‰å¾…å¼€å§‹æµ‹è¯•...',
                chartPrefillTitle: 'é¢„å¡«å…… (Prefill) åå',
                chartDecodeTitle: 'è¾“å‡º (Decode) åå',
                chartComparisonPrefillTitle: 'å¯¹æ¯” - é¢„å¡«å…… (Prefill) åå',
                chartComparisonDecodeTitle: 'å¯¹æ¯” - è¾“å‡º (Decode) åå',
                btnExportComparisonChart: 'å¯¼å‡ºä¸€å¼ å¯¹æ¯”å›¾',
                concurrentStatsTitle: 'æ€»ååé‡æ€§èƒ½ç»Ÿè®¡',
                concurrentLabel: 'å¹¶å‘',
                // è¡¨æ ¼æ ‡é¢˜
                tableHeaderPromptLen: 'æç¤ºè¯é•¿åº¦<br>(tokens)',
                tableHeaderTTFT: 'TTFT<br>(ms)',
                tableHeaderPrefillTime: 'é¢„å¡«å……è€—æ—¶<br>(ms)',
                tableHeaderPrefillSpeed: 'é¢„å¡«å……é€Ÿåº¦<br>(tokens/s)',
                tableHeaderOutputLen: 'è¾“å‡ºé•¿åº¦<br>(tokens)',
                tableHeaderOutputTime: 'è¾“å‡ºè€—æ—¶<br>(ms)',
                tableHeaderOutputSpeed: 'è¾“å‡ºé€Ÿåº¦<br>(tokens/s)',
                tableHeaderStatus: 'çŠ¶æ€',
                tableHeaderDetail: 'è¯¦æƒ…',
                // è¯¦æƒ…å¼¹çª—
                detailBtnView: 'æŸ¥çœ‹è¯¦æƒ…',
                detailModalTitle: 'æµ‹è¯•è¯¦æƒ…',
                detailBtnClose: 'å…³é—­',
                detailBtnCopy: 'å¤åˆ¶å†…å®¹',
                detailSectionBasic: 'åŸºæœ¬ä¿¡æ¯',
                detailSectionPerformance: 'æ€§èƒ½æŒ‡æ ‡',
                detailSectionPrompt: 'æç¤ºè¯å†…å®¹',
                detailSectionOutput: 'è¾“å‡ºå†…å®¹',
                detailSectionConcurrent: 'å¹¶å‘è¯¦æƒ…',
                detailSectionRequest: 'è¯·æ±‚ä¿¡æ¯',
                detailSectionConfig: 'è¯·æ±‚é…ç½®',
                detailPromptLength: 'æç¤ºè¯é•¿åº¦:',
                detailOutputLength: 'è¾“å‡ºé•¿åº¦:',
                detailPrefillTime: 'é¢„å¡«å……è€—æ—¶:',
                detailPrefillSpeed: 'é¢„å¡«å……é€Ÿåº¦:',
                detailOutputTime: 'è¾“å‡ºè€—æ—¶:',
                detailOutputSpeed: 'è¾“å‡ºé€Ÿåº¦:',
                detailConcurrency: 'å¹¶å‘æ•°:',
                detailStatus: 'çŠ¶æ€:',
                detailRequestTime: 'è¯·æ±‚æ—¶é—´:',
                detailTimestamp: 'æµ‹è¯•æ—¶é—´:',
                detailApiType: 'APIç±»å‹:',
                detailModel: 'æ¨¡å‹:',
                detailModelName: 'æ¨¡å‹åç§°:',
                detailTemperature: 'Temperature:',
                detailTopP: 'Top P:',
                detailPromptContent: 'å®Œæ•´æç¤ºè¯:',
                detailOutputContent: 'å®Œæ•´è¾“å‡º:',
                detailReasoningContent: 'æ€è€ƒå†…å®¹',
                detailCompletionContent: 'ç­”æ¡ˆå†…å®¹',
                detailNoData: 'æ— æ•°æ®',
                detailConcurrentCount: 'å¹¶å‘è¯·æ±‚æ•°:',
                detailConcurrentItem: 'è¯·æ±‚',
                detailServerTiming: 'æœåŠ¡å™¨å¤„ç†æ—¶é—´:',
                detailNetworkTime: 'ç½‘ç»œå»¶è¿Ÿ:',
                detailCopied: 'å†…å®¹å·²å¤åˆ¶åˆ°å‰ªè´´æ¿ï¼',
                // ç»Ÿè®¡æ ‡é¢˜
                statTotalPrefillRange: 'æ€»é¢„å¡«å……ååèŒƒå›´:',
                statTotalDecodeRange: 'æ€»è¾“å‡ºååèŒƒå›´:',
                statAvgPrefill: 'å¹³å‡æ€»é¢„å¡«å……åå:',
                statAvgDecode: 'å¹³å‡æ€»è¾“å‡ºåå:',
                statPercentileTitle: 'ğŸ“Š ç™¾åˆ†ä½ç»Ÿè®¡ (P50/P90/P95)',
                statTtftPercentile: 'TTFTå»¶è¿Ÿ:',
                statPrefillPercentile: 'Prefillåå:',
                statDecodePercentile: 'Decodeåå:',
                // å›¾è¡¨ç›¸å…³
                chartLabelPrefillThroughput: 'æ€»é¢„å¡«å……åå (tokens/s)',
                chartLabelDecodeThroughput: 'æ€»è¾“å‡ºåå (tokens/s)',
                chartTitlePrefillThroughput: 'æ€»é¢„å¡«å…… (Prefill) åå',
                chartTitleDecodeThroughput: 'æ€»è¾“å‡º (Decode) åå',
                chartAxisPromptLen: 'æç¤ºè¯é•¿åº¦ (tokens)',
                chartAxisThroughput: 'åå (tokens/s)',
                chartComparisonPrefillThroughput: 'å¯¹æ¯” - æ€»é¢„å¡«å…… (Prefill) åå',
                chartComparisonDecodeThroughput: 'å¯¹æ¯” - æ€»è¾“å‡º (Decode) åå',
                // Markdown / CSV
                mdTestResults: 'æµ‹è¯•ç»“æœ',
                mdNotes: 'å¤‡æ³¨ï¼š',
                mdConcurrency: 'å¹¶å‘æ•°:',
                csvConcurrency: 'å¹¶å‘æ•°ï¼š',
                csvHeaders: 'æç¤ºè¯é•¿åº¦(tokens),é¢„å¡«å……è€—æ—¶(ms),é¢„å¡«å……é€Ÿåº¦(tokens/s),è¾“å‡ºé•¿åº¦(tokens),è¾“å‡ºè€—æ—¶(ms),è¾“å‡ºé€Ÿåº¦(tokens/s),çŠ¶æ€',
                // é”™è¯¯æ¶ˆæ¯å’Œæç¤º
                errMissingColumns: 'CSVæ–‡ä»¶ç¼ºå°‘å¿…è¦çš„åˆ— (æç¤ºè¯é•¿åº¦, é¢„å¡«å……é€Ÿåº¦, è¾“å‡ºé€Ÿåº¦)',
                errHttpError: 'HTTPé”™è¯¯! çŠ¶æ€:',
                alertMarkdownCopied: 'Markdownè¡¨æ ¼å·²å¤åˆ¶åˆ°å‰ªè´´æ¿ï¼',
                alertNoTestResults: 'è¯·å…ˆè‡³å°‘è¿è¡Œä¸€æ¬¡"å¼€å§‹æµ‹è¯•"ï¼Œä»¥ä¾¿å°†å½“å‰ç»“æœåŒ…å«åœ¨å¯¹æ¯”ä¸­ã€‚',
                btnTextStart: 'å¼€å§‹æµ‹è¯•',
                btnTextStop: 'åœæ­¢',
                // æµ‹è¯•çŠ¶æ€
                statusSuccess: 'æˆåŠŸ',
                statusFailed: 'å¤±è´¥',
                statusStopping: 'åœæ­¢ä¸­...',
                msgConcurrentSuccess: 'å¹¶å‘æˆåŠŸ',
                msgTestStopped: 'æµ‹è¯•å·²æ‰‹åŠ¨åœæ­¢ã€‚',
                msgTestCompleteNoData: 'æµ‹è¯•å®Œæˆï¼Œä½†æ²¡æœ‰æ”¶é›†åˆ°æˆåŠŸçš„æ•°æ®ã€‚',
                msgAllRequestsFailed: 'æ‰€æœ‰å¹¶å‘è¯·æ±‚å¤±è´¥',
                msgParseFileFailed: 'è§£ææ–‡ä»¶',
                msgFailed2: 'å¤±è´¥:',
                // æµ‹è¯•è¿›è¡Œä¸­çš„çŠ¶æ€
                msgTesting: 'æµ‹è¯•ä¸­...',
                msgConcurrentTesting: 'å¹¶å‘æµ‹è¯•ä¸­...',
                msgTestUnexpectedTermination: 'æµ‹è¯•æ„å¤–ç»ˆæ­¢:',
                // å¤‡æ³¨ä¿¡æ¯
                labelNotesPrefix: 'å¤‡æ³¨ï¼š',
                labelConcurrencyPrefix: 'å¹¶å‘æ•°:',
                labelTimeoutPrefix: 'è¶…æ—¶:',
                // v1.9: å†å²è®°å½•åŠŸèƒ½
                historyTitle: 'ğŸ“š å†å²è®°å½•',
                historyBtn: 'æŸ¥çœ‹å†å²è®°å½•',
                historyModalTitle: 'æµ‹è¯•å†å²è®°å½•',
                historyEmpty: 'æš‚æ— å†å²è®°å½•',
                historyRecordTime: 'æµ‹è¯•æ—¶é—´:',
                historyRecordNotes: 'å¤‡æ³¨:',
                historyRecordConfig: 'é…ç½®:',
                historyRecordModel: 'æ¨¡å‹:',
                historyRecordConcurrency: 'å¹¶å‘:',
                historyRecordPromptRange: 'æç¤ºè¯èŒƒå›´:',
                historyRecordOutputLen: 'è¾“å‡ºé•¿åº¦:',
                historyBtnView: 'æŸ¥çœ‹è¯¦æƒ…',
                historyBtnLoad: 'åŠ è½½',
                historyBtnExport: 'å¯¼å‡ºCSV',
                historyBtnDelete: 'åˆ é™¤',
                historyBtnClearAll: 'æ¸…ç©ºå…¨éƒ¨',
                historyConfirmClear: 'ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰å†å²è®°å½•å—ï¼Ÿ',
                historyConfirmDelete: 'ç¡®å®šè¦åˆ é™¤è¿™æ¡å†å²è®°å½•å—ï¼Ÿ',
                historyViewTitle: 'å†å²è®°å½•è¯¦æƒ…',
                historyBtnClose: 'å…³é—­',
                historyBtnBack: 'è¿”å›åˆ—è¡¨',
                historySaved: 'âœ“ æµ‹è¯•ç»“æœå·²è‡ªåŠ¨ä¿å­˜åˆ°å†å²è®°å½•',
                historyBtnCompare: 'ç”Ÿæˆå¯¹æ¯”å›¾è¡¨',
                historySelectedCount: 'å·²é€‰æ‹©',
                historySelectedCountSuffix: 'æ¡',
                historyCompareSuccess: 'å¯¹æ¯”å›¾è¡¨å·²ç”Ÿæˆï¼è¯·å‘ä¸‹æ»šåŠ¨æŸ¥çœ‹ã€‚',
                historySelectAtLeastOne: 'è¯·è‡³å°‘é€‰æ‹©ä¸€æ¡å†å²è®°å½•è¿›è¡Œå¯¹æ¯”'
            },
            'en': {
                pageTitle: 'LLM Prefill & Decode Performance Testing Tool v1.8 (chao mod - charts + bugfix + autosave)',
                langToggle: 'ä¸­æ–‡',
                apiOpenAI: 'OpenAI Compatible API',
                apiOllama: 'Ollama API',
                apiDescOpenAITitle: 'OpenAI Compatible API Test Description',
                apiDescOpenAI1: 'Use streaming response (stream=true) to measure time to first token',
                apiDescOpenAI2: 'Prefill speed = prompt length / (time to first token - request start time)',
                apiDescOpenAI3: 'Decode speed = output tokens / (completion time - time to first token)',
                apiDescOpenAI4: 'Works with all OpenAI API compatible LLM services',
                apiDescOpenAI5: '<strong> Supports thinking models</strong> (DeepSeek-R1, Qwen-QwQ, etc.): automatically counts total throughput (reasoning + answer tokens)',
                apiDescOllamaTitle: 'Ollama API Test Description',
                apiDescOllama1: 'Use non-streaming request (stream=false)',
                apiDescOllama2: 'Directly use prompt_eval_duration and eval_duration from API response',
                apiDescOllama3: 'Prefill speed = prompt length / (prompt_eval_duration / 1000)',
                apiDescOllama4: 'Decode speed = output tokens / (eval_duration / 1000)',
                apiDescOllama5: '<strong> Supports thinking models</strong>: eval_count automatically includes all output tokens',
                sectionApiInfo: 'API Information',
                labelApiUrl: 'API URL',
                labelModelName: 'Model Name',
                labelApiKey: 'API Key',
                placeholderApiKey: 'Leave empty if no API key is required',
                labelNotes: 'Notes',
                placeholderNotes: 'Fill in device info, model info, inference framework for display in results',
                sectionTestParams: 'Test Parameters',
                labelMinLength: 'Min Prompt Length',
                labelMaxLength: 'Max Prompt Length',
                labelStep: 'Step Size',
                labelOutputLength: 'Expected Output Length',
                labelConcurrency: 'Concurrency',
                labelTimeout: 'Request Timeout (ms)',
                sectionExecTest: 'Execute Test',
                btnStartTest: 'Start Test',
                btnStopTest: 'Stop Test',
                btnCopyMarkdown: 'Copy Markdown Table',
                btnExportCSV: 'Export CSV Data',
                btnExportCombinedChart: 'Export Combined Chart',
                btnResetParams: 'ğŸ”„ Reset Parameters',
                sectionComparison: 'Multi-Result Comparison',
                labelImportFiles: 'Import CSV result files (multiple selection)',
                btnStartComparison: 'Generate Comparison Charts',
                comparisonNote: 'Note: First run "Start Test", then import other CSV files and click "Generate Comparison Charts"',
                msgWaiting: 'Waiting to start test...',
                chartPrefillTitle: 'Prefill Throughput',
                chartDecodeTitle: 'Decode Throughput',
                chartComparisonPrefillTitle: 'Comparison - Prefill Throughput',
                chartComparisonDecodeTitle: 'Comparison - Decode Throughput',
                btnExportComparisonChart: 'Export Comparison Chart',
                concurrentStatsTitle: 'Total Throughput Performance Statistics',
                concurrentLabel: 'Concurrent',
                // Table headers
                tableHeaderPromptLen: 'Prompt Length<br>(tokens)',
                tableHeaderTTFT: 'TTFT<br>(ms)',
                tableHeaderPrefillTime: 'Prefill Time<br>(ms)',
                tableHeaderPrefillSpeed: 'Prefill Speed<br>(tokens/s)',
                tableHeaderOutputLen: 'Output Length<br>(tokens)',
                tableHeaderOutputTime: 'Output Time<br>(ms)',
                tableHeaderOutputSpeed: 'Output Speed<br>(tokens/s)',
                tableHeaderStatus: 'Status',
                tableHeaderDetail: 'Detail',
                // Detail modal
                detailBtnView: 'View Details',
                detailModalTitle: 'Test Details',
                detailBtnClose: 'Close',
                detailBtnCopy: 'Copy Content',
                detailSectionBasic: 'Basic Information',
                detailSectionPerformance: 'Performance Metrics',
                detailSectionPrompt: 'Prompt Content',
                detailSectionOutput: 'Output Content',
                detailSectionConcurrent: 'Concurrent Details',
                detailSectionRequest: 'Request Information',
                detailSectionConfig: 'Request Configuration',
                detailPromptLength: 'Prompt Length:',
                detailOutputLength: 'Output Length:',
                detailPrefillTime: 'Prefill Time:',
                detailPrefillSpeed: 'Prefill Speed:',
                detailOutputTime: 'Output Time:',
                detailOutputSpeed: 'Output Speed:',
                detailConcurrency: 'Concurrency:',
                detailStatus: 'Status:',
                detailRequestTime: 'Request Time:',
                detailTimestamp: 'Test Time:',
                detailApiType: 'API Type:',
                detailModel: 'Model:',
                detailModelName: 'Model Name:',
                detailTemperature: 'Temperature:',
                detailTopP: 'Top P:',
                detailPromptContent: 'Full Prompt:',
                detailOutputContent: 'Full Output:',
                detailReasoningContent: 'Reasoning Content',
                detailCompletionContent: 'Completion Content',
                detailNoData: 'No Data',
                detailConcurrentCount: 'Concurrent Requests:',
                detailConcurrentItem: 'Request',
                detailServerTiming: 'Server Processing Time:',
                detailNetworkTime: 'Network Latency:',
                detailCopied: 'Content copied to clipboard!',
                // Statistics
                statTotalPrefillRange: 'Total Prefill Throughput Range:',
                statTotalDecodeRange: 'Total Decode Throughput Range:',
                statAvgPrefill: 'Avg Total Prefill Throughput:',
                statAvgDecode: 'Avg Total Decode Throughput:',
                statPercentileTitle: 'ğŸ“Š Percentile Statistics (P50/P90/P95)',
                statTtftPercentile: 'TTFT Latency:',
                statPrefillPercentile: 'Prefill Throughput:',
                statDecodePercentile: 'Decode Throughput:',
                // Chart related
                chartLabelPrefillThroughput: 'Total Prefill Throughput (tokens/s)',
                chartLabelDecodeThroughput: 'Total Decode Throughput (tokens/s)',
                chartTitlePrefillThroughput: 'Total Prefill Throughput',
                chartTitleDecodeThroughput: 'Total Decode Throughput',
                chartAxisPromptLen: 'Prompt Length (tokens)',
                chartAxisThroughput: 'Throughput (tokens/s)',
                chartComparisonPrefillThroughput: 'Comparison - Total Prefill Throughput',
                chartComparisonDecodeThroughput: 'Comparison - Total Decode Throughput',
                // Markdown / CSV
                mdTestResults: 'Test Results',
                mdNotes: 'Notes:',
                mdConcurrency: 'Concurrency:',
                csvConcurrency: 'Concurrency:',
                csvHeaders: 'Prompt Length(tokens),Prefill Time(ms),Prefill Speed(tokens/s),Output Length(tokens),Output Time(ms),Output Speed(tokens/s),Status',
                // Error messages and alerts
                errMissingColumns: 'CSV file missing required columns (Prompt Length, Prefill Speed, Output Speed)',
                errHttpError: 'HTTP Error! Status:',
                alertMarkdownCopied: 'Markdown table copied to clipboard!',
                alertNoTestResults: 'Please run "Start Test" at least once to include current results in comparison.',
                btnTextStart: 'Start Test',
                btnTextStop: 'Stop',
                // Test status
                statusSuccess: 'Success',
                statusFailed: 'Failed',
                statusStopping: 'Stopping...',
                msgConcurrentSuccess: 'concurrent success',
                msgTestStopped: 'Test manually stopped.',
                msgTestCompleteNoData: 'Test completed, but no successful data collected.',
                msgAllRequestsFailed: 'All concurrent requests failed',
                msgParseFileFailed: 'Failed to parse file',
                msgFailed2: 'failed:',
                // Testing status
                msgTesting: 'Testing...',
                msgConcurrentTesting: 'concurrent testing...',
                msgTestUnexpectedTermination: 'Test unexpectedly terminated:',
                // Notes info
                labelNotesPrefix: 'Notes:',
                labelConcurrencyPrefix: 'Concurrency:',
                labelTimeoutPrefix: 'Timeout:',
                // v1.9: History feature
                historyTitle: 'ğŸ“š History',
                historyBtn: 'View History',
                historyModalTitle: 'Test History',
                historyEmpty: 'No history records',
                historyRecordTime: 'Time:',
                historyRecordNotes: 'Notes:',
                historyRecordConfig: 'Config:',
                historyRecordModel: 'Model:',
                historyRecordConcurrency: 'Concurrency:',
                historyRecordPromptRange: 'Prompt Range:',
                historyRecordOutputLen: 'Output Length:',
                historyBtnView: 'View Details',
                historyBtnLoad: 'Load',
                historyBtnExport: 'Export CSV',
                historyBtnDelete: 'Delete',
                historyBtnClearAll: 'Clear All',
                historyConfirmClear: 'Are you sure you want to clear all history records?',
                historyConfirmDelete: 'Are you sure you want to delete this record?',
                historyViewTitle: 'History Record Details',
                historyBtnClose: 'Close',
                historyBtnBack: 'Back to List',
                historySaved: 'âœ“ Test results automatically saved to history',
                historyBtnCompare: 'Generate Comparison Charts',
                historySelectedCount: 'Selected',
                historySelectedCountSuffix: 'records',
                historyCompareSuccess: 'Comparison charts generated! Please scroll down to view.',
                historySelectAtLeastOne: 'Please select at least one history record for comparison'
            }
        };

        // å½“å‰è¯­è¨€
        let currentLang = localStorage.getItem('llmPerfTestLang') || 'en';

        // åˆ‡æ¢è¯­è¨€å‡½æ•°
        function switchLanguage(lang) {
            currentLang = lang;
            localStorage.setItem('llmPerfTestLang', lang);

            const t = translations[lang];

            // æ›´æ–°é¡µé¢æ ‡é¢˜
            document.getElementById('pageTitle').textContent = t.pageTitle;
            document.getElementById('langToggle').textContent = t.langToggle;

            // æ›´æ–°APIé€‰æ‹©å™¨
            const apiOptions = document.querySelectorAll('.api-option');
            apiOptions[0].textContent = t.apiOpenAI;
            apiOptions[1].textContent = t.apiOllama;

            // æ›´æ–°APIæè¿°ï¼ˆæ ¹æ®å½“å‰é€‰ä¸­çš„ç±»å‹ï¼‰
            const activeApiType = document.querySelector('.api-option.active').dataset.type;
            updateApiDescription(activeApiType);

            // æ›´æ–°å„ä¸ªsectionæ ‡é¢˜
            const sections = document.querySelectorAll('.config-section h2, h2');
            sections[0].textContent = t.sectionApiInfo;
            sections[1].textContent = t.sectionTestParams;
            sections[2].textContent = t.sectionExecTest;
            sections[3].textContent = t.sectionComparison;

            // æ›´æ–°æ ‡ç­¾
            document.querySelector('label[for="apiUrl"]').textContent = t.labelApiUrl;
            document.querySelector('label[for="modelName"]').textContent = t.labelModelName;
            document.querySelector('label[for="apiKey"]').textContent = t.labelApiKey;
            document.getElementById('apiKey').placeholder = t.placeholderApiKey;
            document.querySelector('label[for="notes"]').textContent = t.labelNotes;
            document.getElementById('notes').placeholder = t.placeholderNotes;
            document.querySelector('label[for="minLength"]').textContent = t.labelMinLength;
            document.querySelector('label[for="maxLength"]').textContent = t.labelMaxLength;
            document.querySelector('label[for="step"]').textContent = t.labelStep;
            document.querySelector('label[for="outputLength"]').textContent = t.labelOutputLength;
            document.querySelector('label[for="concurrency"]').textContent = t.labelConcurrency;
            document.querySelector('label[for="timeout"]').textContent = t.labelTimeout;
            document.querySelector('label[for="importFiles"]').textContent = t.labelImportFiles;

            // æ›´æ–°æŒ‰é’®
            document.getElementById('startTest').textContent = t.btnStartTest;
            document.getElementById('stopTest').textContent = t.btnStopTest;
            document.getElementById('copyMarkdown').textContent = t.btnCopyMarkdown;
            document.getElementById('exportCSV').textContent = t.btnExportCSV;
            document.getElementById('exportCombinedChart').textContent = t.btnExportCombinedChart;
            document.getElementById('resetParams').textContent = t.btnResetParams;
            document.getElementById('startComparison').textContent = t.btnStartComparison;
            document.getElementById('exportComparisonChart').textContent = t.btnExportComparisonChart;

            // æ›´æ–°è¯´æ˜æ–‡å­—
            document.querySelector('.config-section p.notes').textContent = t.comparisonNote;

            // æ›´æ–°å›¾è¡¨æ ‡é¢˜
            const chartTitles = document.querySelectorAll('#chartContainer h3');
            if (chartTitles.length >= 2) {
                chartTitles[0].textContent = t.chartPrefillTitle;
                chartTitles[1].textContent = t.chartDecodeTitle;
            }

            const comparisonTitles = document.querySelectorAll('#comparisonChartContainer h3');
            if (comparisonTitles.length >= 2) {
                comparisonTitles[0].textContent = t.chartComparisonPrefillTitle;
                comparisonTitles[1].textContent = t.chartComparisonDecodeTitle;
            }

            // å¦‚æœç»“æœåŒºåŸŸæ˜¯ç­‰å¾…çŠ¶æ€ï¼Œæ›´æ–°æ–‡æœ¬
            const resultsDiv = document.getElementById('results');
            if (resultsDiv && resultsDiv.querySelector('.info')) {
                const infoElem = resultsDiv.querySelector('.info');
                if (infoElem.textContent.includes('ç­‰å¾…') || infoElem.textContent.includes('Waiting')) {
                    infoElem.textContent = t.msgWaiting;
                }
            }
        }

        // ç»‘å®šè¯­è¨€åˆ‡æ¢æŒ‰é’®
        document.getElementById('langToggle').addEventListener('click', function() {
            const newLang = currentLang === 'zh' ? 'en' : 'zh';
            switchLanguage(newLang);
        });

        // é¡µé¢åŠ è½½æ—¶åº”ç”¨ä¿å­˜çš„è¯­è¨€
        document.addEventListener('DOMContentLoaded', function() {
            switchLanguage(currentLang);
        });

        // é»˜è®¤å‚æ•°è®¾ç½®
        // ===============================================================================
        // API ç«¯ç‚¹å’Œæ¨¡å‹åç§°é…ç½®
        let d_openai_apiUrl = 'http://10.0.0.50:8000/v1/chat/completions';          // OpenAI å…¼å®¹ API çš„ URL åœ°å€
        let d_openai_modelName = 'Qwen3-30B-A3B-Instruct-2507-Int4-W4A16';                                          // OpenAI å…¼å®¹ API æ‰€ä½¿ç”¨çš„æ¨¡å‹åç§°æˆ–è·¯å¾„
        let d_ollama_apiUrl = 'http://localhost:11434/api/chat';                    // Ollama API çš„ URL åœ°å€
        let d_ollama_modelName = 'Qwen3-32B-AWQ';                                      // Ollama API æ‰€ä½¿ç”¨çš„æ¨¡å‹åç§°
        let d_api_key = '';                                                         // è®¿é—® API æ‰€éœ€çš„è®¤è¯å¯†é’¥ï¼Œå¦‚æœä¸éœ€è¦åˆ™å¯ä»¥ç•™ç©º
        // æ–‡æœ¬ç”Ÿæˆé•¿åº¦æ§åˆ¶å‚æ•° (æ•´æ•°)
        let d_minLength = 512;                                                      // ç”Ÿæˆæ–‡æœ¬çš„æœ€å°é•¿åº¦ï¼ˆä¾‹å¦‚ï¼Œtoken æˆ–å­—ç¬¦æ•°ï¼‰
        let d_maxLength = 8192;                                                     // ç”Ÿæˆæ–‡æœ¬çš„æœ€å¤§é•¿åº¦ï¼ˆä¾‹å¦‚ï¼Œtoken æˆ–å­—ç¬¦æ•°ï¼‰
        let d_step = 512;                                                           // æ¯æ¬¡æç¤ºè¯é•¿åº¦å¢åŠ çš„æ­¥é•¿
        let d_outputLength = 128;                                                   // æœŸæœ›è¾“å‡ºçš„æ–‡æœ¬é•¿åº¦
        let d_timeout = 30000;                                                      // è¯·æ±‚è¶…æ—¶æ—¶é—´ (ms)
        // æ–‡æœ¬ç”Ÿæˆé‡‡æ ·å‚æ•° (æµ®ç‚¹æ•°)
        let d_temperature = 1.0;                                                    // æ§åˆ¶ç”Ÿæˆæ–‡æœ¬çš„éšæœºæ€§ã€‚å€¼è¶Šé«˜ï¼Œæ–‡æœ¬è¶Šéšæœºï¼ˆ0.0è¡¨ç¤ºç¡®å®šæ€§ï¼Œ1.0è¡¨ç¤ºè¾ƒé«˜éšæœºæ€§ï¼‰
        let d_top_p = 0.1;                                                          // æ§åˆ¶ç”Ÿæˆæ–‡æœ¬çš„å¤šæ ·æ€§ã€‚åªè€ƒè™‘ç´¯ç§¯æ¦‚ç‡è¾¾åˆ° top_p çš„è¯æ±‡ï¼ˆ0.0-1.0ï¼‰
        let d_presence_penalty = 0.0;                                               // å¯¹ç”Ÿæˆæ–‡æœ¬ä¸­å·²ç»å‡ºç°çš„è¯æ±‡è¿›è¡Œæƒ©ç½šï¼Œå‡å°‘é‡å¤ï¼ˆé€šå¸¸åœ¨ -2.0 åˆ° 2.0 ä¹‹é—´ï¼Œè´Ÿæ•°ä¼šé¼“åŠ±é‡å¤ï¼‰
        let d_frequency_penalty = 0.0;                                              // å¯¹ç”Ÿæˆæ–‡æœ¬ä¸­è¯æ±‡å‡ºç°çš„é¢‘ç‡è¿›è¡Œæƒ©ç½šï¼Œå‡å°‘å¸¸ç”¨è¯çš„é‡å¤ï¼ˆé€šå¸¸åœ¨ -2.0 åˆ° 2.0 ä¹‹é—´ï¼Œè´Ÿæ•°ä¼šé¼“åŠ±é‡å¤ï¼‰
        // ===============================================================================

        // APIç±»å‹åˆ‡æ¢
        const apiOptions = document.querySelectorAll('.api-option');
        const apiDescription = document.getElementById('apiDescription');

        apiOptions.forEach(option => {
            option.addEventListener('click', () => {
                apiOptions.forEach(o => o.classList.remove('active'));
                option.classList.add('active');

                const apiType = option.dataset.type;
                updateApiDescription(apiType);
                updateDefaultValues(apiType);
            });
        });

        function updateApiDescription(apiType) {
            const t = translations[currentLang];
            if (apiType === 'openai') {
                apiDescription.innerHTML = `
                    <h3>${t.apiDescOpenAITitle}</h3>
                    <ul>
                        <li>${t.apiDescOpenAI1}</li>
                        <li>${t.apiDescOpenAI2}</li>
                        <li>${t.apiDescOpenAI3}</li>
                        <li>${t.apiDescOpenAI4}</li>
                        <li>${t.apiDescOpenAI5}</li>
                    </ul>
                `;
            } else {
                apiDescription.innerHTML = `
                    <h3>${t.apiDescOllamaTitle}</h3>
                    <ul>
                        <li>${t.apiDescOllama1}</li>
                        <li>${t.apiDescOllama2}</li>
                        <li>${t.apiDescOllama3}</li>
                        <li>${t.apiDescOllama4}</li>
                        <li>${t.apiDescOllama5}</li>
                    </ul>
                `;
            }
        }

        function updateDefaultValues(apiType) {
            const apiUrl = document.getElementById('apiUrl');
            const modelName = document.getElementById('modelName');

            if (apiType === 'openai') {
                apiUrl.value = d_openai_apiUrl;
                modelName.value = d_openai_modelName;
            } else {
                apiUrl.value = d_ollama_apiUrl;
                modelName.value = d_ollama_modelName;
            }
        }

        // åˆå§‹åŒ–
        updateApiDescription('openai');

        // å•è¯åº“ç”¨äºç”Ÿæˆæç¤ºè¯ï¼ˆä¸°å¯Œå¤šæ ·çš„è¯æ±‡ï¼Œæ¶µç›–ä¸åŒä¸»é¢˜å’Œè¯æ€§ï¼‰
        const wordList = [
            // ç§‘æŠ€ä¸åˆ›æ–°
            "algorithm", "artificial", "automation", "blockchain", "compute", "digital", "innovation",
            "quantum", "robotics", "software", "technology", "virtual", "network", "database",
            // è‡ªç„¶ä¸ç¯å¢ƒ
            "mountain", "ocean", "forest", "planet", "climate", "wildlife", "ecosystem", "atmosphere",
            "renewable", "sustainable", "biological", "natural", "organic", "environment",
            // ç¤¾ä¼šä¸äººæ–‡
            "community", "society", "culture", "tradition", "diversity", "equality", "justice",
            "democracy", "freedom", "humanity", "civilization", "education", "heritage", "philosophy",
            // å•†ä¸šä¸ç»æµ
            "economy", "finance", "market", "investment", "enterprise", "commerce", "industry",
            "revenue", "strategy", "competition", "management", "resource", "capital", "prosperity",
            // ç§‘å­¦ä¸çŸ¥è¯†
            "research", "science", "discovery", "experiment", "theory", "hypothesis", "evidence",
            "analysis", "knowledge", "wisdom", "intelligence", "learning", "academic", "scholarship",
            // è‰ºæœ¯ä¸åˆ›é€ 
            "creative", "artistic", "imagination", "aesthetic", "expression", "inspiration", "design",
            "architecture", "literature", "poetry", "painting", "sculpture", "performance", "melody",
            // æƒ…æ„Ÿä¸å¿ƒç†
            "emotion", "passion", "empathy", "compassion", "mindfulness", "awareness", "consciousness",
            "perception", "intuition", "reflection", "meditation", "happiness", "serenity", "gratitude",
            // æ—¶é—´ä¸ç©ºé—´
            "moment", "eternal", "temporal", "spatial", "dimension", "horizon", "infinity",
            "universe", "cosmos", "reality", "existence", "journey", "destiny", "evolution",
            // è¡ŒåŠ¨ä¸å‘å±•
            "action", "progress", "development", "advancement", "achievement", "success", "excellence",
            "improvement", "transformation", "revolution", "growth", "expansion", "breakthrough", "pioneer",
            // å…³ç³»ä¸è¿æ¥
            "connection", "relationship", "interaction", "collaboration", "communication", "cooperation",
            "harmony", "unity", "solidarity", "partnership", "network", "community", "integration", "bond"
        ];

        // æ ¹æ®æŒ‡å®šé•¿åº¦ç”Ÿæˆæç¤ºè¯
        function generatePrompt(length, apiType, seed = 0) {
            let prompt = [];

            //  æ·»åŠ å”¯ä¸€å‰ç¼€ä»¥é¿å…prefix cacheå‘½ä¸­ï¼ˆå¹¶å‘æµ‹è¯•æ—¶å¾ˆé‡è¦ï¼‰
            if (seed > 0) {
                prompt.push(`[Request-${seed}-${Date.now()}]`);
            }

            for (let i = 0; i < length - 20; i++) {
                const randomIndex = Math.floor(Math.random() * wordList.length);
                prompt.push(wordList[randomIndex]);
            }

            return prompt.join(' ') + `\nBased on the words above, write a short philosophical essay discussing the meaning of existence, the nature of consciousness, and humanity's place in the universe. Use clear, coherent sentences.`;
        }

        const startTestBtn = document.getElementById('startTest');
        const stopTestBtn = document.getElementById('stopTest');
        const copyMarkdownBtn = document.getElementById('copyMarkdown');
        const exportCSVBtn = document.getElementById('exportCSV');
        const exportCombinedChartBtn = document.getElementById('exportCombinedChart'); // v1.8
        const startComparisonBtn = document.getElementById('startComparison'); // v1.8
        const importFilesInput = document.getElementById('importFiles'); // v1.8
        const exportComparisonChartBtn = document.getElementById('exportComparisonChart'); // v1.8

        const resultsDiv = document.getElementById('results');
        const markdownOutputHidden = document.getElementById('markdownOutputHidden');
        const progressBar = document.getElementById('progressBar');

        // è·å–å›¾è¡¨å…ƒç´ 
        const chartContainer = document.getElementById('chartContainer');
        const prefillChartCanvas = document.getElementById('prefillChart');
        const outputChartCanvas = document.getElementById('outputChart');
        let prefillChartInstance = null;
        let outputChartInstance = null;

        // å¯¹æ¯”å›¾è¡¨ (v1.8)
        let comparisonData = [];
        let comparisonPrefillChartInstance = null;
        let comparisonOutputChartInstance = null;

        let testResultsData = [];
        let totalTests = 0;
        let completedTests = 0;
        let isTestingRunning = false;
        let currentApiType = 'openai';
        let currentModelName = '/model';
        let api_key = '';
        let notes = '';
        let concurrencyStats = {
            minPrefillSpeed: Infinity,
            maxPrefillSpeed: 0,
            minOutputSpeed: Infinity,
            maxOutputSpeed: 0,
            avgPrefillSpeed: 0,
            avgOutputSpeed: 0
        };

        // ===============================================================================
        // å†å²è®°å½•åŠŸèƒ½ (History Feature) - v1.9
        // ===============================================================================
        const HISTORY_STORAGE_KEY = 'llmPerfTestHistory';
        const MAX_HISTORY_RECORDS = 20; // æœ€å¤šä¿å­˜20æ¡å†å²è®°å½•

        /**
         * ä¿å­˜å½“å‰æµ‹è¯•ç»“æœåˆ°å†å²è®°å½•
         */
        function saveTestToHistory(config, results, stats) {
            try {
                const history = loadHistoryFromStorage();

                const historyRecord = {
                    id: Date.now(),
                    timestamp: new Date().toLocaleString('zh-CN', {
                        year: 'numeric',
                        month: '2-digit',
                        day: '2-digit',
                        hour: '2-digit',
                        minute: '2-digit',
                        second: '2-digit'
                    }),
                    notes: config.notes || '',
                    config: {
                        apiUrl: config.apiUrl,
                        modelName: config.modelName,
                        apiType: config.apiType,
                        minLength: config.minLength,
                        maxLength: config.maxLength,
                        step: config.step,
                        outputLength: config.outputLength,
                        concurrency: config.concurrency,
                        temperature: config.temperature,
                        topP: config.topP,
                        presencePenalty: config.presencePenalty,
                        frequencyPenalty: config.frequencyPenalty,
                        timeout: config.timeout
                    },
                    results: results, // Complete results (including promptText, etc.)
                    stats: stats // Statistics (min/max/avg/P50/P90/P95)
                };

                // æ·»åŠ åˆ°å†å²è®°å½•æ•°ç»„å¼€å¤´ï¼ˆæœ€æ–°çš„åœ¨æœ€å‰é¢ï¼‰
                history.unshift(historyRecord);

                // é™åˆ¶å†å²è®°å½•æ•°é‡
                if (history.length > MAX_HISTORY_RECORDS) {
                    history.splice(MAX_HISTORY_RECORDS);
                }

                // ä¿å­˜åˆ° localStorage
                localStorage.setItem(HISTORY_STORAGE_KEY, JSON.stringify(history));
                console.log('[å†å²è®°å½•] å·²ä¿å­˜æµ‹è¯•ç»“æœï¼Œå½“å‰å†å²è®°å½•æ•°:', history.length);

                return true;
            } catch (e) {
                console.error('[å†å²è®°å½•] ä¿å­˜å¤±è´¥:', e);

                // If quota exceeded error, show friendly message to user
                if (e.name === 'QuotaExceededError') {
                    const t = translations[currentLang];
                    const msg = currentLang === 'zh'
                        ? 'âš ï¸ å†å²è®°å½•å­˜å‚¨ç©ºé—´å·²æ»¡ï¼\n\nå½“å‰æµ‹è¯•ç»“æœæ— æ³•ä¿å­˜åˆ°å†å²è®°å½•ã€‚\n\nå»ºè®®ï¼š\n1. ç‚¹å‡»"æŸ¥çœ‹å†å²è®°å½•"æŒ‰é’®\n2. åˆ é™¤ä¸€äº›æ—§çš„å†å²è®°å½•\n3. æˆ–ç‚¹å‡»"æ¸…ç©ºå…¨éƒ¨"é‡Šæ”¾ç©ºé—´\n\næ³¨æ„ï¼šå½“å‰æµ‹è¯•ç»“æœä»ç„¶æ˜¾ç¤ºåœ¨é¡µé¢ä¸Šï¼Œä¸ä¼šä¸¢å¤±ã€‚'
                        : 'âš ï¸ History storage is full!\n\nCurrent test results cannot be saved to history.\n\nSuggestions:\n1. Click "View History" button\n2. Delete some old history records\n3. Or click "Clear All" to free up space\n\nNote: Current test results are still displayed on the page and won\'t be lost.';
                    alert(msg);
                }

                return false;
            }
        }

        /**
         * ä» localStorage åŠ è½½å†å²è®°å½•
         */
        function loadHistoryFromStorage() {
            try {
                const historyJson = localStorage.getItem(HISTORY_STORAGE_KEY);
                if (!historyJson) return [];

                const history = JSON.parse(historyJson);
                return Array.isArray(history) ? history : [];
            } catch (e) {
                console.error('[å†å²è®°å½•] åŠ è½½å¤±è´¥:', e);
                return [];
            }
        }

        /**
         * åˆ é™¤æŒ‡å®šçš„å†å²è®°å½•
         */
        function deleteHistoryRecord(recordId) {
            try {
                const history = loadHistoryFromStorage();
                const filteredHistory = history.filter(record => record.id !== recordId);
                localStorage.setItem(HISTORY_STORAGE_KEY, JSON.stringify(filteredHistory));
                console.log('[å†å²è®°å½•] å·²åˆ é™¤è®°å½• ID:', recordId);
                return true;
            } catch (e) {
                console.error('[å†å²è®°å½•] åˆ é™¤å¤±è´¥:', e);
                return false;
            }
        }

        /**
         * æ¸…ç©ºæ‰€æœ‰å†å²è®°å½•
         */
        function clearAllHistory() {
            try {
                localStorage.removeItem(HISTORY_STORAGE_KEY);
                console.log('[å†å²è®°å½•] å·²æ¸…ç©ºæ‰€æœ‰å†å²è®°å½•');
                return true;
            } catch (e) {
                console.error('[å†å²è®°å½•] æ¸…ç©ºå¤±è´¥:', e);
                return false;
            }
        }

        // å¸¦é‡è¯•çš„ fetch è¾…åŠ©å‡½æ•°
        /**
         * Fetches a resource with retry logic.
         * @param {string} apiUrl - The URL to fetch.
         * @param {object} fetchOptions - The options for the fetch call (method, headers, body).
         * @param {number} timeout - The timeout for each attempt in milliseconds.
         * @param {number} retries - The total number of attempts.
         * @param {number} delay - The delay between retries in milliseconds.
         * @returns {Promise<Response>} - A promise that resolves with the Response object.
         */
        async function createFetchPromiseWithRetry(apiUrl, fetchOptions, timeout, retries = 3, delay = 1500) {
            for (let i = 0; i < retries; i++) {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), timeout);

                try {
                    const response = await fetch(apiUrl, {
                        ...fetchOptions,
                        signal: controller.signal
                    });

                    clearTimeout(timeoutId); // Success, clear timeout

                    // Note: We return the response even if !response.ok
                    // The processing function (e.g., processOpenAIStreamResponse) is responsible for checking response.ok
                    return response; // Return the successful response

                } catch (error) {
                    clearTimeout(timeoutId); // Failed attempt

                    // Log the attempt
                    console.warn(`[RetryLogic] Attempt ${i + 1}/${retries} for ${fetchOptions.body.length} bytes failed: ${error.message}`);

                    if (i === retries - 1) {
                        // This was the last attempt, re-throw the error to be caught by allSettled
                        console.error(`[RetryLogic] All ${retries} attempts failed.`);
                        throw error;
                    }

                    // Wait before the next retry
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            }
        }


        //  Tokenä¼°ç®—å‡½æ•°ï¼ˆå½“APIä¸è¿”å›usageæ—¶çš„fallbackï¼‰
        function estimateTokenCount(text) {
            if (!text || text.length === 0) return 0;

            // ç»Ÿè®¡ä¸­æ–‡å­—ç¬¦æ•°é‡
            const chineseChars = (text.match(/[\u4e00-\u9fa5]/g) || []).length;
            // å…¶ä»–å­—ç¬¦ï¼ˆè‹±æ–‡ã€æ•°å­—ã€ç¬¦å·ç­‰ï¼‰
            const otherChars = text.length - chineseChars;

            // ç²—ç•¥ä¼°ç®—ï¼šä¸­æ–‡çº¦1.5å­—ç¬¦=1tokenï¼Œè‹±æ–‡çº¦4å­—ç¬¦=1token
            const estimatedTokens = Math.round(chineseChars / 1.5 + otherChars / 4);

            console.log(`[Tokenä¼°ç®—] æ€»å­—ç¬¦: ${text.length}, ä¸­æ–‡: ${chineseChars}, å…¶ä»–: ${otherChars}, ä¼°ç®—tokens: ${estimatedTokens}`);

            return estimatedTokens;
        }

        // ã€ä¿®å¤ã€‘æµ‹è¯•OpenAIå…¼å®¹æ¥å£
        async function testOpenAI(apiUrl, modelName, minLength, maxLength, step, outputLength, temperature, top_p, presence_penalty, frequency_penalty, concurrency, timeout) {
            for (let length = minLength; length <= maxLength; length += step) {
                if (!isTestingRunning) break;

                // F12æ§åˆ¶å°æ—¥å¿—
                console.log(`[Test] å‡†å¤‡æµ‹è¯•æç¤ºè¯é•¿åº¦: ${length}`);

                const row = document.createElement('tr');
                resultsDiv.querySelector('tbody').appendChild(row);
                const cells = [];
                for (let i = 0; i < 8; i++) {
                    const cell = document.createElement('td');
                    cells.push(cell);
                    row.appendChild(cell);
                }

                cells[0].textContent = length;
                cells[1].textContent = translations[currentLang].msgTesting;
                cells[2].textContent = translations[currentLang].msgTesting;
                cells[3].textContent = translations[currentLang].msgTesting;
                cells[4].textContent = translations[currentLang].msgTesting;
                cells[5].textContent = translations[currentLang].msgTesting;
                cells[6].textContent = `${concurrency} ${translations[currentLang].msgConcurrentTesting}`;
                cells[7].textContent = '-'; // Placeholder for detail button
                row.classList.add('info');
                resultsDiv.scrollTop = resultsDiv.scrollHeight;

                let resultEntry = {
                    promptLength: length,
                    ttftMs: 'N/A',
                    prefillTimeMs: 'N/A',
                    prefillSpeed: 'N/A',
                    outputTokens: 'N/A',
                    outputTimeMs: 'N/A',
                    outputSpeed: 'N/A',
                    status: translations[currentLang].statusFailed,
                    concurrency: concurrency,
                    // Detail data
                    promptText: '',
                    outputText: '',
                    requestConfig: {},
                    timestamp: new Date().toISOString()
                };

                // æš–æœºè¯·æ±‚ (å¯é€‰, ä¿ç•™)
                if (length == minLength) {
                    try {
                        console.log("[Test] å‘é€æš–æœºè¯·æ±‚...");
                        const controller = new AbortController();
                        const timeoutId = setTimeout(() => controller.abort(), 5000); // æš–æœº5ç§’è¶…æ—¶
                        await fetch(apiUrl, {
                            method: 'POST',
                            headers: {
                                'Authorization': `Bearer ${api_key}`,
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({
                                "model": modelName,
                                "messages": [
                                    { "role": "system", "content": "You are a helpful assistant." },
                                    { "role": "user", "content": "hello" }
                                ],
                                "max_tokens": 2, "stream": false
                            }),
                            signal: controller.signal
                        });
                        clearTimeout(timeoutId);
                        console.log("[Test] æš–æœºè¯·æ±‚å®Œæˆã€‚");
                    }
                    catch (error) { console.warn("æš–æœºè¯·æ±‚å¤±è´¥:", error.message); }
                    await new Promise(resolve => setTimeout(resolve, 800)); // æš–æœºåé¢å¤–ç­‰å¾…
                }


                const measurementPromises = [];
                let firstPrompt = ''; // ä¿å­˜ç¬¬ä¸€ä¸ªè¯·æ±‚çš„promptç”¨äºè¯¦æƒ…å±•ç¤º

                for (let i = 0; i < concurrency; i++) {
                    //  ä¼ å…¥seedç¡®ä¿æ¯ä¸ªå¹¶å‘è¯·æ±‚çš„promptéƒ½ä¸åŒï¼Œé¿å…prefix cacheå‘½ä¸­
                    const prompt = generatePrompt(length, 'openai', i + 1);
                    if (i === 0) firstPrompt = prompt; // ä¿å­˜ç¬¬ä¸€ä¸ªprompt

                    const requestBody = {
                        "model": modelName,
                        "messages": [
                            { "role": "system", "content": "You are a helpful assistant." },
                            { "role": "user", "content": prompt }
                        ],
                        "max_tokens": outputLength,
                        "temperature": temperature,
                        "top_p": top_p,
                        "presence_penalty": presence_penalty,
                        "frequency_penalty": frequency_penalty,
                        "stream": true,
                        "stream_options": { "include_usage": true }  // Request usage information
                    };

                    const fetchOptions = {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${api_key}`,
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(requestBody)
                    };

                    measurementPromises.push(
                        executeAndMeasureRequest(apiUrl, fetchOptions, timeout, length)
                    );
                }

                try {
                    const results = await Promise.allSettled(measurementPromises);

                    const concurrencyResults = [];
                    let failedMessages = [];

                    for (const result of results) {
                        if (result.status === 'fulfilled') {
                            concurrencyResults.push(result.value);
                        } else {
                            failedMessages.push(result.reason.message);
                        }
                    }

                    //
                    const avgPrefillTimeMs = concurrencyResults.reduce((sum, res) => sum + res.prefillTimeMs, 0) / concurrencyResults.length;
                    const avgOutputTokens = concurrencyResults.reduce((sum, res) => sum + res.outputTokens, 0) / concurrencyResults.length;
                    const avgOutputTimeMs = concurrencyResults.reduce((sum, res) => sum + res.outputTimeMs, 0) / concurrencyResults.length;

                    //  è·å–å®é™…çš„prompt tokenæ•°ï¼ˆAPIè¿”å›çš„å‡†ç¡®å€¼ï¼‰
                    // é˜²å¾¡æ€§ç¼–ç¨‹ï¼šå¤„ç†undefinedçš„æƒ…å†µ
                    const avgActualPromptTokens = concurrencyResults.reduce((sum, res) => {
                        const tokens = res.actualPromptTokens ?? length; // fallbackåˆ°é¢„æœŸé•¿åº¦
                        return sum + tokens;
                    }, 0) / concurrencyResults.length;

                    // è®¡ç®—æ€»åå
                    const totalPrefillSpeed = concurrencyResults.reduce((sum, res) => sum + res.prefillSpeed, 0);
                    const totalOutputSpeed = concurrencyResults.reduce((sum, res) => sum + res.outputSpeed, 0);

                    // ä»…åœ¨æˆåŠŸæ—¶æ›´æ–°ç»Ÿè®¡
                    updateConcurrencyStats(totalPrefillSpeed, totalOutputSpeed);

                    //  æ˜¾ç¤ºé¢„æœŸvså®é™…çš„tokenæ•°å·®å¼‚
                    const actualPromptLength = Math.round(avgActualPromptTokens);
                    if (actualPromptLength !== length) {
                        const diff = actualPromptLength - length;
                        const diffPercent = ((diff / length) * 100).toFixed(1);
                        console.log(`[Tokenå·®å¼‚] é¢„æœŸ: ${length}, å®é™…: ${actualPromptLength}, å·®å¼‚: ${diff > 0 ? '+' : ''}${diff} (${diffPercent}%)`);
                    }

                    resultEntry = {
                        promptLength: actualPromptLength, //  ä¿®å¤ï¼šä½¿ç”¨å®é™…tokenæ•°
                        prefillTimeMs: avgPrefillTimeMs.toFixed(2),
                        prefillSpeed: totalPrefillSpeed.toFixed(2),
                        outputTokens: avgOutputTokens.toFixed(0),
                        outputTimeMs: avgOutputTimeMs.toFixed(2),
                        outputSpeed: totalOutputSpeed.toFixed(2),
                        status: translations[currentLang].statusSuccess,
                        concurrency: concurrency,
                        // ä¿å­˜å¹¶å‘è¯¦æƒ…ï¼ˆç”¨äºP50/P90/P95ç»Ÿè®¡ï¼‰
                        concurrentDetails: concurrencyResults.map(res => ({
                            prefillTimeMs: res.prefillTimeMs,
                            prefillSpeed: res.prefillSpeed,
                            outputTokens: res.outputTokens,
                            outputTimeMs: res.outputTimeMs,
                            outputSpeed: res.outputSpeed
                        })),
                        // è¯¦æƒ…æ•°æ®ï¼šä¿å­˜ç¬¬ä¸€ä¸ªè¯·æ±‚çš„promptå’Œoutput
                        promptText: firstPrompt,
                        outputText: concurrencyResults[0]?.outputContent || '',
                        reasoningText: concurrencyResults[0]?.reasoningContent || '',
                        completionText: concurrencyResults[0]?.completionContent || '',
                        usageInfo: concurrencyResults[0]?.usageInfo || null,  // Save usage info
                        requestConfig: {
                            apiType: 'OpenAI Compatible',
                            model: modelName,
                            maxTokens: outputLength,
                            temperature: temperature,
                            topP: top_p,
                            presencePenalty: presence_penalty,
                            frequencyPenalty: frequency_penalty
                        },
                        timestamp: new Date().toISOString()
                    };

                    console.log('[Debug] OpenAI resultEntry.usageInfo:', resultEntry.usageInfo);

                    cells[0].textContent = resultEntry.promptLength; //  æ›´æ–°ä¸ºå®é™…tokenæ•°
                    cells[1].textContent = resultEntry.prefillTimeMs;
                    cells[2].textContent = resultEntry.prefillSpeed;
                    cells[3].textContent = resultEntry.outputTokens;
                    cells[4].textContent = resultEntry.outputTimeMs;
                    cells[5].textContent = resultEntry.outputSpeed;
                    // æ˜¾ç¤ºéƒ¨åˆ†æˆåŠŸ
                    cells[6].textContent = `${concurrencyResults.length}/${concurrency} ${translations[currentLang].msgConcurrentSuccess}`;

                    // æ·»åŠ è¯¦æƒ…æŒ‰é’®
                    cells[7].textContent = ''; // æ¸…ç©ºå ä½ç¬¦
                    const detailButton = document.createElement('button');
                    detailButton.className = 'detail-button';
                    detailButton.textContent = translations[currentLang].detailBtnView;
                    detailButton.onclick = () => showTestDetail(resultEntry);
                    cells[7].appendChild(detailButton);

                    row.classList.remove('info');
                    row.classList.add('success');

                } catch (error) {
                    // F12æ§åˆ¶å°é”™è¯¯æ—¥å¿—
                    console.error(`[Test] æç¤ºè¯é•¿åº¦ ${length} æµ‹è¯•å¤±è´¥:`, error);
                    resultEntry.status = `${translations[currentLang].statusFailed} (${error.message})`;
                    cells[1].textContent = 'N/A';
                    cells[2].textContent = 'N/A';
                    cells[3].textContent = 'N/A';
                    cells[4].textContent = 'N/A';
                    cells[5].textContent = 'N/A';
                    cells[6].textContent = resultEntry.status;
                    row.classList.remove('info');
                    row.classList.add('error');
                }

                testResultsData.push(resultEntry); // æ— è®ºæˆåŠŸå¤±è´¥éƒ½æ¨å…¥ï¼Œä»¥ä¾¿å›¾è¡¨æ˜¾ç¤ºæ–­ç‚¹
                generateCharts(); // å®æ—¶æ›´æ–°å›¾è¡¨
                completedTests++;
                progressBar.style.width = `${(completedTests / totalTests) * 100}%`;
                resultsDiv.scrollTop = resultsDiv.scrollHeight;

                // å¢åŠ æµ‹è¯•é—´çš„å»¶è¿Ÿ
                console.log(`[Test] é•¿åº¦ ${length} æµ‹è¯•å®Œæˆã€‚ç­‰å¾… 1.5 ç§’...`);
                await new Promise(resolve => setTimeout(resolve, 1500));
            }
        }

        async function executeAndMeasureRequest(apiUrl, fetchOptions, timeout, promptLength) {

            const startTime = performance.now();
            let firstTokenTime = null;
            let outputContent = '';
            let reasoningContent = ''; //  å•ç‹¬ç»Ÿè®¡reasoningå†…å®¹
            let actualOutputTokensFromUsage = null; //  ä»usageè·å–çš„è¾“å‡ºtokenæ•°ï¼ˆæ”¯æŒæ€è€ƒæ¨¡å‹ï¼‰
            let actualPromptTokensFromUsage = null; //  ä»usageè·å–çš„å®é™…prompt tokenæ•°
            let reasoningChunkCount = 0; //  ç»Ÿè®¡reasoning chunkæ•°é‡ï¼ˆç”¨äºfallbackï¼‰
            let contentChunkCount = 0;   //  ç»Ÿè®¡content chunkæ•°é‡ï¼ˆç”¨äºfallbackï¼‰
            let serverPrefillTimeMs = null; //  æœåŠ¡å™¨è¿”å›çš„prefillçœŸå®å¤„ç†æ—¶é—´
            let serverDecodeTimeMs = null;  //  æœåŠ¡å™¨è¿”å›çš„decodeçœŸå®å¤„ç†æ—¶é—´
            let usageInfo = null; // Save complete usage object for detail display

            const response = await createFetchPromiseWithRetry(apiUrl, fetchOptions, timeout, 3, 1500);

            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`HTTPé”™è¯¯! çŠ¶æ€: ${response.status}. å“åº”: ${errorText}`);
            }

            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            let reading = true;

            while (reading) {
                const { value, done } = await reader.read();
                if (done) {
                    reading = false;
                    break;
                }

                const chunk = decoder.decode(value, { stream: true });
                const lines = chunk.split('\n').filter(line => line.trim() !== '');

                for (const line of lines) {
                    if (line.startsWith('data: ') && !line.includes('[DONE]')) {
                        const jsonLine = line.replace('data: ', '');
                        try {
                            const data = JSON.parse(jsonLine);

                            //  è§£æusageå­—æ®µï¼ˆæµå¼å“åº”çš„æœ€åä¸€ä¸ªchunkä¼šåŒ…å«ï¼‰
                            if (data.usage) {
                                const completion = data.usage.completion_tokens || 0;
                                const reasoning = data.usage.reasoning_tokens || 0;
                                const prompt = data.usage.prompt_tokens || 0;

                                // æ€»decodeåå = æ€è€ƒtokens + ç­”æ¡ˆtokens
                                actualOutputTokensFromUsage = completion + reasoning;
                                actualPromptTokensFromUsage = prompt;

                                // Save complete usage object for detail display (include all possible fields)
                                usageInfo = { ...data.usage };
                                // If timings field exists, merge it in
                                if (data.timings) {
                                    usageInfo.timings = { ...data.timings };
                                }
                                console.log('[Debug] Captured usageInfo:', JSON.stringify(usageInfo, null, 2));

                                console.log(`[Tokenç»Ÿè®¡] prompt: ${prompt}, completion: ${completion}, reasoning: ${reasoning}, è¾“å‡ºæ€»è®¡: ${actualOutputTokensFromUsage}`);

                                //  å°è¯•æå–æœåŠ¡å™¨çš„çœŸå®å¤„ç†æ—¶é—´ï¼ˆllama.cppæ‰©å±•å­—æ®µï¼‰
                                // å¯èƒ½çš„å­—æ®µåï¼štimings, prompt_eval_duration, eval_durationç­‰
                                if (data.usage.prompt_eval_duration) {
                                    // llama.cppæ ¼å¼ï¼šçº³ç§’
                                    serverPrefillTimeMs = data.usage.prompt_eval_duration / 1_000_000;
                                } else if (data.usage.prompt_eval_time) {
                                    // å¯èƒ½æ˜¯æ¯«ç§’
                                    serverPrefillTimeMs = data.usage.prompt_eval_time;
                                }

                                if (data.usage.eval_duration) {
                                    // llama.cppæ ¼å¼ï¼šçº³ç§’
                                    serverDecodeTimeMs = data.usage.eval_duration / 1_000_000;
                                } else if (data.usage.eval_time) {
                                    // å¯èƒ½æ˜¯æ¯«ç§’
                                    serverDecodeTimeMs = data.usage.eval_time;
                                }

                                if (serverPrefillTimeMs && serverDecodeTimeMs) {
                                    console.log(`[æœåŠ¡å™¨Timing] Prefill: ${serverPrefillTimeMs.toFixed(2)}ms, Decode: ${serverDecodeTimeMs.toFixed(2)}ms`);
                                }
                            }

                            //  æ£€æŸ¥é¡¶å±‚çš„timingså­—æ®µï¼ˆæŸäº›å®ç°å¯èƒ½æ”¾åœ¨è¿™é‡Œï¼‰
                            if (data.timings) {
                                // å°è¯•å¤šç§å­—æ®µå
                                if (!serverPrefillTimeMs) {
                                    if (data.timings.prompt_eval_duration) {
                                        serverPrefillTimeMs = data.timings.prompt_eval_duration / 1_000_000; // çº³ç§’è½¬æ¯«ç§’
                                    } else if (data.timings.prompt_ms) {
                                        serverPrefillTimeMs = data.timings.prompt_ms; // å·²ç»æ˜¯æ¯«ç§’
                                    }
                                }

                                if (!serverDecodeTimeMs) {
                                    if (data.timings.eval_duration) {
                                        serverDecodeTimeMs = data.timings.eval_duration / 1_000_000; // çº³ç§’è½¬æ¯«ç§’
                                    } else if (data.timings.predicted_ms) {
                                        serverDecodeTimeMs = data.timings.predicted_ms; // å·²ç»æ˜¯æ¯«ç§’
                                    }
                                }

                                if (serverPrefillTimeMs && serverDecodeTimeMs) {
                                    console.log(`[æœåŠ¡å™¨Timing] Prefill: ${serverPrefillTimeMs.toFixed(2)}ms, Decode: ${serverDecodeTimeMs.toFixed(2)}ms (æ¥è‡ªtimingså­—æ®µ)`);
                                }
                            }

                            //  é€šç”¨fallbackï¼šæ‰“å°å®Œæ•´çš„dataç»“æ„ï¼ˆä»…åœ¨æœ€åä¸€ä¸ªchunkï¼Œä¸”æ˜¯é¦–æ¬¡æ‰“å°ï¼‰
                            if (data.usage && !window._debugDataPrinted) {
                                console.log('[è°ƒè¯•] æ”¶åˆ°usageå­—æ®µ:', JSON.stringify(data.usage, null, 2));
                                if (data.timings) {
                                    console.log('[è°ƒè¯•] æ”¶åˆ°timingså­—æ®µ:', JSON.stringify(data.timings, null, 2));
                                }
                                if (!serverPrefillTimeMs) {
                                    console.log('[è­¦å‘Š] æœªèƒ½æå–æœåŠ¡å™¨timingï¼Œä½¿ç”¨ç«¯åˆ°ç«¯æµ‹é‡ï¼ˆå«ç½‘ç»œå»¶è¿Ÿï¼‰');
                                }
                                window._debugDataPrinted = true;
                            }

                            // æ£€æŸ¥å¤šç§å¯èƒ½çš„contentä½ç½®
                            let contentText = null;
                            let isReasoningToken = false;

                            if (data.choices && data.choices[0]) {
                                const choice = data.choices[0];

                                //  æ€è€ƒæ¨¡å‹æ ¼å¼ï¼šdelta.reasoning_contentï¼ˆæ€è€ƒè¿‡ç¨‹ï¼‰
                                if (choice.delta && choice.delta.reasoning_content) {
                                    contentText = choice.delta.reasoning_content;
                                    isReasoningToken = true;
                                    reasoningChunkCount++;
                                }
                                // æ ‡å‡†OpenAIæµå¼æ ¼å¼ï¼šdelta.contentï¼ˆç­”æ¡ˆæˆ–å…¨éƒ¨å†…å®¹ï¼‰
                                else if (choice.delta && choice.delta.content) {
                                    contentText = choice.delta.content;
                                    contentChunkCount++;
                                }
                                // æŸäº›å®ç°ï¼šmessage.content
                                else if (choice.message && choice.message.content) {
                                    contentText = choice.message.content;
                                    contentChunkCount++;
                                }
                                // æŸäº›å®ç°ï¼štextå­—æ®µ
                                else if (choice.text) {
                                    contentText = choice.text;
                                    contentChunkCount++;
                                }
                            }

                            if (contentText) {
                                if (isReasoningToken) {
                                    reasoningContent += contentText;
                                } else {
                                    outputContent += contentText;
                                }

                                if (!firstTokenTime) {
                                    firstTokenTime = performance.now();
                                    const tokenType = isReasoningToken ? 'reasoning' : 'content';
                                    console.log(`[TTFT] é¦–tokenåˆ°è¾¾ï¼ˆ${tokenType}ï¼‰ï¼Œå†…å®¹: "${contentText.substring(0, 20)}..."`);
                                }
                            }
                        } catch (e) {
                            console.error('è§£æé”™è¯¯:', e, jsonLine);
                        }
                    }
                }
            }

            const endTime = performance.now();

            try {
                if (!firstTokenTime) {
                    const hasContent = (reasoningContent + outputContent).length > 0;
                    if (!hasContent) {
                       throw new Error("æœªæ”¶åˆ°ä»»ä½•token (stream ended)");
                    }
                    firstTokenTime = endTime;
                }

                //  ä¼˜å…ˆä½¿ç”¨usageä¸­çš„å‡†ç¡®tokenæ•°ï¼Œå¦‚æœæ²¡æœ‰åˆ™ä¼°ç®—/ä½¿ç”¨ä¼ å…¥å€¼
                const actualPromptTokens = actualPromptTokensFromUsage ?? promptLength; // Prefillç”¨APIè¿”å›çš„å®é™…å€¼

                //  Tokenç»Ÿè®¡ï¼šä¼˜å…ˆä½¿ç”¨usageä¸­çš„å‡†ç¡®å€¼
                let receivedTokens;

                if (actualOutputTokensFromUsage && actualOutputTokensFromUsage > 0) {
                    // ä¼˜å…ˆä½¿ç”¨APIè¿”å›çš„usage
                    receivedTokens = actualOutputTokensFromUsage;
                } else if (reasoningContent.length > 0 || outputContent.length > 0) {
                    // Fallback: ä¼°ç®—
                    const reasoningTokens = estimateTokenCount(reasoningContent);
                    const completionTokens = estimateTokenCount(outputContent);
                    receivedTokens = reasoningTokens + completionTokens;
                    console.log(`[Tokenä¼°ç®—] reasoning: ${reasoningTokens}, completion: ${completionTokens}, æ€»è®¡: ${receivedTokens}`);
                } else {
                    receivedTokens = 0;
                }

                //  è®¡ç®—æ—¶é—´ï¼šä¼˜å…ˆä½¿ç”¨æœåŠ¡å™¨çœŸå®å¤„ç†æ—¶é—´ï¼Œå¦åˆ™ä½¿ç”¨ç«¯åˆ°ç«¯æµ‹é‡
                let prefillTimeMs, outputTimeMs;
                let timeSource = '';

                if (serverPrefillTimeMs && serverDecodeTimeMs) {
                    // ä½¿ç”¨æœåŠ¡å™¨è¿”å›çš„çœŸå®GPUå¤„ç†æ—¶é—´
                    prefillTimeMs = serverPrefillTimeMs;
                    outputTimeMs = serverDecodeTimeMs;
                    timeSource = 'æœåŠ¡å™¨çœŸå®å¤„ç†æ—¶é—´';
                } else {
                    // Fallback: ä½¿ç”¨ç«¯åˆ°ç«¯æµ‹é‡ï¼ˆåŒ…å«ç½‘ç»œå»¶è¿Ÿï¼‰
                    prefillTimeMs = firstTokenTime - startTime;
                    outputTimeMs = Math.max(endTime - firstTokenTime, 1);
                    timeSource = 'ç«¯åˆ°ç«¯æµ‹é‡ï¼ˆå«ç½‘ç»œå»¶è¿Ÿï¼‰';
                }

                const prefillSpeed = (actualPromptTokens / (prefillTimeMs / 1000));
                const outputSpeed = receivedTokens > 0 ? (receivedTokens / (outputTimeMs / 1000)) : 0;

                console.log(`[é€Ÿåº¦ç»Ÿè®¡] æ—¶é—´æ¥æº: ${timeSource}`);
                console.log(`[é€Ÿåº¦ç»Ÿè®¡] Prefill: ${prefillSpeed.toFixed(2)} tok/s (${prefillTimeMs.toFixed(2)}ms), Decode: ${outputSpeed.toFixed(2)} tok/s (${outputTimeMs.toFixed(2)}ms, ${receivedTokens} tokens)`);

                return {
                    prefillTimeMs,
                    prefillSpeed,
                    outputTokens: receivedTokens,
                    outputTimeMs,
                    outputSpeed,
                    actualPromptTokens,  //  è¿”å›å®é™…çš„prompt tokenæ•°
                    outputContent: outputContent + reasoningContent,  // å®Œæ•´è¾“å‡ºå†…å®¹ï¼ˆæ€è€ƒ+ç­”æ¡ˆï¼‰
                    reasoningContent: reasoningContent,  // å•ç‹¬çš„æ€è€ƒå†…å®¹
                    completionContent: outputContent,  // å•ç‹¬çš„ç­”æ¡ˆå†…å®¹
                    usageInfo: usageInfo  // Complete usage information returned by API
                };
            } catch (error) {
                console.error(`[Error] executeAndMeasureRequestå¼‚å¸¸:`, error);
                throw error; // é‡æ–°æŠ›å‡º
            }
        }

        function updateConcurrencyStats(prefillSpeed, outputSpeed) {

            concurrencyStats.minPrefillSpeed = Math.min(concurrencyStats.minPrefillSpeed, prefillSpeed);
            concurrencyStats.maxPrefillSpeed = Math.max(concurrencyStats.maxPrefillSpeed, prefillSpeed);
            concurrencyStats.minOutputSpeed = Math.min(concurrencyStats.minOutputSpeed, outputSpeed);
            concurrencyStats.maxOutputSpeed = Math.max(concurrencyStats.maxOutputSpeed, outputSpeed);

            // é‡æ–°ä» testResultsData è®¡ç®—å¹³å‡å€¼ï¼Œç¡®ä¿å‡†ç¡®æ€§
            const allPrefillSpeeds = testResultsData
                .filter(r => (r.status === translations.zh.statusSuccess || r.status === translations.en.statusSuccess) && r.prefillSpeed !== 'N/A')
                .map(r => parseFloat(r.prefillSpeed));
            if (prefillSpeed) allPrefillSpeeds.push(prefillSpeed); // åŒ…æ‹¬å½“å‰æ‰¹æ¬¡çš„

            const allOutputSpeeds = testResultsData
                .filter(r => (r.status === translations.zh.statusSuccess || r.status === translations.en.statusSuccess) && r.outputSpeed !== 'N/A')
                .map(r => parseFloat(r.outputSpeed));
            if (outputSpeed) allOutputSpeeds.push(outputSpeed); // åŒ…æ‹¬å½“å‰æ‰¹æ¬¡çš„

            if (allPrefillSpeeds.length > 0) {
                concurrencyStats.avgPrefillSpeed = allPrefillSpeeds.reduce((sum, speed) => sum + speed, 0) / allPrefillSpeeds.length;
            }
             if (allOutputSpeeds.length > 0) {
                concurrencyStats.avgOutputSpeed = allOutputSpeeds.reduce((sum, speed) => sum + speed, 0) / allOutputSpeeds.length;
            }
        }

        /**
         * è®¡ç®—ç™¾åˆ†ä½æ•°
         * @param {Array<number>} values - æ•°å€¼æ•°ç»„
         * @param {number} percentile - ç™¾åˆ†ä½æ•° (0-100)
         * @returns {number} - ç™¾åˆ†ä½å€¼
         */
        function calculatePercentile(values, percentile) {
            if (values.length === 0) return null;
            const sorted = values.slice().sort((a, b) => a - b);
            const index = (percentile / 100) * (sorted.length - 1);
            const lower = Math.floor(index);
            const upper = Math.ceil(index);
            const weight = index % 1;
            if (lower === upper) return sorted[lower];
            return sorted[lower] * (1 - weight) + sorted[upper] * weight;
        }

        function showConcurrencyStats() {

            const statsDiv = document.createElement('div');
            statsDiv.className = 'concurrent-stats';

            // ç¡®ä¿æ˜¾ç¤ºçš„å€¼ä¸æ˜¯Infinity
            const minP = isFinite(concurrencyStats.minPrefillSpeed) ? concurrencyStats.minPrefillSpeed.toFixed(2) : 'N/A';
            const maxP = isFinite(concurrencyStats.maxPrefillSpeed) && concurrencyStats.maxPrefillSpeed > 0 ? concurrencyStats.maxPrefillSpeed.toFixed(2) : 'N/A';
            const minO = isFinite(concurrencyStats.minOutputSpeed) ? concurrencyStats.minOutputSpeed.toFixed(2) : 'N/A';
            const maxO = isFinite(concurrencyStats.maxOutputSpeed) && concurrencyStats.maxOutputSpeed > 0 ? concurrencyStats.maxOutputSpeed.toFixed(2) : 'N/A';
            const avgP = isFinite(concurrencyStats.avgPrefillSpeed) && concurrencyStats.avgPrefillSpeed > 0 ? concurrencyStats.avgPrefillSpeed.toFixed(2) : 'N/A';
            const avgO = isFinite(concurrencyStats.avgOutputSpeed) && concurrencyStats.avgOutputSpeed > 0 ? concurrencyStats.avgOutputSpeed.toFixed(2) : 'N/A';

            // æ”¶é›†æ‰€æœ‰å¹¶å‘è¯¦æƒ…æ•°æ®ç”¨äºè®¡ç®—ç™¾åˆ†ä½æ•°
            const allPrefillSpeedValues = [];
            const allDecodeSpeedValues = [];

            testResultsData.forEach(res => {
                if (res.concurrentDetails && Array.isArray(res.concurrentDetails)) {
                    res.concurrentDetails.forEach(detail => {
                        const prefillSpeed = parseFloat(detail.prefillSpeed);
                        const decodeSpeed = parseFloat(detail.outputSpeed);

                        if (!isNaN(prefillSpeed) && isFinite(prefillSpeed)) allPrefillSpeedValues.push(prefillSpeed);
                        if (!isNaN(decodeSpeed) && isFinite(decodeSpeed)) allDecodeSpeedValues.push(decodeSpeed);
                    });
                }
            });

            // è®¡ç®—ç™¾åˆ†ä½æ•°
            const prefillP50 = allPrefillSpeedValues.length > 0 ? calculatePercentile(allPrefillSpeedValues, 50).toFixed(2) : 'N/A';
            const prefillP90 = allPrefillSpeedValues.length > 0 ? calculatePercentile(allPrefillSpeedValues, 90).toFixed(2) : 'N/A';
            const prefillP95 = allPrefillSpeedValues.length > 0 ? calculatePercentile(allPrefillSpeedValues, 95).toFixed(2) : 'N/A';

            const decodeP50 = allDecodeSpeedValues.length > 0 ? calculatePercentile(allDecodeSpeedValues, 50).toFixed(2) : 'N/A';
            const decodeP90 = allDecodeSpeedValues.length > 0 ? calculatePercentile(allDecodeSpeedValues, 90).toFixed(2) : 'N/A';
            const decodeP95 = allDecodeSpeedValues.length > 0 ? calculatePercentile(allDecodeSpeedValues, 95).toFixed(2) : 'N/A';

            const t = translations[currentLang];
            statsDiv.innerHTML = `
                <h3>${t.concurrentStatsTitle} (${document.getElementById('concurrency').value} ${t.concurrentLabel})</h3>
                <div class="stat-item">
                    <span>${t.statTotalPrefillRange}</span>
                    <span class="stat-value">${minP} - ${maxP} tokens/s</span>
                </div>
                <div class="stat-item">
                    <span>${t.statTotalDecodeRange}</span>
                    <span class="stat-value">${minO} - ${maxO} tokens/s</span>
                </div>
                <div class="stat-item">
                    <span>${t.statAvgPrefill}</span>
                    <span class="stat-value">${avgP} tokens/s</span>
                </div>
                <div class="stat-item">
                    <span>${t.statAvgDecode}</span>
                    <span class="stat-value">${avgO} tokens/s</span>
                </div>
                <hr style="margin: 10px 0; border: none; border-top: 1px solid #ddd;">
                <h4 style="margin: 10px 0; font-size: 14px; color: #555;">${t.statPercentileTitle}</h4>
                <div class="stat-item">
                    <span>${t.statPrefillPercentile}</span>
                    <span class="stat-value">P50: ${prefillP50} | P90: ${prefillP90} | P95: ${prefillP95} tokens/s</span>
                </div>
                <div class="stat-item">
                    <span>${t.statDecodePercentile}</span>
                    <span class="stat-value">P50: ${decodeP50} | P90: ${decodeP90} | P95: ${decodeP95} tokens/s</span>
                </div>
            `;
            resultsDiv.appendChild(statsDiv);

            // è¿”å›ç»Ÿè®¡æ•°æ®ï¼ˆç”¨äºä¿å­˜å†å²è®°å½•ï¼‰
            return {
                prefill: {
                    min: minP,
                    max: maxP,
                    avg: avgP,
                    p50: prefillP50,
                    p90: prefillP90,
                    p95: prefillP95
                },
                decode: {
                    min: minO,
                    max: maxO,
                    avg: avgO,
                    p50: decodeP50,
                    p90: decodeP90,
                    p95: decodeP95
                }
            };
        }

        // ã€ä¿®å¤ã€‘æµ‹è¯•Ollamaæ¥å£
        async function testOllama(apiUrl, modelName, minLength, maxLength, step, outputLength, temperature, top_p, presence_penalty, frequency_penalty, concurrency, timeout) {
             for (let length = minLength; length <= maxLength; length += step) {
                if (!isTestingRunning) break;

                // F12æ§åˆ¶å°æ—¥å¿—
                console.log(`[Test] å‡†å¤‡æµ‹è¯•æç¤ºè¯é•¿åº¦: ${length}`);

                const row = document.createElement('tr');
                resultsDiv.querySelector('tbody').appendChild(row);
                const cells = [];
                for (let i = 0; i < 8; i++) {
                    const cell = document.createElement('td');
                    cells.push(cell);
                    row.appendChild(cell);
                }

                cells[0].textContent = length;
                cells[1].textContent = translations[currentLang].msgTesting;
                cells[2].textContent = translations[currentLang].msgTesting;
                cells[3].textContent = translations[currentLang].msgTesting;
                cells[4].textContent = translations[currentLang].msgTesting;
                cells[5].textContent = translations[currentLang].msgTesting;
                cells[6].textContent = `${concurrency} ${translations[currentLang].msgConcurrentTesting}`;
                cells[7].textContent = '-'; // Placeholder for detail button
                row.classList.add('info');
                resultsDiv.scrollTop = resultsDiv.scrollHeight;

                let resultEntry = {
                    promptLength: length,
                    ttftMs: 'N/A',
                    prefillTimeMs: 'N/A',
                    prefillSpeed: 'N/A',
                    outputTokens: 'N/A',
                    outputTimeMs: 'N/A',
                    outputSpeed: 'N/A',
                    status: translations[currentLang].statusFailed,
                    concurrency: concurrency,
                    // Detail data
                    promptText: '',
                    outputText: '',
                    requestConfig: {},
                    timestamp: new Date().toISOString()
                };

                // æš–æœº
                if (length == minLength) {
                    try {
                        console.log("[Test] å‘é€æš–æœºè¯·æ±‚...");
                        const controller = new AbortController();
                        const timeoutId = setTimeout(() => controller.abort(), 5000);
                        await fetch(apiUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json', },
                            body: JSON.stringify({
                                "model": modelName,
                                "messages": [
                                    { "role": "system", "content": "You are a helpful assistant." },
                                    { "role": "user", "content": "hello" }
                                ],
                                "options": { "num_predict": 2 }, "stream": false
                            }),
                            signal: controller.signal
                        });
                        clearTimeout(timeoutId);
                        console.log("[Test] æš–æœºè¯·æ±‚å®Œæˆã€‚");
                    }
                    catch (error) { console.warn("æš–æœºè¯·æ±‚å¤±è´¥:", error.message); }
                    await new Promise(resolve => setTimeout(resolve, 800));
                }

                const requests = [];
                let firstPrompt = ''; // ä¿å­˜ç¬¬ä¸€ä¸ªè¯·æ±‚çš„promptç”¨äºè¯¦æƒ…å±•ç¤º

                for (let i = 0; i < concurrency; i++) {
                    const prompt = generatePrompt(length, 'ollama', i + 1);
                    if (i === 0) firstPrompt = prompt; // ä¿å­˜ç¬¬ä¸€ä¸ªprompt

                    const requestBody = {
                        "model": modelName,
                        "messages": [
                            { "role": "system", "content": "You are a helpful assistant." },
                            { "role": "user", "content": prompt }
                        ],
                        "options": {
                            "num_predict": outputLength,
                            "num_ctx": maxLength, // Ollama é€šå¸¸ç”¨ num_ctx é™åˆ¶ä¸Šä¸‹æ–‡
                            "temperature": temperature,
                            "top_p": top_p,
                            "repeat_penalty": 1.1 // åˆå¹¶ presence å’Œ frequency (Ollama ä¸åŒºåˆ†)
                        },
                        "stream": false
                    };

                    // ä½¿ç”¨å¸¦é‡è¯•çš„ fetch
                    const fetchOptions = {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(requestBody)
                    };

                    const fetchPromise = createFetchPromiseWithRetry(apiUrl, fetchOptions, timeout, 3, 1500);
                    requests.push(fetchPromise);
                }

                try {
                    const responses = await Promise.allSettled(requests);
                    const processPromises = [];
                    let failedMessages = [];

                    for (const result of responses) {
                        if (result.status === 'fulfilled' && result.value.ok) {
                            processPromises.push(processOllamaResponse(result.value, length));
                        } else {
                            if (result.status === 'rejected') {
                                failedMessages.push(result.reason.message);
                            } else {
                                failedMessages.push(`HTTP ${result.value.status}`);
                            }
                        }
                    }

                    // (v1.8 bug fix) ç­‰å¾…æ‰€æœ‰æˆåŠŸçš„å“åº”è¢«å¤„ç†
                    const concurrencyResults = [];
                    const processedResponses = await Promise.allSettled(processPromises);

                    for (const result of processedResponses) {
                        if (result.status === 'fulfilled') {
                            concurrencyResults.push(result.value);
                        } else {
                            failedMessages.push(result.reason.message);
                        }
                    }

                    if (concurrencyResults.length === 0) {
                         throw new Error(`${translations[currentLang].msgAllRequestsFailed}: ${failedMessages.join(', ')}`);
                    }

                    const avgPrefillTimeMs = concurrencyResults.reduce((sum, res) => sum + res.prefillTimeMs, 0) / concurrencyResults.length;
                    const avgOutputTokens = concurrencyResults.reduce((sum, res) => sum + res.outputTokens, 0) / concurrencyResults.length;
                    const avgOutputTimeMs = concurrencyResults.reduce((sum, res) => sum + res.outputTimeMs, 0) / concurrencyResults.length;

                    //  è·å–å®é™…çš„prompt tokenæ•°ï¼ˆOllama APIè¿”å›çš„å‡†ç¡®å€¼ï¼‰
                    // é˜²å¾¡æ€§ç¼–ç¨‹ï¼šå¤„ç†undefinedçš„æƒ…å†µ
                    const avgActualPromptTokens = concurrencyResults.reduce((sum, res) => {
                        const tokens = res.actualPromptTokens ?? length; // fallbackåˆ°é¢„æœŸé•¿åº¦
                        return sum + tokens;
                    }, 0) / concurrencyResults.length;

                    //
                    const totalPrefillSpeed = concurrencyResults.reduce((sum, res) => sum + res.prefillSpeed, 0);
                    const totalOutputSpeed = concurrencyResults.reduce((sum, res) => sum + res.outputSpeed, 0);

                    updateConcurrencyStats(totalPrefillSpeed, totalOutputSpeed);

                    //  æ˜¾ç¤ºé¢„æœŸvså®é™…çš„tokenæ•°å·®å¼‚
                    const actualPromptLength = Math.round(avgActualPromptTokens);
                    if (actualPromptLength !== length) {
                        const diff = actualPromptLength - length;
                        const diffPercent = ((diff / length) * 100).toFixed(1);
                        console.log(`[Ollama Tokenå·®å¼‚] é¢„æœŸ: ${length}, å®é™…: ${actualPromptLength}, å·®å¼‚: ${diff > 0 ? '+' : ''}${diff} (${diffPercent}%)`);
                    }

                    resultEntry = {
                        promptLength: actualPromptLength, //  ä¿®å¤ï¼šä½¿ç”¨å®é™…tokenæ•°
                        prefillTimeMs: avgPrefillTimeMs.toFixed(2),
                        prefillSpeed: totalPrefillSpeed.toFixed(2),
                        outputTokens: avgOutputTokens.toFixed(0),
                        outputTimeMs: avgOutputTimeMs.toFixed(2),
                        outputSpeed: totalOutputSpeed.toFixed(2),
                        status: translations[currentLang].statusSuccess,
                        concurrency: concurrency,
                        // ä¿å­˜å¹¶å‘è¯¦æƒ…ï¼ˆç”¨äºP50/P90/P95ç»Ÿè®¡ï¼‰
                        concurrentDetails: concurrencyResults.map(res => ({
                            prefillTimeMs: res.prefillTimeMs,
                            prefillSpeed: res.prefillSpeed,
                            outputTokens: res.outputTokens,
                            outputTimeMs: res.outputTimeMs,
                            outputSpeed: res.outputSpeed
                        })),
                        // è¯¦æƒ…æ•°æ®ï¼šä¿å­˜ç¬¬ä¸€ä¸ªè¯·æ±‚çš„promptå’Œoutput
                        promptText: firstPrompt,
                        outputText: concurrencyResults[0]?.outputContent || '',
                        reasoningText: concurrencyResults[0]?.reasoningContent || '',
                        completionText: concurrencyResults[0]?.completionContent || '',
                        usageInfo: concurrencyResults[0]?.usageInfo || null,  // Save usage info
                        requestConfig: {
                            apiType: 'Ollama',
                            model: modelName,
                            numPredict: outputLength,
                            temperature: temperature,
                            topP: top_p,
                            repeatPenalty: 1.1
                        },
                        timestamp: new Date().toISOString()
                    };

                    console.log('[Debug] Ollama resultEntry.usageInfo:', resultEntry.usageInfo);

                    cells[0].textContent = resultEntry.promptLength; //  æ›´æ–°ä¸ºå®é™…tokenæ•°
                    cells[1].textContent = resultEntry.prefillTimeMs;
                    cells[2].textContent = resultEntry.prefillSpeed;
                    cells[3].textContent = resultEntry.outputTokens;
                    cells[4].textContent = resultEntry.outputTimeMs;
                    cells[5].textContent = resultEntry.outputSpeed;
                    cells[6].textContent = `${concurrencyResults.length}/${concurrency} ${translations[currentLang].msgConcurrentSuccess}`;

                    // æ·»åŠ è¯¦æƒ…æŒ‰é’®
                    cells[7].textContent = ''; // æ¸…ç©ºå ä½ç¬¦
                    const detailButton = document.createElement('button');
                    detailButton.className = 'detail-button';
                    detailButton.textContent = translations[currentLang].detailBtnView;
                    detailButton.onclick = () => showTestDetail(resultEntry);
                    cells[7].appendChild(detailButton);

                    row.classList.remove('info');
                    row.classList.add('success');

                } catch (error) {
                    // F12æ§åˆ¶å°é”™è¯¯æ—¥å¿—
                    console.error(`[Test] æç¤ºè¯é•¿åº¦ ${length} æµ‹è¯•å¤±è´¥:`, error);
                    resultEntry.status = `${translations[currentLang].statusFailed} (${error.message})`;
                    cells[1].textContent = 'N/A';
                    cells[2].textContent = 'N/A';
                    cells[3].textContent = 'N/A';
                    cells[4].textContent = 'N/A';
                    cells[5].textContent = 'N/A';
                    cells[6].textContent = resultEntry.status;
                    row.classList.remove('info');
                    row.classList.add('error');
                }

                testResultsData.push(resultEntry);
                generateCharts(); // å®æ—¶æ›´æ–°å›¾è¡¨
                completedTests++;
                progressBar.style.width = `${(completedTests / totalTests) * 100}%`;
                resultsDiv.scrollTop = resultsDiv.scrollHeight;

                // å¢åŠ æµ‹è¯•é—´çš„å»¶è¿Ÿ
                console.log(`[Test] é•¿åº¦ ${length} æµ‹è¯•å®Œæˆã€‚ç­‰å¾… 1.5 ç§’...`);
                await new Promise(resolve => setTimeout(resolve, 1500));
            }
        }

        async function processOllamaResponse(response, promptLength) {

            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`HTTP é”™è¯¯! çŠ¶æ€: ${response.status}. å“åº”: ${errorText}`);
            }

            const data = await response.json();

            if (data.error) {
                throw new Error(`Ollama é”™è¯¯: ${data.error}`);
            }

            if (!data.prompt_eval_duration || !data.eval_duration) {
                throw new Error("Ollama å“åº”ä¸­ç¼ºå°‘*durationå­—æ®µ");
            }

            // prompt_eval_duration å’Œ eval_duration æ˜¯çº³ç§’ (ns)
            const prefillDurationMs = data.prompt_eval_duration / 1_000_000;

            //  Ollamaçš„eval_countå·²ç»åŒ…å«æ‰€æœ‰è¾“å‡ºtokenï¼ˆå¦‚æœæ˜¯æ€è€ƒæ¨¡å‹ï¼ŒåŒ…æ‹¬æ€è€ƒ+ç­”æ¡ˆï¼‰
            // æ³¨æ„ï¼šOllamaç›®å‰æ²¡æœ‰å•ç‹¬çš„reasoning_tokenså­—æ®µï¼Œä½†eval_countæ˜¯å‡†ç¡®çš„æ€»æ•°
            const actualOutputTokens = data.eval_count;
            const outputDurationMs = Math.max(data.eval_duration / 1_000_000, 1); // ns to ms, æœ€å° 1ms

            //  Ollamaè¿”å›çš„å®é™…prompt tokenæ•°
            const actualPromptTokens = data.prompt_eval_count || promptLength;

            console.log(`[Ollama Tokenç»Ÿè®¡] prompt_eval_count: ${actualPromptTokens}, eval_count: ${actualOutputTokens}, prompt_eval_duration: ${data.prompt_eval_duration}ns`);

            //  ä¿®å¤ï¼šä½¿ç”¨å®é™…çš„prompt tokenæ•°
            const prefillSpeed = (actualPromptTokens / (prefillDurationMs / 1000));
            const outputSpeed = actualOutputTokens > 0 ? (actualOutputTokens / (outputDurationMs / 1000)) : 0;

            // æå–è¾“å‡ºå†…å®¹
            const outputText = data.message?.content || '';

            // Construct usageInfo object (Ollama format)
            const usageInfo = {
                prompt_eval_count: data.prompt_eval_count,
                eval_count: data.eval_count,
                prompt_eval_duration: data.prompt_eval_duration,
                eval_duration: data.eval_duration
            };
            console.log('[Debug] Ollama usageInfo:', JSON.stringify(usageInfo, null, 2));

            return {
                prefillTimeMs: prefillDurationMs,
                prefillSpeed: prefillSpeed,
                outputTokens: actualOutputTokens,
                outputTimeMs: outputDurationMs,
                outputSpeed: outputSpeed,
                actualPromptTokens: actualPromptTokens,  //  è¿”å›å®é™…çš„prompt tokenæ•°
                outputContent: outputText,  // å®Œæ•´è¾“å‡ºå†…å®¹
                reasoningContent: '',  // Ollamaç›®å‰ä¸å•ç‹¬åŒºåˆ†æ€è€ƒå†…å®¹
                completionContent: outputText,  // ç­”æ¡ˆå†…å®¹
                usageInfo: usageInfo  // Complete usage information returned by API
            };
        }

        // æ˜¾ç¤ºæµ‹è¯•è¯¦æƒ…å¼¹çª—
        function showTestDetail(testData) {
            const t = translations[currentLang];

            // Debug: output testData and usageInfo
            console.log('[Debug] testData:', testData);
            console.log('[Debug] usageInfo:', testData.usageInfo);

            // ç¦æ­¢é¡µé¢æ»šåŠ¨
            document.body.style.overflow = 'hidden';

            // åˆ›å»ºé®ç½©å±‚
            const overlay = document.createElement('div');
            overlay.className = 'detail-overlay';

            // åˆ›å»ºå¯¹è¯æ¡†
            const dialog = document.createElement('div');
            dialog.className = 'detail-dialog';

            // æ„å»ºè¯¦æƒ…å†…å®¹
            let detailHTML = `
                <div class="detail-header">
                    <div class="detail-title">${t.detailModalTitle}</div>
                    <button type="button" class="detail-close-button">${t.detailBtnClose}</button>
                </div>
                <div class="detail-body">
                    <!-- åŸºæœ¬ä¿¡æ¯ -->
                    <div class="detail-section">
                        <div class="detail-section-title">${t.detailSectionBasic}</div>
                        <div class="detail-info-grid">
                            <div class="detail-info-item">
                                <span class="detail-label">${t.detailApiType}:</span>
                                <span class="detail-value">${testData.requestConfig?.apiType || 'N/A'}</span>
                            </div>
                            <div class="detail-info-item">
                                <span class="detail-label">${t.detailModel}:</span>
                                <span class="detail-value">${testData.requestConfig?.model || 'N/A'}</span>
                            </div>
                            <div class="detail-info-item">
                                <span class="detail-label">${t.detailPromptLength}:</span>
                                <span class="detail-value">${testData.promptLength} tokens</span>
                            </div>
                            <div class="detail-info-item">
                                <span class="detail-label">${t.detailOutputLength}:</span>
                                <span class="detail-value">${testData.outputTokens} tokens</span>
                            </div>
                            <div class="detail-info-item">
                                <span class="detail-label">${t.detailConcurrency}:</span>
                                <span class="detail-value">${testData.concurrency}</span>
                            </div>
                            <div class="detail-info-item">
                                <span class="detail-label">${t.detailTimestamp}:</span>
                                <span class="detail-value">${new Date(testData.timestamp).toLocaleString()}</span>
                            </div>
                        </div>
                    </div>

                    <!-- æ€§èƒ½æŒ‡æ ‡ -->
                    <div class="detail-section">
                        <div class="detail-section-title">${t.detailSectionPerformance}</div>
                        <div class="detail-info-grid">
                            <div class="detail-info-item">
                                <span class="detail-label">${t.tableHeaderPrefillTime}:</span>
                                <span class="detail-value">${testData.prefillTimeMs} ms</span>
                            </div>
                            <div class="detail-info-item">
                                <span class="detail-label">${t.tableHeaderPrefillSpeed}:</span>
                                <span class="detail-value">${testData.prefillSpeed} tokens/s</span>
                            </div>
                            <div class="detail-info-item">
                                <span class="detail-label">${t.tableHeaderOutputTime}:</span>
                                <span class="detail-value">${testData.outputTimeMs} ms</span>
                            </div>
                            <div class="detail-info-item">
                                <span class="detail-label">${t.tableHeaderOutputSpeed}:</span>
                                <span class="detail-value">${testData.outputSpeed} tokens/s</span>
                            </div>
                            <div class="detail-info-item">
                                <span class="detail-label">${t.tableHeaderStatus}:</span>
                                <span class="detail-value">${testData.status}</span>
                            </div>
                        </div>
                    </div>

                    <!-- API Usage Statistics -->
                    ${testData.usageInfo ? `
                    <div class="detail-section">
                        <div class="detail-section-title">${t.detailSectionUsage}</div>
                        <div class="detail-info-grid">
                            ${testData.usageInfo.prompt_tokens !== undefined ? `
                            <div class="detail-info-item">
                                <span class="detail-label">${t.detailUsagePromptTokens}:</span>
                                <span class="detail-value">${testData.usageInfo.prompt_tokens}</span>
                            </div>` : ''}
                            ${testData.usageInfo.completion_tokens !== undefined ? `
                            <div class="detail-info-item">
                                <span class="detail-label">${t.detailUsageCompletionTokens}:</span>
                                <span class="detail-value">${testData.usageInfo.completion_tokens}</span>
                            </div>` : ''}
                            ${testData.usageInfo.total_tokens !== undefined ? `
                            <div class="detail-info-item">
                                <span class="detail-label">${t.detailUsageTotalTokens}:</span>
                                <span class="detail-value">${testData.usageInfo.total_tokens}</span>
                            </div>` : ''}
                            ${testData.usageInfo.reasoning_tokens !== undefined ? `
                            <div class="detail-info-item">
                                <span class="detail-label">${t.detailUsageReasoningTokens}:</span>
                                <span class="detail-value">${testData.usageInfo.reasoning_tokens}</span>
                            </div>` : ''}
                            ${testData.usageInfo.prompt_eval_count !== undefined ? `
                            <div class="detail-info-item">
                                <span class="detail-label">${t.detailUsagePromptEvalCount}:</span>
                                <span class="detail-value">${testData.usageInfo.prompt_eval_count}</span>
                            </div>` : ''}
                            ${testData.usageInfo.eval_count !== undefined ? `
                            <div class="detail-info-item">
                                <span class="detail-label">${t.detailUsageEvalCount}:</span>
                                <span class="detail-value">${testData.usageInfo.eval_count}</span>
                            </div>` : ''}
                            ${testData.usageInfo.prompt_eval_duration !== undefined ? `
                            <div class="detail-info-item">
                                <span class="detail-label">${t.detailUsagePromptEvalDuration}:</span>
                                <span class="detail-value">${(testData.usageInfo.prompt_eval_duration / 1000000).toFixed(2)} ms</span>
                            </div>` : ''}
                            ${testData.usageInfo.eval_duration !== undefined ? `
                            <div class="detail-info-item">
                                <span class="detail-label">${t.detailUsageEvalDuration}:</span>
                                <span class="detail-value">${(testData.usageInfo.eval_duration / 1000000).toFixed(2)} ms</span>
                            </div>` : ''}
                            ${testData.usageInfo.prompt_time !== undefined ? `
                            <div class="detail-info-item">
                                <span class="detail-label">${t.detailUsagePromptTime}:</span>
                                <span class="detail-value">${testData.usageInfo.prompt_time.toFixed(2)} s</span>
                            </div>` : ''}
                            ${testData.usageInfo.completion_time !== undefined ? `
                            <div class="detail-info-item">
                                <span class="detail-label">${t.detailUsageCompletionTime}:</span>
                                <span class="detail-value">${testData.usageInfo.completion_time.toFixed(2)} s</span>
                            </div>` : ''}
                            ${testData.usageInfo.queue_time !== undefined ? `
                            <div class="detail-info-item">
                                <span class="detail-label">${t.detailUsageQueueTime}:</span>
                                <span class="detail-value">${testData.usageInfo.queue_time.toFixed(2)} s</span>
                            </div>` : ''}
                            ${testData.usageInfo.prompt_tokens_details?.cached_tokens !== undefined ? `
                            <div class="detail-info-item">
                                <span class="detail-label">Cached Tokens:</span>
                                <span class="detail-value">${testData.usageInfo.prompt_tokens_details.cached_tokens}</span>
                            </div>` : ''}
                            ${testData.usageInfo.completion_tokens_details?.reasoning_tokens !== undefined ? `
                            <div class="detail-info-item">
                                <span class="detail-label">Reasoning Tokens (detail):</span>
                                <span class="detail-value">${testData.usageInfo.completion_tokens_details.reasoning_tokens}</span>
                            </div>` : ''}
                            ${testData.usageInfo.timings ? Object.keys(testData.usageInfo.timings).map(key => `
                            <div class="detail-info-item">
                                <span class="detail-label">Timings.${key}:</span>
                                <span class="detail-value">${typeof testData.usageInfo.timings[key] === 'number' ? testData.usageInfo.timings[key].toFixed(2) : testData.usageInfo.timings[key]}</span>
                            </div>`).join('') : ''}
                        </div>
                    </div>
                    ` : ''}

                    <!-- è¯·æ±‚é…ç½® -->
                    <div class="detail-section">
                        <div class="detail-section-title">${t.detailSectionConfig}</div>
                        <div class="detail-info-grid">
                            ${testData.requestConfig?.temperature !== undefined ? `
                            <div class="detail-info-item">
                                <span class="detail-label">Temperature:</span>
                                <span class="detail-value">${testData.requestConfig.temperature}</span>
                            </div>` : ''}
                            ${testData.requestConfig?.topP !== undefined ? `
                            <div class="detail-info-item">
                                <span class="detail-label">Top P:</span>
                                <span class="detail-value">${testData.requestConfig.topP}</span>
                            </div>` : ''}
                            ${testData.requestConfig?.maxTokens !== undefined ? `
                            <div class="detail-info-item">
                                <span class="detail-label">Max Tokens:</span>
                                <span class="detail-value">${testData.requestConfig.maxTokens}</span>
                            </div>` : ''}
                            ${testData.requestConfig?.numPredict !== undefined ? `
                            <div class="detail-info-item">
                                <span class="detail-label">Num Predict:</span>
                                <span class="detail-value">${testData.requestConfig.numPredict}</span>
                            </div>` : ''}
                        </div>
                    </div>

                    <!-- æç¤ºè¯å†…å®¹ -->
                    <div class="detail-section">
                        <div class="detail-section-title">${t.detailSectionPrompt}</div>
                        <div class="detail-content-block detail-prompt-content">
                            <pre>${testData.promptText || t.detailNoData}</pre>
                        </div>
                        <button class="detail-copy-button" data-content="${testData.promptText?.replace(/"/g, '&quot;') || ''}">${t.detailBtnCopy}</button>
                    </div>

                    <!-- è¾“å‡ºå†…å®¹ -->
                    <div class="detail-section">
                        <div class="detail-section-title">${t.detailSectionOutput}</div>
                        ${testData.reasoningText ? `
                        <div class="detail-subsection-title">${t.detailReasoningContent}:</div>
                        <div class="detail-content-block detail-reasoning-content">
                            <pre>${testData.reasoningText}</pre>
                        </div>
                        ` : ''}
                        ${testData.completionText ? `
                        <div class="detail-subsection-title">${t.detailCompletionContent}:</div>
                        <div class="detail-content-block detail-output-content">
                            <pre>${testData.completionText}</pre>
                        </div>
                        ` : ''}
                        ${!testData.reasoningText && !testData.completionText && testData.outputText ? `
                        <div class="detail-content-block detail-output-content">
                            <pre>${testData.outputText}</pre>
                        </div>
                        ` : ''}
                        ${!testData.outputText && !testData.reasoningText && !testData.completionText ? `
                        <div class="detail-content-block">
                            <pre>${t.detailNoData}</pre>
                        </div>
                        ` : ''}
                        <button class="detail-copy-button" data-content="${(testData.outputText || testData.completionText || '').replace(/"/g, '&quot;')}">${t.detailBtnCopy}</button>
                    </div>
                </div>
            `;

            dialog.innerHTML = detailHTML;
            overlay.appendChild(dialog);
            document.body.appendChild(overlay);

            // å…³é—­æŒ‰é’®äº‹ä»¶
            const closeBtn = dialog.querySelector('.detail-close-button');
            closeBtn.onclick = () => {
                document.body.removeChild(overlay);
                document.body.style.overflow = '';
            };

            // ç‚¹å‡»é®ç½©å±‚å…³é—­
            overlay.onclick = (e) => {
                if (e.target === overlay) {
                    document.body.removeChild(overlay);
                    document.body.style.overflow = '';
                }
            };

            // å¤åˆ¶æŒ‰é’®äº‹ä»¶
            const copyButtons = dialog.querySelectorAll('.detail-copy-button');
            copyButtons.forEach(btn => {
                btn.onclick = () => {
                    const content = btn.getAttribute('data-content');
                    if (content) {
                        navigator.clipboard.writeText(content).then(() => {
                            const originalText = btn.textContent;
                            btn.textContent = t.detailCopied || 'Copied!';
                            setTimeout(() => {
                                btn.textContent = originalText;
                            }, 2000);
                        });
                    }
                };
            });
        }

        startTestBtn.addEventListener('click', async () => {
            // v1.8: éšè—å¯¹æ¯”å›¾è¡¨å¹¶æ¸…ç©ºæ•°æ®
            document.getElementById('comparisonChartContainer').style.display = 'none';
            exportComparisonChartBtn.style.display = 'none'; // v1.8
            if (comparisonPrefillChartInstance) comparisonPrefillChartInstance.destroy();
            if (comparisonOutputChartInstance) comparisonOutputChartInstance.destroy();
            comparisonPrefillChartInstance = null;
            comparisonOutputChartInstance = null;
            comparisonData = [];
            importFilesInput.value = ""; // æ¸…ç©ºæ–‡ä»¶é€‰æ‹©

            currentApiType = document.querySelector('.api-option.active').dataset.type;
            const apiUrl = document.getElementById('apiUrl').value.trim();
            currentModelName = document.getElementById('modelName').value.trim();
            api_key = document.getElementById('apiKey').value.trim();
            notes = document.getElementById('notes').value.trim() || `æ— ç”¨æˆ·å¤‡æ³¨ï¼Œæ¥å£: ${currentApiType === 'openai' ? 'OpenAIå…¼å®¹æ¥å£' : 'Ollamaæ¥å£'} ï¼Œæ¨¡å‹: ${currentModelName}`;
            const minLength = parseInt(document.getElementById('minLength').value, 10);
            const maxLength = parseInt(document.getElementById('maxLength').value, 10);
            const step = parseInt(document.getElementById('step').value, 10);
            const outputLength = parseInt(document.getElementById('outputLength').value, 10);
            const concurrency = parseInt(document.getElementById('concurrency').value, 10) || 1;
            const timeout = parseInt(document.getElementById('timeout').value, 10);
            const temperature = parseFloat(document.getElementById('temperatureInput').value);
            const top_p = parseFloat(document.getElementById('topPInput').value);
            const presence_penalty = parseFloat(document.getElementById('presencePenaltyInput').value);
            const frequency_penalty = parseFloat(document.getElementById('frequencyPenaltyInput').value);

            //  ä¿å­˜å½“å‰é…ç½®åˆ° localStorageï¼ˆæ‰©å±•ä¿å­˜æ‰€æœ‰å‚æ•°ï¼‰
            try {
                localStorage.setItem('llmPerfTestApiUrl', apiUrl);
                localStorage.setItem('llmPerfTestModelName', currentModelName);
                localStorage.setItem('llmPerfTestApiType', currentApiType);
                localStorage.setItem('llmPerfTestApiKey', api_key);
                localStorage.setItem('llmPerfTestNotes', notes);
                localStorage.setItem('llmPerfTestMinLength', minLength);
                localStorage.setItem('llmPerfTestMaxLength', maxLength);
                localStorage.setItem('llmPerfTestStep', step);
                localStorage.setItem('llmPerfTestOutputLength', outputLength);
                localStorage.setItem('llmPerfTestConcurrency', concurrency);
                localStorage.setItem('llmPerfTestTimeout', timeout);
                localStorage.setItem('llmPerfTestTemperature', temperature);
                localStorage.setItem('llmPerfTestTopP', top_p);
                localStorage.setItem('llmPerfTestPresencePenalty', presence_penalty);
                localStorage.setItem('llmPerfTestFrequencyPenalty', frequency_penalty);
                console.log('[é…ç½®ä¿å­˜] å·²ä¿å­˜å½“å‰é…ç½®åˆ°localStorage');
            } catch (e) {
                console.warn("æ— æ³•ä¿å­˜é…ç½®åˆ° localStorage:", e);
            }

            // éªŒè¯è¾“å…¥
            if (!apiUrl || !currentModelName || !minLength || !maxLength || !step || !outputLength || !timeout) {
                alert("è¯·å¡«å†™æ‰€æœ‰å¿…å¡«çš„é…ç½®å‚æ•°ï¼");
                return;
            }

            totalTests = Math.floor((maxLength - minLength) / step) + 1;
            if (totalTests <= 0) {
                alert("æœ€å¤§é•¿åº¦å¿…é¡»å¤§äºæœ€å°é•¿åº¦ï¼Œæ­¥é•¿å¿…é¡»ä¸ºæ­£æ•°ã€‚");
                return;
            }
            completedTests = 0;

            concurrencyStats = {
                minPrefillSpeed: Infinity,
                maxPrefillSpeed: 0,
                minOutputSpeed: Infinity,
                maxOutputSpeed: 0,
                avgPrefillSpeed: 0,
                avgOutputSpeed: 0
            };

            startTestBtn.disabled = true;
            startTestBtn.textContent = translations[currentLang].msgTesting;
            copyMarkdownBtn.style.display = 'none';
            exportCSVBtn.style.display = 'none';
            exportCombinedChartBtn.style.display = 'none'; // v1.8
            // chartContainer.style.display = 'none';
            progressBar.style.width = '0%';
            resultsDiv.innerHTML = "";
            testResultsData = [];

            // é”€æ¯æ—§å›¾è¡¨
            if (prefillChartInstance) prefillChartInstance.destroy();
            if (outputChartInstance) outputChartInstance.destroy();
            prefillChartInstance = null;
            outputChartInstance = null;

            const t = translations[currentLang];

            const notesMessage = document.createElement('p');
            notesMessage.className = 'notes';
            notesMessage.textContent = `${t.labelNotesPrefix}${notes} | ${t.labelConcurrencyPrefix} ${concurrency} | ${t.labelTimeoutPrefix} ${timeout/1000}s`;
            resultsDiv.appendChild(notesMessage);

            const table = document.createElement('table');
            const thead = document.createElement('thead');
            const tbody = document.createElement('tbody');
            table.appendChild(thead);
            table.appendChild(tbody);
            resultsDiv.appendChild(table);

            const headerRow = document.createElement('tr');
            [
                t.tableHeaderPromptLen,
                t.tableHeaderPrefillTime,
                t.tableHeaderPrefillSpeed,
                t.tableHeaderOutputLen,
                t.tableHeaderOutputTime,
                t.tableHeaderOutputSpeed,
                t.tableHeaderStatus,
                t.tableHeaderDetail
            ].forEach(text => {
                const th = document.createElement('th');
                th.innerHTML = text;
                headerRow.appendChild(th);
            });
            thead.appendChild(headerRow);
            chartContainer.style.display = 'block';

            stopTestBtn.disabled = false;
            stopTestBtn.textContent = translations[currentLang].btnTextStop;
            stopTestBtn.style.display = 'block';
            isTestingRunning = true;

            stopTestBtn.onclick = () => {
                isTestingRunning = false;
                stopTestBtn.disabled = true;
                stopTestBtn.textContent = translations[currentLang].statusStopping;
            };

            try {
                if (currentApiType === 'openai') {
                    await testOpenAI(apiUrl, currentModelName, minLength, maxLength, step, outputLength, temperature, top_p, presence_penalty, frequency_penalty, concurrency, timeout);
                } else {
                    await testOllama(apiUrl, currentModelName, minLength, maxLength, step, outputLength, temperature, top_p, presence_penalty, frequency_penalty, concurrency, timeout);
                }
            } catch (e) {
                console.error('æµ‹è¯•è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯:', e);
                const errorRow = document.createElement('tr');
                errorRow.innerHTML = `<td colspan="8" class="error">${t.msgTestUnexpectedTermination} ${e.message}</td>`;
                resultsDiv.querySelector('tbody').appendChild(errorRow);
            }

            //
            const wasManuallyStopped = !isTestingRunning;

            // æ— è®ºæµ‹è¯•æ˜¯å®Œæˆè¿˜æ˜¯è¢«æ‰‹åŠ¨åœæ­¢ï¼Œåªè¦æœ‰æ•°æ®å°±æ˜¾ç¤ºç»Ÿè®¡
            let statsData = null;
            if (testResultsData.some(r => r.status === translations.zh.statusSuccess || r.status === translations.en.statusSuccess)) {
                statsData = showConcurrencyStats();
                // generateCharts(); //

                // v1.9: ä¿å­˜å†å²è®°å½•
                if (statsData && !wasManuallyStopped) {
                    const currentConfig = {
                        apiUrl: apiUrl,
                        modelName: currentModelName,
                        apiType: currentApiType,
                        minLength: minLength,
                        maxLength: maxLength,
                        step: step,
                        outputLength: outputLength,
                        concurrency: concurrency,
                        temperature: temperature,
                        topP: top_p,
                        presencePenalty: presence_penalty,
                        frequencyPenalty: frequency_penalty,
                        timeout: timeout,
                        notes: notes
                    };
                    const saved = saveTestToHistory(currentConfig, testResultsData, statsData);
                    if (saved) {
                        console.log('[å†å²è®°å½•] æµ‹è¯•ç»“æœå·²è‡ªåŠ¨ä¿å­˜');
                    }
                }
            }

            // æ ¹æ®æµ‹è¯•æ˜¯å¦è¢«æ‰‹åŠ¨åœæ­¢æ¥æ˜¾ç¤ºä¸åŒçš„æœ€ç»ˆæ¶ˆæ¯
            if (wasManuallyStopped) {
                 const stopRow = document.createElement('tr');
                stopRow.innerHTML = `<td colspan="8" class="info">${t.msgTestStopped}</td>`;
                resultsDiv.querySelector('tbody').appendChild(stopRow);
            } else if (!testResultsData.some(r => r.status === t.statusSuccess)) {
                 const noDataRow = document.createElement('tr');
                noDataRow.innerHTML = `<td colspan="8" class="info">${t.msgTestCompleteNoData}</td>`;
                resultsDiv.querySelector('tbody').appendChild(noDataRow);
            }

            isTestingRunning = false; //

            // ç”ŸæˆMarkdownè¡¨æ ¼
            const apiTypeText = currentApiType === 'openai' ? t.apiOpenAI : t.apiOllama;
            let markdownTable = `## ${t.mdTestResults} (${apiTypeText} - ${currentModelName})\n\n`;
            markdownTable += `${t.mdNotes}${notes} | ${t.mdConcurrency} ${concurrency}\n\n`;
            markdownTable += `| ${t.tableHeaderPromptLen.replace('<br>', ' ')} | ${t.tableHeaderPrefillTime.replace('<br>', ' ')} | ${t.tableHeaderPrefillSpeed.replace('<br>', ' ')} | ${t.tableHeaderOutputLen.replace('<br>', ' ')} | ${t.tableHeaderOutputTime.replace('<br>', ' ')} | ${t.tableHeaderOutputSpeed.replace('<br>', ' ')} |\n`;
            markdownTable += `|---------------------|-------------------|-------------------------|-------------------|---------------|---------------------|\n`;

            testResultsData.forEach(res => {
                // Markdown ä¸­ä¹Ÿæ˜¾ç¤º N/A
                markdownTable += `| ${res.promptLength} | ${res.prefillTimeMs} | ${res.prefillSpeed} | ${res.outputTokens} | ${res.outputTimeMs} | ${res.outputSpeed} |\n`;
            });
            markdownOutputHidden.value = markdownTable;

            startTestBtn.disabled = false;
            startTestBtn.textContent = translations[currentLang].btnTextStart;
            copyMarkdownBtn.style.display = 'block';
            exportCSVBtn.style.display = 'block';
            exportCombinedChartBtn.style.display = 'block'; // v1.8
            stopTestBtn.style.display = 'none';
        });

        copyMarkdownBtn.addEventListener('click', () => {

            markdownOutputHidden.select();
            document.execCommand('copy');
            alert(translations[currentLang].alertMarkdownCopied);
        });

        exportCSVBtn.addEventListener('click', () => {
            const t = translations[currentLang];
            const apiTypeText = currentApiType === 'openai' ? t.apiOpenAI : t.apiOllama;
            let csvContent = "data:text/csv;charset=utf-8,";
            csvContent += `${apiTypeText}, ${currentModelName}\n`;
            csvContent += `${t.mdNotes}, "${notes.replace(/"/g, '""')}"\n`; // å¤„ç†å¤‡æ³¨ä¸­çš„å¼•å·
            const concurrencyValue = document.getElementById('concurrency').value; // è·å–å¹¶å‘æ•°
            csvContent += `${t.csvConcurrency}, ${concurrencyValue}\n`;
            csvContent += t.csvHeaders + "\n";
            testResultsData.forEach(res => {
                csvContent += `${res.promptLength},${res.prefillTimeMs},${res.prefillSpeed},${res.outputTokens},${res.outputTimeMs},${res.outputSpeed},"${res.status.replace(/"/g, '""')}"\n`;
            });
            const encodedUri = encodeURI(csvContent);
            const link = document.createElement("a");
            link.setAttribute("href", encodedUri);

            // è·å–å¤‡æ³¨ï¼ˆå¯èƒ½éœ€è¦å¯¹ç‰¹æ®Šå­—ç¬¦è¿›è¡Œå¤„ç†ï¼Œç¡®ä¿æ–‡ä»¶åå…¼å®¹æ€§ï¼‰
            const cleanNotes = notes // å‡è®¾notesæ˜¯åŒ…å«å¤‡æ³¨çš„å˜é‡
                .replace(/[\s\t\n\r]+/g, '_') // å°†ç©ºæ ¼å’Œæ¢è¡Œç¬¦æ›¿æ¢ä¸ºä¸‹åˆ’çº¿
                .replace(/[^a-zA-Z0-9_\-\.]/g, '') // ç§»é™¤å…¶ä»–éå­—æ¯æ•°å­—ä¸‹åˆ’çº¿è¿æ¥ç¬¦ç‚¹å·çš„å­—ç¬¦
                .substring(0, 30); // é™åˆ¶æ–‡ä»¶åä¸­çš„å¤‡æ³¨é•¿åº¦ï¼Œé˜²æ­¢è¿‡é•¿

            // æ„å»ºæ–°çš„æ–‡ä»¶å
            const filename = `${currentModelName}_${cleanNotes}_concurrency_${concurrencyValue}.csv`;
            // --- é‡ç‚¹ä¿®æ”¹éƒ¨åˆ†ç»“æŸ ---

            link.setAttribute("download", filename);
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        });


        // ===============================================================================
        // v1.8: æ–°å¢åŠŸèƒ½ï¼šå›¾è¡¨å¯¼å‡ºå’Œç»“æœå¯¹æ¯” (é‡æ„)
        // ===============================================================================

        /**
         * v1.8: å°†ä¸¤ä¸ª canvas åˆå¹¶å¹¶ä¸‹è½½ä¸ºä¸€å¼ å›¾ç‰‡
         * @param {HTMLCanvasElement} canvas1 - é¡¶éƒ¨å›¾è¡¨
         * @param {HTMLCanvasElement} canvas2 - åº•éƒ¨å›¾è¡¨
         * @param {string} filename - ä¸‹è½½çš„æ–‡ä»¶å
         * @param {string} title - (å¯é€‰) åœ¨å›¾è¡¨é¡¶éƒ¨æ·»åŠ çš„
         */
        function downloadCombinedChart(canvas1, canvas2, filename, title = null) {
            if (!canvas1 || !canvas2) {
                alert("å›¾è¡¨å°šæœªç”Ÿæˆï¼");
                return;
            }

            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');

            const padding = 20; // å›¾è¡¨é—´çš„é—´è·
            const titleHeight = title ? 60 : 0; // ä¸ºé¡¶éƒ¨å¤§æ ‡é¢˜ç•™å‡ºç©ºé—´

            // è®¾ç½®ç”»å¸ƒå°ºå¯¸
            tempCanvas.width = Math.max(canvas1.width, canvas2.width);
            tempCanvas.height = canvas1.height + canvas2.height + padding + titleHeight;

            // 1. å¡«å……ç™½è‰²èƒŒæ™¯
            tempCtx.fillStyle = '#FFFFFF';
            tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);

            // 2. (å¯é€‰) ç»˜åˆ¶å¤§æ ‡é¢˜
            if (title) {
                tempCtx.fillStyle = '#333333';
                tempCtx.font = 'bold 24px sans-serif';
                tempCtx.textAlign = 'center';
                tempCtx.fillText(title, tempCanvas.width / 2, 40);
            }

            // 3. ç»˜åˆ¶ç¬¬ä¸€ä¸ªå›¾è¡¨ (Chart.jsçš„å›¾è¡¨æ ‡é¢˜æ˜¯canvasçš„ä¸€éƒ¨åˆ†,æ‰€ä»¥ä¼šä¸€èµ·ç»˜åˆ¶)
            tempCtx.drawImage(canvas1, 0, titleHeight);

            // 4. ç»˜åˆ¶ç¬¬äºŒä¸ªå›¾è¡¨
            tempCtx.drawImage(canvas2, 0, titleHeight + canvas1.height + padding);

            // 5. è§¦å‘ä¸‹è½½
            const link = document.createElement('a');
            link.href = tempCanvas.toDataURL('image/png');
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        // v1.8: ç›‘å¬åˆå¹¶å¯¼å‡ºæŒ‰é’®
        exportCombinedChartBtn.addEventListener('click', () => {
            const modelName = currentModelName.replace(/[\/\\]/g, '_'); // æ¸…ç†æ–‡ä»¶å
            downloadCombinedChart(
                prefillChartCanvas,
                outputChartCanvas,
                `Perf_Chart_${modelName}.png`,
                `æ€§èƒ½æµ‹è¯•å›¾è¡¨ - ${currentModelName} - ${notes}` // å¤§æ ‡é¢˜
            );
        });

        // v1.8: ç›‘å¬å¯¹æ¯”å›¾è¡¨å¯¼å‡ºæŒ‰é’®
        exportComparisonChartBtn.addEventListener('click', () => {
            if (comparisonData.length === 0) {
                alert("æ²¡æœ‰å¯¹æ¯”æ•°æ®å¯å¯¼å‡ºã€‚");
                return;
            }
            // v1.8: ä» comparisonData åŠ¨æ€ç”Ÿæˆæ–‡ä»¶å
            const labels = comparisonData.map(d =>
                d.label.replace(/ã€.*?ã€‘/g, '') // ç§»é™¤ã€å¯¼å…¥ã€‘
                       .replace(/[\s\(\),]/g, '_') // æ›¿æ¢éæ³•å­—ç¬¦
                       .replace(/_+/g, '_') // ç§»é™¤è¿ç»­çš„ä¸‹åˆ’çº¿
            );
            // é™åˆ¶æ–‡ä»¶åé•¿åº¦ï¼Œé˜²æ­¢è¿‡é•¿
            const filename = `Comparison_${labels.join('_vs_').slice(0, 100)}.png`;

            downloadCombinedChart(
                document.getElementById('comparisonPrefillChart'),
                document.getElementById('comparisonOutputChart'),
                filename,
                "æ€§èƒ½å¯¹æ¯”å›¾è¡¨" // å¤§æ ‡é¢˜
            );
        });


        // 2. ç»“æœå¯¹æ¯”åŠŸèƒ½
        startComparisonBtn.addEventListener('click', async () => {
            const files = importFilesInput.files;
            comparisonData = []; // é‡ç½®å¯¹æ¯”æ•°æ®

            // 1. æ·»åŠ å½“å‰æµ‹è¯•æ•°æ® (å¦‚æœå­˜åœ¨)
            if (testResultsData.length > 0) {
                const currentConcurrency = document.getElementById('concurrency').value;
                // v1.8: ä¿®æ”¹å½“å‰æµ‹è¯•çš„æ ‡ç­¾
                const label = `ã€å½“å‰æµ‹è¯•ã€‘${currentModelName} (å¹¶å‘ ${currentConcurrency})`;
                comparisonData.push(formatDataForComparison(testResultsData, label));
            } else {
                alert(translations[currentLang].alertNoTestResults);
                // å³ä½¿æ²¡æœ‰å½“å‰æ•°æ®ï¼Œä¹Ÿç»§ç»­å¤„ç†å¯¼å…¥çš„æ•°æ®
            }

            // 2. æ·»åŠ å¯¼å…¥çš„CSVæ–‡ä»¶æ•°æ®
            for (const file of files) {
                try {
                    const fileContent = await file.text();
                    const parsedData = parseImportedCSV(fileContent);

                    // v1.8: ä½¿ç”¨æ–‡ä»¶åä½œä¸ºæ ‡ç­¾
                    const fileName = file.name.replace(/.csv$/i, ''); // ç§»é™¤.csv
                    const label = `ã€å¯¼å…¥ã€‘${fileName}`;

                    comparisonData.push(formatDataForComparison(parsedData.results, label));
                } catch (error) {
                    console.error(`${translations[currentLang].msgParseFileFailed} ${file.name} ${translations[currentLang].msgFailed2}`, error);
                    alert(`${translations[currentLang].msgParseFileFailed} ${file.name} ${translations[currentLang].msgFailed2} ${error.message}`);
                }
            }

            // 3. ç”Ÿæˆå¯¹æ¯”å›¾è¡¨
            if (comparisonData.length > 0) {
                generateComparisonCharts();
            } else if (testResultsData.length === 0) {
                // ä»…åœ¨æ—¢æ²¡æœ‰å½“å‰æ•°æ® *ä¹Ÿ* æ²¡æœ‰å¯¼å…¥æ•°æ®æ—¶æ‰æ˜¾ç¤ºæ­¤æ¶ˆæ¯
                alert("æ²¡æœ‰å¯ç”¨äºå¯¹æ¯”çš„æ•°æ®ã€‚");
            }
        });

        /**
         * å°† testResultsData æ ¼å¼çš„æ•°æ®è½¬æ¢ä¸ºå¯¹æ¯”å›¾è¡¨æ‰€éœ€çš„å¯¹è±¡æ•°ç»„æ ¼å¼
         * @param {Array} resultsArray - æ¥æºæ•°æ® (e.g., testResultsData)
         * @param {string} label - è¿™ä¸ªæ•°æ®é›†çš„å›¾ä¾‹æ ‡ç­¾
         * @returns {object} - { label, prefillData: [{x, y}], outputData: [{x, y}] }
         */
        function formatDataForComparison(resultsArray, label) {
            const data = {
                label: label,
                prefillData: [], // {x: promptLength, y: speed}
                outputData: []   // {x: promptLength, y: speed}
            };

            for (const res of resultsArray) {
                const promptLength = parseFloat(res.promptLength);
                const prefillSpeed = res.prefillSpeed === 'N/A' ? null : parseFloat(res.prefillSpeed);
                const outputSpeed = res.outputSpeed === 'N/A' ? null : parseFloat(res.outputSpeed);

                if (!isNaN(promptLength)) {
                    if (prefillSpeed !== null) {
                        data.prefillData.push({ x: promptLength, y: prefillSpeed });
                    }
                    if (outputSpeed !== null) {
                        data.outputData.push({ x: promptLength, y: outputSpeed });
                    }
                }
            }
            // æŒ‰ x (promptLength) æ’åºä»¥ç¡®ä¿çº¿æ¡æ­£ç¡®ç»˜åˆ¶
            data.prefillData.sort((a, b) => a.x - b.x);
            data.outputData.sort((a, b) => a.x - b.x);

            return data;
        }

        /**
         * è§£æå¯¼å…¥çš„CSVæ–‡ä»¶å†…å®¹
         * @param {string} csvContent - CSVæ–‡ä»¶æ–‡æœ¬å†…å®¹
         * @returns {object} - { modelName, notes, concurrency, results }
         */
        function parseImportedCSV(csvContent) {
            // v1.8 bug fix: åŒæ—¶å¤„ç† \n å’Œ \r\n æ¢è¡Œ
            const lines = csvContent.trim().split(/\r?\n/);
            if (lines.length < 5) throw new Error("CSVæ–‡ä»¶æ ¼å¼ä¸æ­£ç¡®ï¼Œè¡Œæ•°ä¸è¶³ã€‚");

            // ç§»é™¤\r (å†æ¬¡ç¡®ä¿)
            const cleanLines = lines.map(line => line.replace(/\r$/, ''));

            const modelName = cleanLines[0].split(',')[1]?.trim() || 'æœªçŸ¥æ¨¡å‹';
            const notes = (cleanLines[1].split(',"')[1] || '').replace(/"$/, '') || 'æ— å¤‡æ³¨';
            const concurrency = cleanLines[2].split(',')[1]?.trim() || '1';

            const headerLine = cleanLines[3];
            const headers = headerLine.split(',').map(h => h.trim());

            // æŸ¥æ‰¾åˆ—ç´¢å¼•ï¼ˆæ”¯æŒä¸­è‹±æ–‡åˆ—åï¼‰
            let lenIdx = headers.indexOf("æç¤ºè¯é•¿åº¦(tokens)");
            if (lenIdx === -1) lenIdx = headers.indexOf("Prompt Length(tokens)");

            let prefillSpdIdx = headers.indexOf("é¢„å¡«å……é€Ÿåº¦(tokens/s)");
            if (prefillSpdIdx === -1) prefillSpdIdx = headers.indexOf("Prefill Speed(tokens/s)");

            let outputSpdIdx = headers.indexOf("è¾“å‡ºé€Ÿåº¦(tokens/s)");
            if (outputSpdIdx === -1) outputSpdIdx = headers.indexOf("Output Speed(tokens/s)");

            if (lenIdx === -1 || prefillSpdIdx === -1 || outputSpdIdx === -1) {
                throw new Error(translations[currentLang].errMissingColumns);
            }

            const results = [];
            for (let i = 4; i < cleanLines.length; i++) {
                if (cleanLines[i].trim() === "") continue;
                const values = cleanLines[i].split(',');

                if (values.length > Math.max(lenIdx, prefillSpdIdx, outputSpdIdx)) {
                    results.push({
                        promptLength: values[lenIdx],
                        prefillSpeed: values[prefillSpdIdx],
                        outputSpeed: values[outputSpdIdx],
                        prefillTimeMs: 'N/A',
                        outputTokens: 'N/A',
                        outputTimeMs: 'N/A',
                        status: 'N/A'
                    });
                }
            }

            return { modelName, notes, concurrency, results };
        }

        /**
         * ç”Ÿæˆå¯¹æ¯”å›¾è¡¨
         */
        function generateComparisonCharts() {
            const comparisonChartContainer = document.getElementById('comparisonChartContainer');
            const compPrefillCanvas = document.getElementById('comparisonPrefillChart').getContext('2d');
            const compOutputCanvas = document.getElementById('comparisonOutputChart').getContext('2d');

            if (comparisonData.length === 0) {
                comparisonChartContainer.style.display = 'none';
                return;
            }

            comparisonChartContainer.style.display = 'block';

            // å®šä¹‰ä¸€ç»„é¢œè‰²
            const colors = [
                '#E41A1C', '#377EB8', '#4DAF4A', '#984EA3', '#FF7F00', '#FFFF33',
                '#A65628', '#F781BF', '#999999', '#1B9E77', '#D95F02', '#7570B3'
            ];

            // 1. åˆ›å»º Prefill å¯¹æ¯”å›¾è¡¨
            const prefillDatasets = comparisonData.map((dataset, index) => {
                return {
                    label: dataset.label, // v1.8: æ ‡ç­¾å·²åœ¨è°ƒç”¨æ—¶æ ¼å¼åŒ–
                    data: dataset.prefillData,
                    borderColor: colors[index % colors.length],
                    backgroundColor: colors[index % colors.length] + '33', // 20% é€æ˜åº¦
                    tension: 0.1,
                    spanGaps: false, // åœ¨ null æ•°æ®ç‚¹å¤„æ–­å¼€
                    fill: false // çº¿æ¡ä¸å¡«å……
                };
            });

            const t = translations[currentLang];
            if (comparisonPrefillChartInstance) comparisonPrefillChartInstance.destroy();
            comparisonPrefillChartInstance = new Chart(compPrefillCanvas, {
                type: 'line',
                data: { datasets: prefillDatasets },
                options: {
                    responsive: true,
                    plugins: {
                        legend: { position: 'top' },
                        title: { display: true, text: t.chartComparisonPrefillThroughput }
                    },
                    scales: {
                        x: {
                            type: 'linear', // Xè½´ä½¿ç”¨çº¿æ€§åˆ»åº¦
                            position: 'bottom',
                            title: { display: true, text: t.chartAxisPromptLen }
                        },
                        y: {
                            title: { display: true, text: t.chartAxisThroughput },
                            beginAtZero: true
                        }
                    }
                }
            });

            // 2. åˆ›å»º Output å¯¹æ¯”å›¾è¡¨
            const outputDatasets = comparisonData.map((dataset, index) => {
                return {
                    label: dataset.label,
                    data: dataset.outputData,
                    borderColor: colors[index % colors.length],
                    backgroundColor: colors[index % colors.length] + '33',
                    tension: 0.1,
                    spanGaps: false,
                    fill: false
                };
            });

            if (comparisonOutputChartInstance) comparisonOutputChartInstance.destroy();
            comparisonOutputChartInstance = new Chart(compOutputCanvas, {
                type: 'line',
                data: { datasets: outputDatasets },
                options: {
                    responsive: true,
                    plugins: {
                        legend: { position: 'top' },
                        title: { display: true, text: t.chartComparisonDecodeThroughput }
                    },
                    scales: {
                        x: {
                            type: 'linear',
                            position: 'bottom',
                            title: { display: true, text: t.chartAxisPromptLen }
                        },
                        y: {
                            title: { display: true, text: t.chartAxisThroughput },
                            beginAtZero: true
                        }
                    }
                }
            });

            // v1.8: æ˜¾ç¤ºå¯¹æ¯”å›¾è¡¨å¯¼å‡ºæŒ‰é’®
            exportComparisonChartBtn.style.display = 'block';
        }


        // ===============================================================================
        // åŸæœ‰å›¾è¡¨ç”Ÿæˆ
        // ===============================================================================

        // ç”Ÿæˆå›¾è¡¨ (ç°åœ¨æ˜¯ä¸¤å¼ å›¾)
        function generateCharts() {
            if (testResultsData.length === 0) {
                //
                if (prefillChartInstance) prefillChartInstance.clear();
                if (outputChartInstance) outputChartInstance.clear();
                return;
            }

            const t = translations[currentLang];
            // ä»æ•°æ®ä¸­æå–æ ‡ç­¾å’Œæ•°æ®é›†
            const labels = testResultsData.map(d => d.promptLength);
            // å°† 'N/A' è½¬æ¢ä¸º nullï¼Œä»¥ä¾¿ Chart.js çŸ¥é“åœ¨ä½•å¤„æ–­å¼€çº¿æ¡
            const prefillDataTotal = testResultsData.map(d => d.prefillSpeed === 'N/A' ? null : parseFloat(d.prefillSpeed));
            const outputDataTotal = testResultsData.map(d => d.outputSpeed === 'N/A' ? null : parseFloat(d.outputSpeed));

            chartContainer.style.display = 'block';

            // é”€æ¯æ—§å›¾è¡¨
            if (prefillChartInstance) {
                prefillChartInstance.data.labels = labels;
                prefillChartInstance.data.datasets[0].data = prefillDataTotal;
                prefillChartInstance.update('none');
            } else {
                // å›¾è¡¨1: é¢„å¡«å……é€Ÿåº¦
                const prefillCtx = prefillChartCanvas.getContext('2d');
                prefillChartInstance = new Chart(prefillCtx, {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: [
                            {
                                label: t.chartLabelPrefillThroughput,
                                data: prefillDataTotal,
                                borderColor: 'rgb(75, 192, 192)',
                                backgroundColor: 'rgba(75, 192, 192, 0.2)',
                                tension: 0.1,
                                fill: true,
                                spanGaps: false // åœ¨ null æ•°æ®ç‚¹å¤„æ–­å¼€
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        plugins: {
                            legend: {
                                position: 'top',
                            },
                            title: {
                                display: true,
                                text: `${t.chartTitlePrefillThroughput} - ${currentModelName} - ${notes}`
                            }
                        },
                        scales: {
                            x: {
                                title: {
                                    display: true,
                                    text: t.chartAxisPromptLen
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: t.chartAxisThroughput
                                },
                                beginAtZero: true
                            }
                        }
                    }
                });
            }

            // å›¾è¡¨2: è¾“å‡ºé€Ÿåº¦
            if (outputChartInstance) {
                outputChartInstance.data.labels = labels;
                outputChartInstance.data.datasets[0].data = outputDataTotal;
                outputChartInstance.update('none');
            } else {
                const outputCtx = outputChartCanvas.getContext('2d');
                outputChartInstance = new Chart(outputCtx, {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: [
                            {
                                label: t.chartLabelDecodeThroughput,
                                data: outputDataTotal,
                                borderColor: 'rgb(255, 99, 132)',
                                backgroundColor: 'rgba(255, 99, 132, 0.2)',
                                tension: 0.1,
                                fill: true,
                                spanGaps: false // åœ¨ null æ•°æ®ç‚¹å¤„æ–­å¼€
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        plugins: {
                            legend: {
                                position: 'top',
                            },
                            title: {
                                display: true,
                                text: `${t.chartTitleDecodeThroughput} - ${currentModelName} - ${notes}`
                            }
                        },
                        scales: {
                            x: {
                                title: {
                                    display: true,
                                    text: t.chartAxisPromptLen
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: t.chartAxisThroughput
                                },
                                beginAtZero: true
                            }
                        }
                    }
                });
            }
        }

        //  ä»localStorageåŠ è½½ä¸Šæ¬¡ä¿å­˜çš„é…ç½®
        function setDefaultValues() {
            // ä» localStorage åŠ è½½ä¿å­˜çš„ API ç±»å‹ã€åœ°å€å’Œæ¨¡å‹åç§°
            const savedApiType = localStorage.getItem('llmPerfTestApiType') || 'openai';
            const savedApiUrl = localStorage.getItem('llmPerfTestApiUrl');
            const savedModelName = localStorage.getItem('llmPerfTestModelName');
            const savedApiKey = localStorage.getItem('llmPerfTestApiKey');
            const savedNotes = localStorage.getItem('llmPerfTestNotes');
            const savedMinLength = localStorage.getItem('llmPerfTestMinLength');
            const savedMaxLength = localStorage.getItem('llmPerfTestMaxLength');
            const savedStep = localStorage.getItem('llmPerfTestStep');
            const savedOutputLength = localStorage.getItem('llmPerfTestOutputLength');
            const savedConcurrency = localStorage.getItem('llmPerfTestConcurrency');
            const savedTimeout = localStorage.getItem('llmPerfTestTimeout');
            const savedTemperature = localStorage.getItem('llmPerfTestTemperature');
            const savedTopP = localStorage.getItem('llmPerfTestTopP');
            const savedPresencePenalty = localStorage.getItem('llmPerfTestPresencePenalty');
            const savedFrequencyPenalty = localStorage.getItem('llmPerfTestFrequencyPenalty');

            // è®¾ç½® API ç±»å‹çš„ active çŠ¶æ€
            apiOptions.forEach(o => o.classList.remove('active'));
            const activeOption = document.querySelector(`.api-option[data-type="${savedApiType}"]`);
            if (activeOption) {
                activeOption.classList.add('active');
            }
            updateApiDescription(savedApiType);

            // å¦‚æœ localStorage æœ‰æ•°æ®åˆ™ä½¿ç”¨ï¼Œå¦åˆ™ä½¿ç”¨é»˜è®¤æ•°æ®
            document.getElementById('apiUrl').value = savedApiUrl || ((savedApiType === 'openai') ? d_openai_apiUrl : d_ollama_apiUrl);
            document.getElementById('modelName').value = savedModelName || ((savedApiType === 'openai') ? d_openai_modelName : d_ollama_modelName);
            document.getElementById('apiKey').value = savedApiKey || d_api_key;
            document.getElementById('notes').value = savedNotes || '';
            document.getElementById('minLength').value = savedMinLength || d_minLength;
            document.getElementById('maxLength').value = savedMaxLength || d_maxLength;
            document.getElementById('step').value = savedStep || d_step;
            document.getElementById('outputLength').value = savedOutputLength || d_outputLength;
            document.getElementById('concurrency').value = savedConcurrency || 1;
            document.getElementById('timeout').value = savedTimeout || d_timeout;
            document.getElementById('temperatureInput').value = savedTemperature || d_temperature;
            document.getElementById('topPInput').value = savedTopP || d_top_p;
            document.getElementById('presencePenaltyInput').value = savedPresencePenalty || d_presence_penalty;
            document.getElementById('frequencyPenaltyInput').value = savedFrequencyPenalty || d_frequency_penalty;

            // æç¤ºç”¨æˆ·å·²åŠ è½½é…ç½®
            if (savedApiUrl) {
                console.log('[é…ç½®åŠ è½½] å·²ä»localStorageæ¢å¤ä¸Šæ¬¡çš„é…ç½®');
            }
        }

        // ===============================================================================
        // v1.9: å†å²è®°å½•UIåŠŸèƒ½ (History UI Functions)
        // ===============================================================================

        const historyModal = document.getElementById('historyModal');
        const historyModalClose = document.querySelector('.history-modal-close');
        const viewHistoryBtn = document.getElementById('viewHistory');
        const historyListView = document.getElementById('historyListView');
        const historyDetailView = document.getElementById('historyDetailView');
        const backToHistoryListBtn = document.getElementById('backToHistoryList');
        const clearAllHistoryBtn = document.getElementById('clearAllHistory');

        /**
         * æ‰“å¼€å†å²è®°å½•æ¨¡æ€æ¡†
         */
        function openHistoryModal() {
            historyModal.style.display = 'block';
            showHistoryList();
        }

        /**
         * å…³é—­å†å²è®°å½•æ¨¡æ€æ¡†
         */
        function closeHistoryModal() {
            historyModal.style.display = 'none';
            historyListView.style.display = 'block';
            historyDetailView.style.display = 'none';
        }

        /**
         * æ˜¾ç¤ºå†å²è®°å½•åˆ—è¡¨
         */
        function showHistoryList() {
            const t = translations[currentLang];
            const history = loadHistoryFromStorage();
            const historyList = document.getElementById('historyList');

            // æ›´æ–°æ¨¡æ€æ¡†æ ‡é¢˜å’ŒæŒ‰é’®æ–‡æœ¬
            document.getElementById('historyModalTitle').textContent = t.historyModalTitle;
            clearAllHistoryBtn.textContent = t.historyBtnClearAll;
            document.getElementById('generateHistoryComparison').textContent = t.historyBtnCompare;
            document.getElementById('selectAllHistory').textContent = t.historyBtnSelectAll;
            document.getElementById('deselectAllHistory').textContent = t.historyBtnDeselectAll;
            document.getElementById('deleteSelectedHistory').textContent = t.historyBtnDeleteSelected;
            updateSelectedCount(); // æ›´æ–°é€‰æ‹©è®¡æ•°

            historyListView.style.display = 'block';
            historyDetailView.style.display = 'none';

            if (history.length === 0) {
                historyList.innerHTML = `<div class="history-empty">${t.historyEmpty}</div>`;
                document.getElementById('generateHistoryComparison').disabled = true;
                return;
            }

            historyList.innerHTML = '';
            history.forEach(record => {
                const recordDiv = document.createElement('div');
                recordDiv.className = 'history-record';

                const apiTypeText = record.config.apiType === 'openai' ? t.apiOpenAI : t.apiOllama;

                recordDiv.innerHTML = `
                    <div class="history-record-checkbox">
                        <input type="checkbox" class="history-checkbox" data-id="${record.id}" />
                    </div>
                    <div class="history-record-content">
                        <div class="history-record-header">
                            <div class="history-record-time">${record.timestamp}</div>
                        </div>
                        <div class="history-record-info">
                            <div><strong>${t.historyRecordNotes}</strong> ${record.notes || 'N/A'}</div>
                            <div><strong>${t.historyRecordModel}</strong> ${record.config.modelName} (${apiTypeText})</div>
                            <div><strong>${t.historyRecordConcurrency}</strong> ${record.config.concurrency} | <strong>${t.historyRecordPromptRange}</strong> ${record.config.minLength}-${record.config.maxLength} (step ${record.config.step}) | <strong>${t.historyRecordOutputLen}</strong> ${record.config.outputLength}</div>
                            <div><strong>Stats:</strong> Prefill P50/P90/P95: ${record.stats.prefill.p50}/${record.stats.prefill.p90}/${record.stats.prefill.p95} | Decode P50/P90/P95: ${record.stats.decode.p50}/${record.stats.decode.p90}/${record.stats.decode.p95} tokens/s</div>
                        </div>
                        <div class="history-record-actions">
                            <button class="history-record-btn history-record-btn-view" data-id="${record.id}">${t.historyBtnView}</button>
                            <button class="history-record-btn history-record-btn-load" data-id="${record.id}">${t.historyBtnLoad}</button>
                            <button class="history-record-btn history-record-btn-export" data-id="${record.id}">${t.historyBtnExport}</button>
                            <button class="history-record-btn history-record-btn-delete" data-id="${record.id}">${t.historyBtnDelete}</button>
                        </div>
                    </div>
                `;

                historyList.appendChild(recordDiv);
            });

            // ç»‘å®šæŒ‰é’®äº‹ä»¶
            document.querySelectorAll('.history-record-btn-view').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const recordId = parseInt(e.target.dataset.id);
                    viewHistoryDetail(recordId);
                });
            });

            document.querySelectorAll('.history-record-btn-load').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const recordId = parseInt(e.target.dataset.id);
                    loadHistoryRecord(recordId);
                });
            });

            document.querySelectorAll('.history-record-btn-export').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const recordId = parseInt(e.target.dataset.id);
                    exportHistoryToCSV(recordId);
                });
            });

            document.querySelectorAll('.history-record-btn-delete').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const recordId = parseInt(e.target.dataset.id);
                    deleteHistoryWithConfirm(recordId);
                });
            });

            // ç»‘å®šå¤é€‰æ¡†äº‹ä»¶
            document.querySelectorAll('.history-checkbox').forEach(checkbox => {
                checkbox.addEventListener('change', updateSelectedCount);
            });
        }

        /**
         * æŸ¥çœ‹å†å²è®°å½•è¯¦æƒ…
         */
        function viewHistoryDetail(recordId) {
            const t = translations[currentLang];
            const history = loadHistoryFromStorage();
            const record = history.find(r => r.id === recordId);

            if (!record) {
                alert('å†å²è®°å½•æœªæ‰¾åˆ°');
                return;
            }

            historyListView.style.display = 'none';
            historyDetailView.style.display = 'block';

            // æ›´æ–°è¿”å›æŒ‰é’®æ–‡æœ¬
            backToHistoryListBtn.textContent = t.historyBtnBack;

            const detailContent = document.getElementById('historyDetailContent');
            const apiTypeText = record.config.apiType === 'openai' ? t.apiOpenAI : t.apiOllama;

            // åˆ›å»ºè¯¦æƒ…HTML
            let html = `
                <div style="background: #f8f9fa; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h3>${t.historyViewTitle}</h3>
                    <p><strong>${t.historyRecordTime}</strong> ${record.timestamp}</p>
                    <p><strong>${t.historyRecordNotes}</strong> ${record.notes || 'N/A'}</p>
                    <p><strong>${t.historyRecordModel}</strong> ${record.config.modelName} (${apiTypeText})</p>
                    <p><strong>${t.historyRecordConfig}</strong></p>
                    <ul>
                        <li>API URL: ${record.config.apiUrl}</li>
                        <li>${t.historyRecordConcurrency} ${record.config.concurrency}</li>
                        <li>${t.historyRecordPromptRange} ${record.config.minLength}-${record.config.maxLength} (step ${record.config.step})</li>
                        <li>${t.historyRecordOutputLen} ${record.config.outputLength}</li>
                        <li>Temperature: ${record.config.temperature}, Top P: ${record.config.topP}</li>
                        <li>Timeout: ${record.config.timeout}ms</li>
                    </ul>
                </div>

                <div style="background: #2c3e50; padding: 15px; border-radius: 5px; color: white; margin-bottom: 20px;">
                    <h4 style="color: #61afef; margin-bottom: 10px;">${t.concurrentStatsTitle}</h4>
                    <p><strong>${t.statTotalPrefillRange}</strong> ${record.stats.prefill.min} - ${record.stats.prefill.max} tokens/s</p>
                    <p><strong>${t.statTotalDecodeRange}</strong> ${record.stats.decode.min} - ${record.stats.decode.max} tokens/s</p>
                    <p><strong>${t.statAvgPrefill}</strong> ${record.stats.prefill.avg} tokens/s</p>
                    <p><strong>${t.statAvgDecode}</strong> ${record.stats.decode.avg} tokens/s</p>
                    <hr style="margin: 10px 0; border: none; border-top: 1px solid #555;">
                    <h4 style="color: #61afef; margin: 10px 0;">${t.statPercentileTitle}</h4>
                    <p><strong>${t.statPrefillPercentile}</strong> P50: ${record.stats.prefill.p50} | P90: ${record.stats.prefill.p90} | P95: ${record.stats.prefill.p95} tokens/s</p>
                    <p><strong>${t.statDecodePercentile}</strong> P50: ${record.stats.decode.p50} | P90: ${record.stats.decode.p90} | P95: ${record.stats.decode.p95} tokens/s</p>
                </div>

                <div style="background: white; padding: 15px; border-radius: 5px; border: 1px solid #ddd;">
                    <h4>${t.mdTestResults}</h4>
                    <div style="overflow-x: auto;">
                        <table style="width: 100%; border-collapse: collapse; margin-top: 10px;">
                            <thead style="background: #2c3e50; color: white;">
                                <tr>
                                    <th style="padding: 8px; border: 1px solid #ddd;">${t.tableHeaderPromptLen.replace('<br>', ' ')}</th>
                                    <th style="padding: 8px; border: 1px solid #ddd;">${t.tableHeaderPrefillTime.replace('<br>', ' ')}</th>
                                    <th style="padding: 8px; border: 1px solid #ddd;">${t.tableHeaderPrefillSpeed.replace('<br>', ' ')}</th>
                                    <th style="padding: 8px; border: 1px solid #ddd;">${t.tableHeaderOutputLen.replace('<br>', ' ')}</th>
                                    <th style="padding: 8px; border: 1px solid #ddd;">${t.tableHeaderOutputTime.replace('<br>', ' ')}</th>
                                    <th style="padding: 8px; border: 1px solid #ddd;">${t.tableHeaderOutputSpeed.replace('<br>', ' ')}</th>
                                    <th style="padding: 8px; border: 1px solid #ddd;">${t.tableHeaderStatus}</th>
                                </tr>
                            </thead>
                            <tbody>
            `;

            record.results.forEach(res => {
                html += `
                    <tr>
                        <td style="padding: 8px; border: 1px solid #ddd; text-align: center;">${res.promptLength}</td>
                        <td style="padding: 8px; border: 1px solid #ddd; text-align: center;">${res.prefillTimeMs}</td>
                        <td style="padding: 8px; border: 1px solid #ddd; text-align: center;">${res.prefillSpeed}</td>
                        <td style="padding: 8px; border: 1px solid #ddd; text-align: center;">${res.outputTokens}</td>
                        <td style="padding: 8px; border: 1px solid #ddd; text-align: center;">${res.outputTimeMs}</td>
                        <td style="padding: 8px; border: 1px solid #ddd; text-align: center;">${res.outputSpeed}</td>
                        <td style="padding: 8px; border: 1px solid #ddd; text-align: center;">${res.status}</td>
                    </tr>
                `;
            });

            html += `
                            </tbody>
                        </table>
                    </div>
                </div>
            `;

            detailContent.innerHTML = html;
        }

        /**
         * åŠ è½½å†å²è®°å½•åˆ°ä¸»ç•Œé¢
         */
        function loadHistoryRecord(recordId) {
            const t = translations[currentLang];
            const history = loadHistoryFromStorage();
            const record = history.find(r => r.id === recordId);

            if (!record) {
                alert(t.historyRecordNotFound || 'å†å²è®°å½•æœªæ‰¾åˆ°');
                return;
            }

            // æ¸…ç©ºå½“å‰æ•°æ®
            testResultsData = [];

            // å¡«å……è¡¨å•å‚æ•°
            if (record.config) {
                // è®¾ç½® API ç±»å‹ï¼ˆé€šè¿‡æŒ‰é’®é€‰æ‹©ï¼‰
                const apiType = record.config.apiType || 'openai';
                document.querySelectorAll('.api-option').forEach(o => o.classList.remove('active'));
                const activeOption = document.querySelector(`.api-option[data-type="${apiType}"]`);
                if (activeOption) {
                    activeOption.classList.add('active');
                }
                updateApiDescription(apiType);

                // å¡«å……å…¶ä»–å­—æ®µ
                document.getElementById('apiUrl').value = record.config.apiUrl || '';
                document.getElementById('modelName').value = record.config.modelName || '';
                document.getElementById('minLength').value = record.config.minLength || '';
                document.getElementById('maxLength').value = record.config.maxLength || '';
                document.getElementById('step').value = record.config.step || '';
                document.getElementById('outputLength').value = record.config.outputLength || '';
                document.getElementById('concurrency').value = record.config.concurrency || '';
                document.getElementById('temperatureInput').value = record.config.temperature !== undefined ? record.config.temperature : '';
                document.getElementById('topPInput').value = record.config.topP !== undefined ? record.config.topP : '';
                document.getElementById('presencePenaltyInput').value = record.config.presencePenalty !== undefined ? record.config.presencePenalty : '';
                document.getElementById('frequencyPenaltyInput').value = record.config.frequencyPenalty !== undefined ? record.config.frequencyPenalty : '';
                document.getElementById('timeout').value = record.config.timeout || '';
            }
            // å¡«å……å¤‡æ³¨å­—æ®µ
            document.getElementById('notes').value = record.notes || '';

            // åŠ è½½å†å²è®°å½•çš„ç»“æœæ•°æ®
            testResultsData = [...record.results];

            // æ¸…ç©ºå¹¶é‡æ–°åˆ›å»ºç»“æœè¡¨æ ¼
            const resultsDiv = document.getElementById('results');
            resultsDiv.innerHTML = '';

            // åˆ›å»ºå¤‡æ³¨ä¿¡æ¯
            const notesMessage = document.createElement('p');
            notesMessage.className = 'notes';
            notesMessage.textContent = `${t.labelNotesPrefix}${record.notes} | ${t.labelConcurrencyPrefix} ${record.config.concurrency} | ${t.labelTimeoutPrefix} ${record.config.timeout/1000}s`;
            resultsDiv.appendChild(notesMessage);

            // åˆ›å»ºè¡¨æ ¼
            const table = document.createElement('table');
            const thead = document.createElement('thead');
            const tbody = document.createElement('tbody');
            table.appendChild(thead);
            table.appendChild(tbody);
            resultsDiv.appendChild(table);

            // åˆ›å»ºè¡¨å¤´
            const headerRow = document.createElement('tr');
            [
                t.tableHeaderPromptLen,
                t.tableHeaderPrefillTime,
                t.tableHeaderPrefillSpeed,
                t.tableHeaderOutputLen,
                t.tableHeaderOutputTime,
                t.tableHeaderOutputSpeed,
                t.tableHeaderStatus,
                t.tableHeaderDetail
            ].forEach(text => {
                const th = document.createElement('th');
                th.innerHTML = text;
                headerRow.appendChild(th);
            });
            thead.appendChild(headerRow);

            // æ¸²æŸ“æ¯ä¸€è¡Œæ•°æ®
            testResultsData.forEach(resultEntry => {
                const row = document.createElement('tr');
                const cells = [];
                for (let i = 0; i < 8; i++) {
                    const cell = document.createElement('td');
                    cells.push(cell);
                    row.appendChild(cell);
                }

                cells[0].textContent = resultEntry.promptLength;
                cells[1].textContent = resultEntry.prefillTimeMs;
                cells[2].textContent = resultEntry.prefillSpeed;
                cells[3].textContent = resultEntry.outputTokens;
                cells[4].textContent = resultEntry.outputTimeMs;
                cells[5].textContent = resultEntry.outputSpeed;
                cells[6].textContent = resultEntry.status;

                // æ·»åŠ è¯¦æƒ…æŒ‰é’®ï¼ˆå¦‚æœæœ‰è¯¦æƒ…æ•°æ®ï¼‰
                if (resultEntry.promptText || resultEntry.outputText) {
                    const detailButton = document.createElement('button');
                    detailButton.className = 'detail-button';
                    detailButton.textContent = t.detailBtnView;
                    detailButton.onclick = () => showTestDetail(resultEntry);
                    cells[7].appendChild(detailButton);
                } else {
                    cells[7].textContent = '-';
                }

                // æ ¹æ®çŠ¶æ€è®¾ç½®è¡Œæ ·å¼
                if (resultEntry.status === t.statusSuccess || resultEntry.status.includes('æˆåŠŸ') || resultEntry.status.includes('Success')) {
                    row.classList.add('success');
                } else {
                    row.classList.add('error');
                }

                tbody.appendChild(row);
            });

            // æ›´æ–°å›¾è¡¨
            generateCharts();

            // å…³é—­å†å²è®°å½•é¢æ¿
            closeHistoryModal();

            // æ»šåŠ¨åˆ°ç»“æœåŒºåŸŸ
            resultsDiv.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }

        /**
         * å¯¼å‡ºå†å²è®°å½•ä¸ºCSV
         */
        function exportHistoryToCSV(recordId) {
            const t = translations[currentLang];
            const history = loadHistoryFromStorage();
            const record = history.find(r => r.id === recordId);

            if (!record) {
                alert('å†å²è®°å½•æœªæ‰¾åˆ°');
                return;
            }

            const apiTypeText = record.config.apiType === 'openai' ? t.apiOpenAI : t.apiOllama;
            let csvContent = "data:text/csv;charset=utf-8,";
            csvContent += `${apiTypeText}, ${record.config.modelName}\n`;
            csvContent += `${t.mdNotes}, "${record.notes.replace(/"/g, '""')}"\n`;
            csvContent += `${t.csvConcurrency}, ${record.config.concurrency}\n`;
            csvContent += t.csvHeaders + "\n";

            record.results.forEach(res => {
                csvContent += `${res.promptLength},${res.prefillTimeMs},${res.prefillSpeed},${res.outputTokens},${res.outputTimeMs},${res.outputSpeed},"${res.status.replace(/"/g, '""')}"\n`;
            });

            const encodedUri = encodeURI(csvContent);
            const link = document.createElement("a");
            link.setAttribute("href", encodedUri);

            const cleanNotes = record.notes
                .replace(/[\s\t\n\r]+/g, '_')
                .replace(/[^a-zA-Z0-9_\-\.]/g, '')
                .substring(0, 30);

            const filename = `history_${record.config.modelName}_${cleanNotes}_${record.id}.csv`;
            link.setAttribute("download", filename);
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        /**
         * åˆ é™¤å†å²è®°å½•ï¼ˆå¸¦ç¡®è®¤ï¼‰
         */
        function deleteHistoryWithConfirm(recordId) {
            const t = translations[currentLang];
            if (confirm(t.historyConfirmDelete)) {
                const success = deleteHistoryRecord(recordId);
                if (success) {
                    showHistoryList();
                }
            }
        }

        /**
         * æ¸…ç©ºæ‰€æœ‰å†å²è®°å½•ï¼ˆå¸¦ç¡®è®¤ï¼‰
         */
        function clearAllHistoryWithConfirm() {
            const t = translations[currentLang];
            if (confirm(t.historyConfirmClear)) {
                const success = clearAllHistory();
                if (success) {
                    showHistoryList();
                }
            }
        }

        /**
         * æ›´æ–°é€‰æ‹©è®¡æ•°æ˜¾ç¤º
         */
        function updateSelectedCount() {
            const t = translations[currentLang];
            const checkboxes = document.querySelectorAll('.history-checkbox:checked');
            const count = checkboxes.length;
            const selectedCountSpan = document.getElementById('selectedCount');
            const compareBtn = document.getElementById('generateHistoryComparison');
            const deleteSelectedBtn = document.getElementById('deleteSelectedHistory');

            if (selectedCountSpan) {
                selectedCountSpan.textContent = `${t.historySelectedCount} ${count} ${t.historySelectedCountSuffix}`;
            }

            if (compareBtn) {
                compareBtn.disabled = count === 0;
            }

            // v2.0: æ›´æ–°åˆ é™¤é€‰ä¸­æŒ‰é’®çŠ¶æ€
            if (deleteSelectedBtn) {
                deleteSelectedBtn.disabled = count === 0;
            }
        }

        /**
         * ä»å‹¾é€‰çš„å†å²è®°å½•ç”Ÿæˆå¯¹æ¯”å›¾è¡¨
         */
        function generateHistoryComparisonCharts() {
            const t = translations[currentLang];
            const checkboxes = document.querySelectorAll('.history-checkbox:checked');

            if (checkboxes.length === 0) {
                alert(t.historySelectAtLeastOne);
                return;
            }

            const history = loadHistoryFromStorage();
            comparisonData = []; // é‡ç½®å¯¹æ¯”æ•°æ®

            // è·å–å‹¾é€‰çš„è®°å½•ID
            const selectedIds = Array.from(checkboxes).map(cb => parseInt(cb.dataset.id));

            // ä¸ºæ¯ä¸ªé€‰ä¸­çš„å†å²è®°å½•ç”Ÿæˆå¯¹æ¯”æ•°æ®
            selectedIds.forEach(id => {
                const record = history.find(r => r.id === id);
                if (record) {
                    // v2.0: ä½¿ç”¨æ¨¡å‹åã€å¤‡æ³¨å’Œå¹¶å‘æ•°ï¼Œä¸åŒ…å«æ—¶é—´
                    const notesText = record.notes || 'N/A';
                    const label = `${record.config.modelName} - ${notesText} (å¹¶å‘ ${record.config.concurrency})`;
                    comparisonData.push(formatDataForComparison(record.results, label));
                }
            });

            // ç”Ÿæˆå¯¹æ¯”å›¾è¡¨
            if (comparisonData.length > 0) {
                generateComparisonCharts();

                // å…³é—­æ¨¡æ€æ¡†å¹¶æ»šåŠ¨åˆ°å¯¹æ¯”å›¾è¡¨
                closeHistoryModal();

                // å»¶è¿Ÿä¸€ä¸‹è®©æ¨¡æ€æ¡†å…³é—­åŠ¨ç”»å®Œæˆ
                setTimeout(() => {
                    const comparisonContainer = document.getElementById('comparisonChartContainer');
                    if (comparisonContainer) {
                        comparisonContainer.scrollIntoView({ behavior: 'smooth', block: 'start' });
                        alert(t.historyCompareSuccess);
                    }
                }, 300);
            }
        }

        /**
         * å…¨é€‰å†å²è®°å½•
         */
        function selectAllHistoryRecords() {
            const checkboxes = document.querySelectorAll('.history-checkbox');
            checkboxes.forEach(cb => {
                cb.checked = true;
            });
            updateSelectedCount();
        }

        /**
         * åé€‰å†å²è®°å½•
         */
        function deselectAllHistoryRecords() {
            const checkboxes = document.querySelectorAll('.history-checkbox');
            checkboxes.forEach(cb => {
                cb.checked = !cb.checked;
            });
            updateSelectedCount();
        }

        /**
         * åˆ é™¤é€‰ä¸­çš„å†å²è®°å½•
         */
        function deleteSelectedHistoryRecords() {
            const t = translations[currentLang];
            const checkboxes = document.querySelectorAll('.history-checkbox:checked');

            if (checkboxes.length === 0) {
                alert(t.historySelectAtLeastOne);
                return;
            }

            const count = checkboxes.length;
            const confirmMessage = t.historyConfirmDeleteSelected.replace('{count}', count);

            if (!confirm(confirmMessage)) {
                return;
            }

            const selectedIds = Array.from(checkboxes).map(cb => parseInt(cb.dataset.id));
            let history = loadHistoryFromStorage();

            // è¿‡æ»¤æ‰é€‰ä¸­çš„è®°å½•
            history = history.filter(record => !selectedIds.includes(record.id));

            // ä¿å­˜æ›´æ–°åçš„å†å²è®°å½•
            localStorage.setItem(HISTORY_STORAGE_KEY, JSON.stringify(history));

            // åˆ·æ–°åˆ—è¡¨æ˜¾ç¤º
            showHistoryList();

            // æ˜¾ç¤ºæˆåŠŸæ¶ˆæ¯
            const successMessage = t.historyDeletedSuccess.replace('{count}', count);
            alert(successMessage);
        }

        // äº‹ä»¶ç›‘å¬å™¨
        viewHistoryBtn.addEventListener('click', openHistoryModal);
        historyModalClose.addEventListener('click', closeHistoryModal);
        backToHistoryListBtn.addEventListener('click', showHistoryList);
        clearAllHistoryBtn.addEventListener('click', clearAllHistoryWithConfirm);

        // v2.0: å…¨é€‰/åé€‰/åˆ é™¤é€‰ä¸­æŒ‰é’®
        document.getElementById('selectAllHistory').addEventListener('click', selectAllHistoryRecords);
        document.getElementById('deselectAllHistory').addEventListener('click', deselectAllHistoryRecords);
        document.getElementById('deleteSelectedHistory').addEventListener('click', deleteSelectedHistoryRecords);

        // v1.9.1: é‡ç½®å‚æ•°æŒ‰é’®
        const resetParamsBtn = document.getElementById('resetParams');
        resetParamsBtn.addEventListener('click', function() {
            // åªé‡ç½®æµ‹è¯•å‚æ•°é…ç½®ï¼Œä¸é‡ç½®APIé…ç½®
            document.getElementById('minLength').value = d_minLength;
            document.getElementById('maxLength').value = d_maxLength;
            document.getElementById('step').value = d_step;
            document.getElementById('outputLength').value = d_outputLength;
            document.getElementById('concurrency').value = 1;
            document.getElementById('timeout').value = d_timeout;
            document.getElementById('temperatureInput').value = d_temperature;
            document.getElementById('topPInput').value = d_top_p;
            document.getElementById('presencePenaltyInput').value = d_presence_penalty;
            document.getElementById('frequencyPenaltyInput').value = d_frequency_penalty;
        });
        document.getElementById('generateHistoryComparison').addEventListener('click', generateHistoryComparisonCharts);

        // ç‚¹å‡»æ¨¡æ€æ¡†å¤–éƒ¨å…³é—­
        window.addEventListener('click', (event) => {
            if (event.target === historyModal) {
                closeHistoryModal();
            }
        });

        // æ›´æ–°è¯­è¨€åˆ‡æ¢å‡½æ•°ä¸­çš„æŒ‰é’®æ–‡æœ¬æ›´æ–°
        const originalSwitchLanguage = switchLanguage;
        switchLanguage = function(lang) {
            originalSwitchLanguage(lang);
            // æ›´æ–°å†å²è®°å½•æŒ‰é’®æ–‡æœ¬
            const t = translations[lang];
            viewHistoryBtn.textContent = t.historyBtn;
        };

        //
        window.onload = function () {
            setDefaultValues();
            // v1.9: æ›´æ–°å†å²è®°å½•æŒ‰é’®æ–‡æœ¬
            const t = translations[currentLang];
            viewHistoryBtn.textContent = t.historyBtn;
        };
    </script>
</body>

</html>