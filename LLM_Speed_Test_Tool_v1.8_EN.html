<!DOCTYPE html>
<html lang="en">
<!-- Original Author: çº¸é¸¢éšé£ (Bilibili) & DeepSeek-R1-0528-->
<!-- v1.8 (chao's mod):
    Get the latest updates from GitHub:
    https://github.com/gengchaogit/llm_speedtest
    1. (v1.8) æ·»åŠ å›¾è¡¨å¯¼å‡ºæŒ‰é’®
    2. (v1.8) æ·»åŠ å¤šä¸ªCSVç»“æœå¯¼å…¥å¯¹æ¯”åŠŸèƒ½
    3. (v1.8) åˆå¹¶å›¾è¡¨å¯¼å‡ºï¼šå°†Prefillå’ŒDecodeå›¾è¡¨ä¸€é”®å¯¼å‡ºä¸ºä¸€å¼ å›¾ç‰‡
    4. (v1.8) å¯¹æ¯”æ ‡ç­¾ï¼šä½¿ç”¨CSVæ–‡ä»¶åä½œä¸ºå¯¹æ¯”å›¾è¡¨çš„å›¾ä¾‹æ ‡ç­¾
    5. (v1.8) å¯¹æ¯”å¯¼å‡ºï¼šä¸ºå¯¹æ¯”å›¾è¡¨ä¹Ÿå¢åŠ ä¸€é”®å¯¼å‡ºåŠŸèƒ½ï¼Œå¹¶è‡ªåŠ¨ç”ŸæˆåŒ…å«å‚æ•°çš„æ–‡ä»¶å
    6. (v1.8) ã€é‡è¦ä¿®å¤ã€‘æ”¯æŒæ€è€ƒæ¨¡å‹ï¼šè§£æusageå­—æ®µè·å–å‡†ç¡®tokenç»Ÿè®¡ï¼ˆreasoning_tokens + completion_tokensï¼‰
    7. (v1.8) æ·»åŠ tokenä¼°ç®—fallbackï¼šå½“APIä¸è¿”å›usageæ—¶ä½¿ç”¨å­—ç¬¦ä¼°ç®—
    8. (v1.8) ã€å…³é”®ä¿®å¤ã€‘Prefillé€Ÿåº¦è®¡ç®—é”™è¯¯ï¼šç°åœ¨ä½¿ç”¨APIè¿”å›çš„å®é™…prompt_tokensè€Œéä¼°ç®—å€¼ï¼ˆä¿®å¤äº†çº¦10%è¯¯å·®ï¼‰
    9. (v1.8) ã€å…¼å®¹æ€§ä¿®å¤ã€‘æ”¯æŒå¤šç§æµå¼å“åº”æ ¼å¼ï¼šdelta.reasoning_contentï¼ˆæ€è€ƒï¼‰/ delta.content / message.content / text
    10. (v1.8) è‡ªåŠ¨ä¿å­˜/æ¢å¤æ‰€æœ‰é…ç½®å‚æ•°ï¼šAPIåœ°å€ã€æ¨¡å‹ã€æ¸©åº¦ã€å¹¶å‘æ•°ç­‰æ‰€æœ‰å‚æ•°ï¼Œä¸‹æ¬¡æ‰“å¼€è‡ªåŠ¨æ¢å¤
    11. (v1.8) ã€æ€è€ƒæ¨¡å‹ä¿®å¤ã€‘æ­£ç¡®è®¡ç®—reasoning+completionæ€»tokensï¼šå½“usageä¸å‡†æ—¶ä½¿ç”¨å†…å®¹ä¼°ç®—ï¼Œç¡®ä¿decodeé€Ÿåº¦å‡†ç¡®
    12. (v1.8) ã€æ€§èƒ½æµ‹é‡ä¼˜åŒ–ã€‘ä¼˜å…ˆä½¿ç”¨æœåŠ¡å™¨è¿”å›çš„çœŸå®GPUå¤„ç†æ—¶é—´ï¼ˆprompt_eval_duration/eval_durationï¼‰ï¼Œæ¶ˆé™¤ç½‘ç»œå»¶è¿Ÿå½±å“
-->

<!-- v1.7 (chaoåŸºäºåŸç‰ˆé­”æ”¹ç‰ˆ-qqç¾¤:1028429001):
    1. ä¸ºæ¯ä¸ªè¯·æ±‚å¢åŠ 3æ¬¡é‡è¯•ï¼ˆé—´éš”1.5ç§’ï¼‰ï¼Œä»¥è¿‡æ»¤æ‰ç¬æ—¶/å¶å‘çš„æœåŠ¡å™¨å¤±è´¥ã€‚
    2. è‡ªåŠ¨æ˜¾ç¤ºå›¾è¡¨ï¼Œæ— éœ€ç‚¹å‡»
    3. å°† Prefill å’Œ Decode é€Ÿåº¦åˆ†ç¦»åˆ°ä¸¤å¼ å›¾è¡¨
    4. ä¿®å¤é«˜å¹¶å‘ä¸‹ Promise.all ç†”æ–­é—®é¢˜ (ä½¿ç”¨ Promise.allSettled)
    5. å¢åŠ  AbortController å®ç°çš„è¯·æ±‚è¶…æ—¶
    6. ä¿å­˜å½“å‰é…ç½®åˆ° localStorage
-->
<!-- æœ¬å·¥å…·é€šè¿‡æµè§ˆå™¨æœ¬åœ°ç¦»çº¿è¿è¡Œ -->

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LLM Inference Speed Test Tool v1.8</title>
    <!-- å¼•å…¥ Chart.js ç”¨äºç»˜å›¾ -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
    <style>
        :root {
            --primary-color: #1a73e8;
            --success-color: #98c379;
            --error-color: #e06c75;
            --info-color: #61afef;
            --dark-bg: #282c34;
            --dark-row: #2f343a;
            --light-bg: #f4f7f9;
            --border-color: #e0e0e0;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background-color: var(--light-bg);
            color: #333;
            line-height: 1.6;
            padding: 20px;
            max-width: 1000px;
            margin: 0 auto;
        }

        .container {
            background: #fff;
            padding: 25px;
            border-radius: 8px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
            margin-bottom: 30px;
        }

        h1 {
            color: var(--primary-color);
            padding-bottom: 10px;
            margin-top: 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .api-selector {
            display: flex;
            margin-bottom: 20px;
            border-radius: 5px;
            overflow: hidden;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        .api-option {
            flex: 1;
            text-align: center;
            padding: 12px;
            background: #fff;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 1px solid var(--border-color);
        }

        .api-option:first-child {
            border-radius: 5px 0 0 5px;
        }

        .api-option:last-child {
            border-radius: 0 5px 5px 0;
        }

        .api-option.active {
            background-color: var(--primary-color);
            color: white;
            font-weight: bold;
            border-color: var(--primary-color);
        }

        .api-option:hover:not(.active) {
            background-color: #f0f7ff;
        }

        .config-section {
            margin-bottom: 20px;
        }

        h2 {
            color: #444;
            font-size: 1.2em;
            margin-bottom: 15px;
            padding-bottom: 5px;
            border-bottom: 1px dashed var(--border-color);
        }

        .form-row {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 15px;
        }

        .form-group {
            flex: 1;
            min-width: 200px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
        }

        .form-group input,
        .form-group select {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 1em;
        }

        button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 12px 20px;
            font-size: 1em;
            font-weight: 600;
            border-radius: 5px;
            cursor: pointer;
            transition: filter 0.1s, transform 0.1s;
            margin-top: 10px;
        }

        button:hover {
            filter: brightness(0.95);
        }

        button:active {
            transform: scale(0.98);
        }

        button:disabled {
            background-color: #a0a0a0 !important;
            cursor: not-allowed;
        }

        #results {
            background-color: var(--dark-bg);
            color: #abb2bf;
            padding: 15px;
            border-radius: 5px;
            min-height: 150px;
            margin-top: 20px;
            overflow-x: auto;
        }

        #results table {
            width: 100%;
            border-collapse: collapse;
            margin: 0;
            font-family: "Courier New", Courier, monospace;
            font-size: 0.9em;
            table-layout: fixed;
        }

        #results th,
        #results td {
            border: 1px solid #444;
            padding: 8px;
            text-align: left;
            color: #abb2bf;
            white-space: normal;
        }

        #results th {
            background-color: #333;
            color: #f8f8f2;
            position: sticky;
            top: 0;
            z-index: 1;
        }

        /* æç¤ºè¯é•¿åº¦ */
        #results th:nth-child(1),
        #results td:nth-child(1) {
            width: 14%;
        }

        /* é¢„å¡«å……è€—æ—¶ */
        #results th:nth-child(2),
        #results td:nth-child(2) {
            width: 16%;
        }

        /* é¢„å¡«å……é€Ÿåº¦ */
        #results th:nth-child(3),
        #results td:nth-child(3) {
            width: 14%;
        }

        /* è¾“å‡ºé•¿åº¦ */
        #results th:nth-child(4),
        #results td:nth-child(4) {
            width: 14%;
        }

        /* è¾“å‡ºè€—æ—¶ */
        #results th:nth-child(5),
        #results td:nth-child(5) {
            width: 16%;
        }

        /* è¾“å‡ºé€Ÿåº¦ */
        #results th:nth-child(6),
        #results td:nth-child(6) {
            width: 14%;
        }

        /* çŠ¶æ€ */
        #results th:nth-child(7),
        #results td:nth-child(7) {
            width: 12%;
        }

        #results tr:nth-child(even) {
            background-color: var(--dark-row);
        }

        .success {
            color: var(--success-color);
        }

        .error {
            color: var(--error-color);
        }

        .info {
            color: var(--info-color);
            padding: 5px 0;
            text-align: center;
        }

        .notes {
            color: var(--info-color);
            padding-bottom: 5px;
        }

        #markdownOutputHidden {
            position: absolute;
            left: -9999px;
            width: 1px;
            height: 1px;
            overflow: hidden;
            white-space: pre;
        }

        .progress-container {
            margin: 15px 0;
            background-color: #e0e0e0;
            border-radius: 5px;
            height: 10px;
            overflow: hidden;
        }

        .progress-bar {
            height: 100%;
            background-color: var(--primary-color);
            transition: width 0.3s ease;
        }

        .action-buttons {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .action-buttons button {
            flex: 1;
        }

        .api-description {
            margin-top: 10px;
            margin-bottom: 10px;
            padding: 15px;
            background-color: #f0f7ff;
            border-radius: 5px;
            border-left: 4px solid var(--primary-color);
        }

        .api-description h3 {
            color: var(--primary-color);
            margin-bottom: 10px;
        }

        .api-description ul {
            padding-left: 20px;
        }

        .api-description li {
            margin-bottom: 8px;
        }

        .logo {
            font-size: 24px;
        }

        .lang-toggle {
            margin-left: auto;
            padding: 8px 16px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        .lang-toggle:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }

        .lang-toggle:active {
            transform: translateY(0);
        }

        .concurrent-stats {
            background-color: #2c3e50;
            padding: 10px;
            border-radius: 5px;
            margin-top: 15px;
            font-family: monospace;
        }

        .concurrent-stats h3 {
            color: #61afef;
            margin-bottom: 8px;
            font-size: 1.1em;
        }

        .concurrent-stats .stat-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }

        .concurrent-stats .stat-value {
            color: #98c379;
        }

        #chartContainer {
            margin-top: 30px;
            background: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
        }

        #chartContainer h3 {
             color: #333;
             margin-bottom: 10px;
             text-align: center;
        }

        #outputChart {
            margin-top: 25px;
        }

        @media (max-width: 768px) {
            .form-row {
                flex-direction: column;
                gap: 10px;
            }

            .action-buttons {
                flex-direction: column;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <h1><span class="logo">ğŸš€</span> <span id="pageTitle">å¤§æ¨¡å‹ Prefill & Decode æ€§èƒ½æµ‹è¯•å·¥å…· v1.8 (chaoé­”æ”¹ç‰ˆ-åŠ ç»˜å›¾ä¿®bug-è‡ªåŠ¨ä¿å­˜api)</span><button class="lang-toggle" id="langToggle">English</button></h1>

        <div class="api-selector">
            <div class="api-option active" data-type="openai">OpenAIå…¼å®¹æ¥å£</div>
            <div class="api-option" data-type="ollama">Ollamaæ¥å£</div>
        </div>

        <div class="api-description" id="apiDescription">
            <h3>OpenAIå…¼å®¹æ¥å£æµ‹è¯•è¯´æ˜</h3>
            <ul>
                <li>ä½¿ç”¨æµå¼å“åº”(stream=true)æµ‹é‡é¦–å­—å»¶è¿Ÿ</li>
                <li>é¢„å¡«å……é€Ÿåº¦ = æç¤ºè¯é•¿åº¦ / (é¦–å­—åˆ°è¾¾æ—¶é—´ - è¯·æ±‚å¼€å§‹æ—¶é—´)</li>
                <li>è¾“å‡ºé€Ÿåº¦ = è¾“å‡ºtokenæ•° / (è¾“å‡ºå®Œæˆæ—¶é—´ - é¦–å­—åˆ°è¾¾æ—¶é—´)</li>
                <li>é€‚ç”¨äºæ‰€æœ‰å…¼å®¹OpenAI APIçš„å¤§æ¨¡å‹æœåŠ¡</li>
                <li><strong> æ”¯æŒæ€è€ƒæ¨¡å‹</strong>ï¼ˆDeepSeek-R1ã€Qwen-QwQç­‰ï¼‰ï¼šè‡ªåŠ¨ç»Ÿè®¡æ€»ååï¼ˆæ€è€ƒ+ç­”æ¡ˆtokensï¼‰</li>
            </ul>
        </div>

        <div class="config-section">
            <h2>API ä¿¡æ¯</h2>
            <div class="form-row">
                <div class="form-group">
                    <label for="apiUrl">API åœ°å€</label>
                    <input type="text" id="apiUrl" value="">
                </div>
                <div class="form-group">
                    <label for="modelName">æ¨¡å‹åç§°</label>
                    <input type="text" id="modelName" value="">
                </div>
            </div>
            <div class="form-row">
                <div class="form-group">
                    <label for="apiKey">API-Key</label>
                    <input type="text" id="apiKey" value="" placeholder="æœªè®¾ç½® API-Key åˆ™ç•™ç©º">
                </div>
            </div>
            <div class="form-row">
                <div class="form-group">
                    <label for="notes">å¤‡æ³¨</label>
                    <input type="text" id="notes" value="" placeholder="è¯·å¡«å†™è®¾å¤‡ä¿¡æ¯ã€æ¨¡å‹ä¿¡æ¯ã€æ¨¡å‹æ¨ç†æ¡†æ¶ï¼Œä»¥ä¾¿åœ¨ç»“æœä¸­æ˜¾ç¤º">
                </div>
            </div>
        </div>

        <div class="config-section">
            <h2>æµ‹è¯•å‚æ•°é…ç½®</h2>
            <div class="form-row">
                <div class="form-group">
                    <label for="minLength">æœ€å°æç¤ºè¯é•¿åº¦</label>
                    <input type="number" id="minLength" value="" step="128">
                </div>
                <div class="form-group">
                    <label for="maxLength">æœ€å¤§æç¤ºè¯é•¿åº¦</label>
                    <input type="number" id="maxLength" value="" step="128">
                </div>
                <div class="form-group">
                    <label for="step">æ­¥é•¿</label>
                    <input type="number" id="step" value="" step="128">
                </div>
                <div class="form-group">
                    <label for="outputLength">æœŸæœ›è¾“å‡ºé•¿åº¦</label>
                    <input type="number" id="outputLength" value="" min="1">
                </div>
            </div>
            <div class="form-row">
                <div class="form-group">
                    <label for="concurrency">å¹¶å‘æ•°</label>
                    <input type="number" id="concurrency" value="1" min="1" max="50">
                </div>
                <div class="form-group">
                    <label for="timeout">è¯·æ±‚è¶…æ—¶ (ms)</label>
                    <input type="number" id="timeout" value="" min="1000" step="1000">
                </div>
                <div class="form-group">
                    <label for="temperatureInput">Temperature</label>
                    <input type="number" id="temperatureInput" value="" step="0.1" min="0" max="2">
                </div>
                <div class="form-group">
                    <label for="topPInput">Top P</label>
                    <input type="number" id="topPInput" value="" step="0.01" min="0" max="1">
                </div>
            </div>
            <div class="form-row">
                 <div class="form-group">
                    <label for="presencePenaltyInput">Presence Penalty</label>
                    <input type="number" id="presencePenaltyInput" value="" step="0.1" min="-2" max="2">
                </div>
                <div class="form-group">
                    <label for="frequencyPenaltyInput">Frequency Penalty</label>
                    <input type="number" id="frequencyPenaltyInput" value="" step="0.1" min="-2" max="2">
                </div>
            </div>
        </div>

        <h2>æ‰§è¡Œæµ‹è¯•</h2>
        <div class="action-buttons">
            <button id="startTest" style="background: #349bea;">å¼€å§‹æµ‹è¯•</button>
            <button id="stopTest" style="display: none; background: #E74C3C;">åœæ­¢æµ‹è¯•</button>
            <button id="copyMarkdown" style="display: none; background: #4CAF50;">å¤åˆ¶ Markdown è¡¨æ ¼</button>
            <button id="exportCSV" style="display: none; background: #4eb8a6;">å¯¼å‡º CSV æ•°æ®</button>
            <!-- v1.8: åˆå¹¶å›¾è¡¨å¯¼å‡º -->
            <button id="exportCombinedChart" style="display: none; background: #f39c12;">å¯¼å‡ºä¸€å¼ å›¾è¡¨</button>
        </div>
        <div class="progress-container">
            <div id="progressBar" class="progress-bar" style="width: 0%"></div>
        </div>

        <!-- v1.8: æ–°å¢å¯¹æ¯”åŠŸèƒ½ -->
        <div class="config-section">
            <h2>å¤šç»“æœå¯¹æ¯”</h2>
            <div class="form-group">
                <label for="importFiles">å¯¼å…¥CSVç»“æœæ–‡ä»¶ (å¯å¤šé€‰)</label>
                <input type="file" id="importFiles" multiple accept=".csv" style="padding: 5px;">
            </div>
            <button id="startComparison" style="background: #27ae60;">ç”Ÿæˆå¯¹æ¯”å›¾è¡¨</button>
            <p class="notes" style="margin-top: 10px;">è¯´æ˜ï¼šå…ˆâ€œå¼€å§‹æµ‹è¯•â€è¿è¡Œä¸€æ¬¡ï¼Œç„¶åå†å¯¼å…¥å…¶ä»–CSVæ–‡ä»¶ï¼Œç‚¹å‡»â€œç”Ÿæˆå¯¹æ¯”å›¾è¡¨â€</p>
        </div>

        <div id="results">
            <p class="info">ç­‰å¾…å¼€å§‹æµ‹è¯•...</p>
        </div>

        <!-- ç»˜å›¾åŒºåŸŸï¼šåŒ…å«ä¸¤ä¸ª canvas -->
        <div id="chartContainer" style="display: none;">
            <h3>é¢„å¡«å…… (Prefill) åå</h3>
            <canvas id="prefillChart"></canvas>

            <h3 style="margin-top: 25px;">è¾“å‡º (Decode) åå</h3>
            <canvas id="outputChart"></canvas>
        </div>

        <!-- v1.8: æ–°çš„å¯¹æ¯”ç»˜å›¾åŒºåŸŸ -->
        <div id="comparisonChartContainer" style="display: none; margin-top: 30px; background: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 4px 10px rgba(0,0,0,0.1);">
            <h3>å¯¹æ¯” - é¢„å¡«å…… (Prefill) åå</h3>
            <canvas id="comparisonPrefillChart"></canvas>

            <h3 style="margin-top: 25px;">å¯¹æ¯” - è¾“å‡º (Decode) åå</h3>
            <canvas id="comparisonOutputChart"></canvas>

            <!-- v1.8: å¯¹æ¯”å›¾è¡¨å¯¼å‡ºæŒ‰é’® -->
            <button id="exportComparisonChart" style="display: none; background: #8e44ad; margin-top: 15px;">å¯¼å‡ºä¸€å¼ å¯¹æ¯”å›¾</button>
        </div>


        <textarea id="markdownOutputHidden"></textarea>
    </div>

    <script>
        // ===============================================================================
        // è¯­è¨€åˆ‡æ¢åŠŸèƒ½ (Language Toggle)
        // ===============================================================================
        const translations = {
            'zh': {
                pageTitle: 'å¤§æ¨¡å‹ Prefill & Decode æ€§èƒ½æµ‹è¯•å·¥å…· v1.8 (chaoé­”æ”¹ç‰ˆ-åŠ ç»˜å›¾ä¿®bug-è‡ªåŠ¨ä¿å­˜api)',
                langToggle: 'English',
                apiOpenAI: 'OpenAIå…¼å®¹æ¥å£',
                apiOllama: 'Ollamaæ¥å£',
                apiDescOpenAITitle: 'OpenAIå…¼å®¹æ¥å£æµ‹è¯•è¯´æ˜',
                apiDescOpenAI1: 'ä½¿ç”¨æµå¼å“åº”(stream=true)æµ‹é‡é¦–å­—å»¶è¿Ÿ',
                apiDescOpenAI2: 'é¢„å¡«å……é€Ÿåº¦ = æç¤ºè¯é•¿åº¦ / (é¦–å­—åˆ°è¾¾æ—¶é—´ - è¯·æ±‚å¼€å§‹æ—¶é—´)',
                apiDescOpenAI3: 'è¾“å‡ºé€Ÿåº¦ = è¾“å‡ºtokenæ•° / (è¾“å‡ºå®Œæˆæ—¶é—´ - é¦–å­—åˆ°è¾¾æ—¶é—´)',
                apiDescOpenAI4: 'é€‚ç”¨äºæ‰€æœ‰å…¼å®¹OpenAI APIçš„å¤§æ¨¡å‹æœåŠ¡',
                apiDescOpenAI5: '<strong> æ”¯æŒæ€è€ƒæ¨¡å‹</strong>ï¼ˆDeepSeek-R1ã€Qwen-QwQç­‰ï¼‰ï¼šè‡ªåŠ¨ç»Ÿè®¡æ€»ååï¼ˆæ€è€ƒ+ç­”æ¡ˆtokensï¼‰',
                apiDescOllamaTitle: 'Ollamaæ¥å£æµ‹è¯•è¯´æ˜',
                apiDescOllama1: 'ä½¿ç”¨éæµå¼è¯·æ±‚(stream=false)',
                apiDescOllama2: 'ç›´æ¥ä½¿ç”¨APIè¿”å›çš„prompt_eval_durationå’Œeval_durationæŒ‡æ ‡',
                apiDescOllama3: 'é¢„å¡«å……é€Ÿåº¦ = æç¤ºè¯é•¿åº¦ / (prompt_eval_duration / 1000)',
                apiDescOllama4: 'è¾“å‡ºé€Ÿåº¦ = è¾“å‡ºtokenæ•° / (eval_duration / 1000)',
                apiDescOllama5: '<strong> æ”¯æŒæ€è€ƒæ¨¡å‹</strong>ï¼ševal_countè‡ªåŠ¨åŒ…å«æ‰€æœ‰è¾“å‡ºtokens',
                sectionApiInfo: 'API ä¿¡æ¯',
                labelApiUrl: 'API åœ°å€',
                labelModelName: 'æ¨¡å‹åç§°',
                labelApiKey: 'API-Key',
                placeholderApiKey: 'æœªè®¾ç½® API-Key åˆ™ç•™ç©º',
                labelNotes: 'å¤‡æ³¨',
                placeholderNotes: 'è¯·å¡«å†™è®¾å¤‡ä¿¡æ¯ã€æ¨¡å‹ä¿¡æ¯ã€æ¨¡å‹æ¨ç†æ¡†æ¶ï¼Œä»¥ä¾¿åœ¨ç»“æœä¸­æ˜¾ç¤º',
                sectionTestParams: 'æµ‹è¯•å‚æ•°é…ç½®',
                labelMinLength: 'æœ€å°æç¤ºè¯é•¿åº¦',
                labelMaxLength: 'æœ€å¤§æç¤ºè¯é•¿åº¦',
                labelStep: 'æ­¥é•¿',
                labelOutputLength: 'æœŸæœ›è¾“å‡ºé•¿åº¦',
                labelConcurrency: 'å¹¶å‘æ•°',
                labelTimeout: 'è¯·æ±‚è¶…æ—¶ (ms)',
                sectionExecTest: 'æ‰§è¡Œæµ‹è¯•',
                btnStartTest: 'å¼€å§‹æµ‹è¯•',
                btnStopTest: 'åœæ­¢æµ‹è¯•',
                btnCopyMarkdown: 'å¤åˆ¶ Markdown è¡¨æ ¼',
                btnExportCSV: 'å¯¼å‡º CSV æ•°æ®',
                btnExportCombinedChart: 'å¯¼å‡ºä¸€å¼ å›¾è¡¨',
                sectionComparison: 'å¤šç»“æœå¯¹æ¯”',
                labelImportFiles: 'å¯¼å…¥CSVç»“æœæ–‡ä»¶ (å¯å¤šé€‰)',
                btnStartComparison: 'ç”Ÿæˆå¯¹æ¯”å›¾è¡¨',
                comparisonNote: 'è¯´æ˜ï¼šå…ˆ"å¼€å§‹æµ‹è¯•"è¿è¡Œä¸€æ¬¡ï¼Œç„¶åå†å¯¼å…¥å…¶ä»–CSVæ–‡ä»¶ï¼Œç‚¹å‡»"ç”Ÿæˆå¯¹æ¯”å›¾è¡¨"',
                msgWaiting: 'ç­‰å¾…å¼€å§‹æµ‹è¯•...',
                chartPrefillTitle: 'é¢„å¡«å…… (Prefill) åå',
                chartDecodeTitle: 'è¾“å‡º (Decode) åå',
                chartComparisonPrefillTitle: 'å¯¹æ¯” - é¢„å¡«å…… (Prefill) åå',
                chartComparisonDecodeTitle: 'å¯¹æ¯” - è¾“å‡º (Decode) åå',
                btnExportComparisonChart: 'å¯¼å‡ºä¸€å¼ å¯¹æ¯”å›¾',
                concurrentStatsTitle: 'æ€»ååé‡æ€§èƒ½ç»Ÿè®¡',
                concurrentLabel: 'å¹¶å‘',
                // è¡¨æ ¼æ ‡é¢˜
                tableHeaderPromptLen: 'æç¤ºè¯é•¿åº¦<br>(tokens)',
                tableHeaderPrefillTime: 'é¢„å¡«å……è€—æ—¶<br>(ms)',
                tableHeaderPrefillSpeed: 'é¢„å¡«å……é€Ÿåº¦<br>(tokens/s)',
                tableHeaderOutputLen: 'è¾“å‡ºé•¿åº¦<br>(tokens)',
                tableHeaderOutputTime: 'è¾“å‡ºè€—æ—¶<br>(ms)',
                tableHeaderOutputSpeed: 'è¾“å‡ºé€Ÿåº¦<br>(tokens/s)',
                tableHeaderStatus: 'çŠ¶æ€',
                // ç»Ÿè®¡æ ‡é¢˜
                statTotalPrefillRange: 'æ€»é¢„å¡«å……ååèŒƒå›´:',
                statTotalDecodeRange: 'æ€»è¾“å‡ºååèŒƒå›´:',
                statAvgPrefill: 'å¹³å‡æ€»é¢„å¡«å……åå:',
                statAvgDecode: 'å¹³å‡æ€»è¾“å‡ºåå:',
                // å›¾è¡¨ç›¸å…³
                chartLabelPrefillThroughput: 'æ€»é¢„å¡«å……åå (tokens/s)',
                chartLabelDecodeThroughput: 'æ€»è¾“å‡ºåå (tokens/s)',
                chartTitlePrefillThroughput: 'æ€»é¢„å¡«å…… (Prefill) åå',
                chartTitleDecodeThroughput: 'æ€»è¾“å‡º (Decode) åå',
                chartAxisPromptLen: 'æç¤ºè¯é•¿åº¦ (tokens)',
                chartAxisThroughput: 'åå (tokens/s)',
                chartComparisonPrefillThroughput: 'å¯¹æ¯” - æ€»é¢„å¡«å…… (Prefill) åå',
                chartComparisonDecodeThroughput: 'å¯¹æ¯” - æ€»è¾“å‡º (Decode) åå',
                // Markdown / CSV
                mdTestResults: 'æµ‹è¯•ç»“æœ',
                mdNotes: 'å¤‡æ³¨ï¼š',
                mdConcurrency: 'å¹¶å‘æ•°:',
                csvConcurrency: 'å¹¶å‘æ•°ï¼š',
                csvHeaders: 'æç¤ºè¯é•¿åº¦(tokens),é¢„å¡«å……è€—æ—¶(ms),é¢„å¡«å……é€Ÿåº¦(tokens/s),è¾“å‡ºé•¿åº¦(tokens),è¾“å‡ºè€—æ—¶(ms),è¾“å‡ºé€Ÿåº¦(tokens/s),çŠ¶æ€',
                // é”™è¯¯æ¶ˆæ¯å’Œæç¤º
                errMissingColumns: 'CSVæ–‡ä»¶ç¼ºå°‘å¿…è¦çš„åˆ— (æç¤ºè¯é•¿åº¦, é¢„å¡«å……é€Ÿåº¦, è¾“å‡ºé€Ÿåº¦)',
                errHttpError: 'HTTPé”™è¯¯! çŠ¶æ€:',
                alertMarkdownCopied: 'Markdownè¡¨æ ¼å·²å¤åˆ¶åˆ°å‰ªè´´æ¿ï¼',
                alertNoTestResults: 'è¯·å…ˆè‡³å°‘è¿è¡Œä¸€æ¬¡"å¼€å§‹æµ‹è¯•"ï¼Œä»¥ä¾¿å°†å½“å‰ç»“æœåŒ…å«åœ¨å¯¹æ¯”ä¸­ã€‚',
                btnTextStart: 'å¼€å§‹æµ‹è¯•',
                btnTextStop: 'åœæ­¢'
            },
            'en': {
                pageTitle: 'LLM Prefill & Decode Performance Testing Tool v1.8 (chao mod - charts + bugfix + autosave)',
                langToggle: 'ä¸­æ–‡',
                apiOpenAI: 'OpenAI Compatible API',
                apiOllama: 'Ollama API',
                apiDescOpenAITitle: 'OpenAI Compatible API Test Description',
                apiDescOpenAI1: 'Use streaming response (stream=true) to measure time to first token',
                apiDescOpenAI2: 'Prefill speed = prompt length / (time to first token - request start time)',
                apiDescOpenAI3: 'Decode speed = output tokens / (completion time - time to first token)',
                apiDescOpenAI4: 'Works with all OpenAI API compatible LLM services',
                apiDescOpenAI5: '<strong> Supports thinking models</strong> (DeepSeek-R1, Qwen-QwQ, etc.): automatically counts total throughput (reasoning + answer tokens)',
                apiDescOllamaTitle: 'Ollama API Test Description',
                apiDescOllama1: 'Use non-streaming request (stream=false)',
                apiDescOllama2: 'Directly use prompt_eval_duration and eval_duration from API response',
                apiDescOllama3: 'Prefill speed = prompt length / (prompt_eval_duration / 1000)',
                apiDescOllama4: 'Decode speed = output tokens / (eval_duration / 1000)',
                apiDescOllama5: '<strong> Supports thinking models</strong>: eval_count automatically includes all output tokens',
                sectionApiInfo: 'API Information',
                labelApiUrl: 'API URL',
                labelModelName: 'Model Name',
                labelApiKey: 'API Key',
                placeholderApiKey: 'Leave empty if no API key is required',
                labelNotes: 'Notes',
                placeholderNotes: 'Fill in device info, model info, inference framework for display in results',
                sectionTestParams: 'Test Parameters',
                labelMinLength: 'Min Prompt Length',
                labelMaxLength: 'Max Prompt Length',
                labelStep: 'Step Size',
                labelOutputLength: 'Expected Output Length',
                labelConcurrency: 'Concurrency',
                labelTimeout: 'Request Timeout (ms)',
                sectionExecTest: 'Execute Test',
                btnStartTest: 'Start Test',
                btnStopTest: 'Stop Test',
                btnCopyMarkdown: 'Copy Markdown Table',
                btnExportCSV: 'Export CSV Data',
                btnExportCombinedChart: 'Export Combined Chart',
                sectionComparison: 'Multi-Result Comparison',
                labelImportFiles: 'Import CSV result files (multiple selection)',
                btnStartComparison: 'Generate Comparison Charts',
                comparisonNote: 'Note: First run "Start Test", then import other CSV files and click "Generate Comparison Charts"',
                msgWaiting: 'Waiting to start test...',
                chartPrefillTitle: 'Prefill Throughput',
                chartDecodeTitle: 'Decode Throughput',
                chartComparisonPrefillTitle: 'Comparison - Prefill Throughput',
                chartComparisonDecodeTitle: 'Comparison - Decode Throughput',
                btnExportComparisonChart: 'Export Comparison Chart',
                concurrentStatsTitle: 'Total Throughput Performance Statistics',
                concurrentLabel: 'Concurrent',
                // Table headers
                tableHeaderPromptLen: 'Prompt Length<br>(tokens)',
                tableHeaderPrefillTime: 'Prefill Time<br>(ms)',
                tableHeaderPrefillSpeed: 'Prefill Speed<br>(tokens/s)',
                tableHeaderOutputLen: 'Output Length<br>(tokens)',
                tableHeaderOutputTime: 'Output Time<br>(ms)',
                tableHeaderOutputSpeed: 'Output Speed<br>(tokens/s)',
                tableHeaderStatus: 'Status',
                // Statistics
                statTotalPrefillRange: 'Total Prefill Throughput Range:',
                statTotalDecodeRange: 'Total Decode Throughput Range:',
                statAvgPrefill: 'Avg Total Prefill Throughput:',
                statAvgDecode: 'Avg Total Decode Throughput:',
                // Chart related
                chartLabelPrefillThroughput: 'Total Prefill Throughput (tokens/s)',
                chartLabelDecodeThroughput: 'Total Decode Throughput (tokens/s)',
                chartTitlePrefillThroughput: 'Total Prefill Throughput',
                chartTitleDecodeThroughput: 'Total Decode Throughput',
                chartAxisPromptLen: 'Prompt Length (tokens)',
                chartAxisThroughput: 'Throughput (tokens/s)',
                chartComparisonPrefillThroughput: 'Comparison - Total Prefill Throughput',
                chartComparisonDecodeThroughput: 'Comparison - Total Decode Throughput',
                // Markdown / CSV
                mdTestResults: 'Test Results',
                mdNotes: 'Notes:',
                mdConcurrency: 'Concurrency:',
                csvConcurrency: 'Concurrency:',
                csvHeaders: 'Prompt Length(tokens),Prefill Time(ms),Prefill Speed(tokens/s),Output Length(tokens),Output Time(ms),Output Speed(tokens/s),Status',
                // Error messages and alerts
                errMissingColumns: 'CSV file missing required columns (Prompt Length, Prefill Speed, Output Speed)',
                errHttpError: 'HTTP Error! Status:',
                alertMarkdownCopied: 'Markdown table copied to clipboard!',
                alertNoTestResults: 'Please run "Start Test" at least once to include current results in comparison.',
                btnTextStart: 'Start Test',
                btnTextStop: 'Stop'
            }
        };

        // Current language (default: English)
        let currentLang = localStorage.getItem('llmPerfTestLang') || 'en';

        // åˆ‡æ¢è¯­è¨€å‡½æ•°
        function switchLanguage(lang) {
            currentLang = lang;
            localStorage.setItem('llmPerfTestLang', lang);

            const t = translations[lang];

            // æ›´æ–°é¡µé¢æ ‡é¢˜
            document.getElementById('pageTitle').textContent = t.pageTitle;
            document.getElementById('langToggle').textContent = t.langToggle;

            // æ›´æ–°APIé€‰æ‹©å™¨
            const apiOptions = document.querySelectorAll('.api-option');
            apiOptions[0].textContent = t.apiOpenAI;
            apiOptions[1].textContent = t.apiOllama;

            // æ›´æ–°APIæè¿°ï¼ˆæ ¹æ®å½“å‰é€‰ä¸­çš„ç±»å‹ï¼‰
            const activeApiType = document.querySelector('.api-option.active').dataset.type;
            updateApiDescription(activeApiType);

            // æ›´æ–°å„ä¸ªsectionæ ‡é¢˜
            const sections = document.querySelectorAll('.config-section h2, h2');
            sections[0].textContent = t.sectionApiInfo;
            sections[1].textContent = t.sectionTestParams;
            sections[2].textContent = t.sectionExecTest;
            sections[3].textContent = t.sectionComparison;

            // æ›´æ–°æ ‡ç­¾
            document.querySelector('label[for="apiUrl"]').textContent = t.labelApiUrl;
            document.querySelector('label[for="modelName"]').textContent = t.labelModelName;
            document.querySelector('label[for="apiKey"]').textContent = t.labelApiKey;
            document.getElementById('apiKey').placeholder = t.placeholderApiKey;
            document.querySelector('label[for="notes"]').textContent = t.labelNotes;
            document.getElementById('notes').placeholder = t.placeholderNotes;
            document.querySelector('label[for="minLength"]').textContent = t.labelMinLength;
            document.querySelector('label[for="maxLength"]').textContent = t.labelMaxLength;
            document.querySelector('label[for="step"]').textContent = t.labelStep;
            document.querySelector('label[for="outputLength"]').textContent = t.labelOutputLength;
            document.querySelector('label[for="concurrency"]').textContent = t.labelConcurrency;
            document.querySelector('label[for="timeout"]').textContent = t.labelTimeout;
            document.querySelector('label[for="importFiles"]').textContent = t.labelImportFiles;

            // æ›´æ–°æŒ‰é’®
            document.getElementById('startTest').textContent = t.btnStartTest;
            document.getElementById('stopTest').textContent = t.btnStopTest;
            document.getElementById('copyMarkdown').textContent = t.btnCopyMarkdown;
            document.getElementById('exportCSV').textContent = t.btnExportCSV;
            document.getElementById('exportCombinedChart').textContent = t.btnExportCombinedChart;
            document.getElementById('startComparison').textContent = t.btnStartComparison;
            document.getElementById('exportComparisonChart').textContent = t.btnExportComparisonChart;

            // æ›´æ–°è¯´æ˜æ–‡å­—
            document.querySelector('.config-section p.notes').textContent = t.comparisonNote;

            // æ›´æ–°å›¾è¡¨æ ‡é¢˜
            const chartTitles = document.querySelectorAll('#chartContainer h3');
            if (chartTitles.length >= 2) {
                chartTitles[0].textContent = t.chartPrefillTitle;
                chartTitles[1].textContent = t.chartDecodeTitle;
            }

            const comparisonTitles = document.querySelectorAll('#comparisonChartContainer h3');
            if (comparisonTitles.length >= 2) {
                comparisonTitles[0].textContent = t.chartComparisonPrefillTitle;
                comparisonTitles[1].textContent = t.chartComparisonDecodeTitle;
            }

            // å¦‚æœç»“æœåŒºåŸŸæ˜¯ç­‰å¾…çŠ¶æ€ï¼Œæ›´æ–°æ–‡æœ¬
            const resultsDiv = document.getElementById('results');
            if (resultsDiv && resultsDiv.querySelector('.info')) {
                const infoElem = resultsDiv.querySelector('.info');
                if (infoElem.textContent.includes('ç­‰å¾…') || infoElem.textContent.includes('Waiting')) {
                    infoElem.textContent = t.msgWaiting;
                }
            }
        }

        // ç»‘å®šè¯­è¨€åˆ‡æ¢æŒ‰é’®
        document.getElementById('langToggle').addEventListener('click', function() {
            const newLang = currentLang === 'zh' ? 'en' : 'zh';
            switchLanguage(newLang);
        });

        // é¡µé¢åŠ è½½æ—¶åº”ç”¨ä¿å­˜çš„è¯­è¨€
        document.addEventListener('DOMContentLoaded', function() {
            switchLanguage(currentLang);
        });

        // é»˜è®¤å‚æ•°è®¾ç½®
        // ===============================================================================
        // API ç«¯ç‚¹å’Œæ¨¡å‹åç§°é…ç½®
        let d_openai_apiUrl = 'http://10.0.0.50:8000/v1/chat/completions';          // OpenAI å…¼å®¹ API çš„ URL åœ°å€
        let d_openai_modelName = 'Qwen3-30B-A3B-Instruct-2507-Int4-W4A16';                                          // OpenAI å…¼å®¹ API æ‰€ä½¿ç”¨çš„æ¨¡å‹åç§°æˆ–è·¯å¾„
        let d_ollama_apiUrl = 'http://localhost:11434/api/chat';                    // Ollama API çš„ URL åœ°å€
        let d_ollama_modelName = 'Qwen3-32B-AWQ';                                      // Ollama API æ‰€ä½¿ç”¨çš„æ¨¡å‹åç§°
        let d_api_key = '';                                                         // è®¿é—® API æ‰€éœ€çš„è®¤è¯å¯†é’¥ï¼Œå¦‚æœä¸éœ€è¦åˆ™å¯ä»¥ç•™ç©º
        // æ–‡æœ¬ç”Ÿæˆé•¿åº¦æ§åˆ¶å‚æ•° (æ•´æ•°)
        let d_minLength = 512;                                                      // ç”Ÿæˆæ–‡æœ¬çš„æœ€å°é•¿åº¦ï¼ˆä¾‹å¦‚ï¼Œtoken æˆ–å­—ç¬¦æ•°ï¼‰
        let d_maxLength = 8192;                                                     // ç”Ÿæˆæ–‡æœ¬çš„æœ€å¤§é•¿åº¦ï¼ˆä¾‹å¦‚ï¼Œtoken æˆ–å­—ç¬¦æ•°ï¼‰
        let d_step = 512;                                                           // æ¯æ¬¡æç¤ºè¯é•¿åº¦å¢åŠ çš„æ­¥é•¿
        let d_outputLength = 128;                                                   // æœŸæœ›è¾“å‡ºçš„æ–‡æœ¬é•¿åº¦
        let d_timeout = 30000;                                                      // è¯·æ±‚è¶…æ—¶æ—¶é—´ (ms)
        // æ–‡æœ¬ç”Ÿæˆé‡‡æ ·å‚æ•° (æµ®ç‚¹æ•°)
        let d_temperature = 1.0;                                                    // æ§åˆ¶ç”Ÿæˆæ–‡æœ¬çš„éšæœºæ€§ã€‚å€¼è¶Šé«˜ï¼Œæ–‡æœ¬è¶Šéšæœºï¼ˆ0.0è¡¨ç¤ºç¡®å®šæ€§ï¼Œ1.0è¡¨ç¤ºè¾ƒé«˜éšæœºæ€§ï¼‰
        let d_top_p = 0.1;                                                          // æ§åˆ¶ç”Ÿæˆæ–‡æœ¬çš„å¤šæ ·æ€§ã€‚åªè€ƒè™‘ç´¯ç§¯æ¦‚ç‡è¾¾åˆ° top_p çš„è¯æ±‡ï¼ˆ0.0-1.0ï¼‰
        let d_presence_penalty = -1.0;                                              // å¯¹ç”Ÿæˆæ–‡æœ¬ä¸­å·²ç»å‡ºç°çš„è¯æ±‡è¿›è¡Œæƒ©ç½šï¼Œå‡å°‘é‡å¤ï¼ˆé€šå¸¸åœ¨ -2.0 åˆ° 2.0 ä¹‹é—´ï¼‰
        let d_frequency_penalty = -1.0;                                             // å¯¹ç”Ÿæˆæ–‡æœ¬ä¸­è¯æ±‡å‡ºç°çš„é¢‘ç‡è¿›è¡Œæƒ©ç½šï¼Œå‡å°‘å¸¸ç”¨è¯çš„é‡å¤ï¼ˆé€šå¸¸åœ¨ -2.0 åˆ° 2.0 ä¹‹é—´ï¼‰
        // ===============================================================================

        // APIç±»å‹åˆ‡æ¢
        const apiOptions = document.querySelectorAll('.api-option');
        const apiDescription = document.getElementById('apiDescription');

        apiOptions.forEach(option => {
            option.addEventListener('click', () => {
                apiOptions.forEach(o => o.classList.remove('active'));
                option.classList.add('active');

                const apiType = option.dataset.type;
                updateApiDescription(apiType);
                updateDefaultValues(apiType);
            });
        });

        function updateApiDescription(apiType) {
            const t = translations[currentLang];
            if (apiType === 'openai') {
                apiDescription.innerHTML = `
                    <h3>${t.apiDescOpenAITitle}</h3>
                    <ul>
                        <li>${t.apiDescOpenAI1}</li>
                        <li>${t.apiDescOpenAI2}</li>
                        <li>${t.apiDescOpenAI3}</li>
                        <li>${t.apiDescOpenAI4}</li>
                        <li>${t.apiDescOpenAI5}</li>
                    </ul>
                `;
            } else {
                apiDescription.innerHTML = `
                    <h3>${t.apiDescOllamaTitle}</h3>
                    <ul>
                        <li>${t.apiDescOllama1}</li>
                        <li>${t.apiDescOllama2}</li>
                        <li>${t.apiDescOllama3}</li>
                        <li>${t.apiDescOllama4}</li>
                        <li>${t.apiDescOllama5}</li>
                    </ul>
                `;
            }
        }

        function updateDefaultValues(apiType) {
            const apiUrl = document.getElementById('apiUrl');
            const modelName = document.getElementById('modelName');

            if (apiType === 'openai') {
                apiUrl.value = d_openai_apiUrl;
                modelName.value = d_openai_modelName;
            } else {
                apiUrl.value = d_ollama_apiUrl;
                modelName.value = d_ollama_modelName;
            }
        }

        // åˆå§‹åŒ–
        updateApiDescription('openai');

        // å•è¯åº“ç”¨äºç”Ÿæˆæç¤ºè¯
        const wordList = [
            "active", "project", "quality", "develop", "example", "explore", "journey", "library",
            "advance", "another", "because", "believe", "between", "central", "channel", "charity",
            "collect", "company", "compare", "compete", "compute", "concept", "concern", "confirm",
            "contact", "contain", "content", "context", "control", "country", "culture", "current",
            "digital", "discuss", "document", "economy", "element", "energy", "engine", "enhance",
            "evening", "exactly", "examine", "execute", "explain", "express", "feature", "federal",
            "feeling", "finance"
        ];

        // æ ¹æ®æŒ‡å®šé•¿åº¦ç”Ÿæˆæç¤ºè¯
        function generatePrompt(length, apiType, seed = 0) {
            let prompt = [];

            //  æ·»åŠ å”¯ä¸€å‰ç¼€ä»¥é¿å…prefix cacheå‘½ä¸­ï¼ˆå¹¶å‘æµ‹è¯•æ—¶å¾ˆé‡è¦ï¼‰
            if (seed > 0) {
                prompt.push(`[Request-${seed}-${Date.now()}]`);
            }

            for (let i = 0; i < length - 20; i++) {
                const randomIndex = Math.floor(Math.random() * wordList.length);
                prompt.push(wordList[randomIndex]);
            }

            return prompt.join(' ') + `\n\nRepeat the above text 100 times`;
        }

        const startTestBtn = document.getElementById('startTest');
        const stopTestBtn = document.getElementById('stopTest');
        const copyMarkdownBtn = document.getElementById('copyMarkdown');
        const exportCSVBtn = document.getElementById('exportCSV');
        const exportCombinedChartBtn = document.getElementById('exportCombinedChart'); // v1.8
        const startComparisonBtn = document.getElementById('startComparison'); // v1.8
        const importFilesInput = document.getElementById('importFiles'); // v1.8
        const exportComparisonChartBtn = document.getElementById('exportComparisonChart'); // v1.8

        const resultsDiv = document.getElementById('results');
        const markdownOutputHidden = document.getElementById('markdownOutputHidden');
        const progressBar = document.getElementById('progressBar');

        // è·å–å›¾è¡¨å…ƒç´ 
        const chartContainer = document.getElementById('chartContainer');
        const prefillChartCanvas = document.getElementById('prefillChart');
        const outputChartCanvas = document.getElementById('outputChart');
        let prefillChartInstance = null;
        let outputChartInstance = null;

        // å¯¹æ¯”å›¾è¡¨ (v1.8)
        let comparisonData = [];
        let comparisonPrefillChartInstance = null;
        let comparisonOutputChartInstance = null;

        let testResultsData = [];
        let totalTests = 0;
        let completedTests = 0;
        let isTestingRunning = false;
        let currentApiType = 'openai';
        let currentModelName = '/model';
        let api_key = '';
        let notes = '';
        let concurrencyStats = {
            minPrefillSpeed: Infinity,
            maxPrefillSpeed: 0,
            minOutputSpeed: Infinity,
            maxOutputSpeed: 0,
            avgPrefillSpeed: 0,
            avgOutputSpeed: 0
        };

        // å¸¦é‡è¯•çš„ fetch è¾…åŠ©å‡½æ•°
        /**
         * Fetches a resource with retry logic.
         * @param {string} apiUrl - The URL to fetch.
         * @param {object} fetchOptions - The options for the fetch call (method, headers, body).
         * @param {number} timeout - The timeout for each attempt in milliseconds.
         * @param {number} retries - The total number of attempts.
         * @param {number} delay - The delay between retries in milliseconds.
         * @returns {Promise<Response>} - A promise that resolves with the Response object.
         */
        async function createFetchPromiseWithRetry(apiUrl, fetchOptions, timeout, retries = 3, delay = 1500) {
            for (let i = 0; i < retries; i++) {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), timeout);

                try {
                    const response = await fetch(apiUrl, {
                        ...fetchOptions,
                        signal: controller.signal
                    });

                    clearTimeout(timeoutId); // Success, clear timeout

                    // Note: We return the response even if !response.ok
                    // The processing function (e.g., processOpenAIStreamResponse) is responsible for checking response.ok
                    return response; // Return the successful response

                } catch (error) {
                    clearTimeout(timeoutId); // Failed attempt

                    // Log the attempt
                    console.warn(`[RetryLogic] Attempt ${i + 1}/${retries} for ${fetchOptions.body.length} bytes failed: ${error.message}`);

                    if (i === retries - 1) {
                        // This was the last attempt, re-throw the error to be caught by allSettled
                        console.error(`[RetryLogic] All ${retries} attempts failed.`);
                        throw error;
                    }

                    // Wait before the next retry
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            }
        }


        //  Tokenä¼°ç®—å‡½æ•°ï¼ˆå½“APIä¸è¿”å›usageæ—¶çš„fallbackï¼‰
        function estimateTokenCount(text) {
            if (!text || text.length === 0) return 0;

            // ç»Ÿè®¡ä¸­æ–‡å­—ç¬¦æ•°é‡
            const chineseChars = (text.match(/[\u4e00-\u9fa5]/g) || []).length;
            // å…¶ä»–å­—ç¬¦ï¼ˆè‹±æ–‡ã€æ•°å­—ã€ç¬¦å·ç­‰ï¼‰
            const otherChars = text.length - chineseChars;

            // ç²—ç•¥ä¼°ç®—ï¼šä¸­æ–‡çº¦1.5å­—ç¬¦=1tokenï¼Œè‹±æ–‡çº¦4å­—ç¬¦=1token
            const estimatedTokens = Math.round(chineseChars / 1.5 + otherChars / 4);

            console.log(`[Tokenä¼°ç®—] æ€»å­—ç¬¦: ${text.length}, ä¸­æ–‡: ${chineseChars}, å…¶ä»–: ${otherChars}, ä¼°ç®—tokens: ${estimatedTokens}`);

            return estimatedTokens;
        }

        // ã€ä¿®å¤ã€‘æµ‹è¯•OpenAIå…¼å®¹æ¥å£
        async function testOpenAI(apiUrl, modelName, minLength, maxLength, step, outputLength, temperature, top_p, presence_penalty, frequency_penalty, concurrency, timeout) {
            for (let length = minLength; length <= maxLength; length += step) {
                if (!isTestingRunning) break;

                // F12æ§åˆ¶å°æ—¥å¿—
                console.log(`[Test] å‡†å¤‡æµ‹è¯•æç¤ºè¯é•¿åº¦: ${length}`);

                const row = document.createElement('tr');
                resultsDiv.querySelector('tbody').appendChild(row);
                const cells = [];
                for (let i = 0; i < 7; i++) {
                    const cell = document.createElement('td');
                    cells.push(cell);
                    row.appendChild(cell);
                }

                cells[0].textContent = length;
                cells[1].textContent = "æµ‹è¯•ä¸­...";
                cells[2].textContent = "æµ‹è¯•ä¸­...";
                cells[3].textContent = "æµ‹è¯•ä¸­...";
                cells[4].textContent = "æµ‹è¯•ä¸­...";
                cells[5].textContent = "æµ‹è¯•ä¸­...";
                cells[6].textContent = `${concurrency}å¹¶å‘æµ‹è¯•ä¸­...`;
                row.classList.add('info');
                resultsDiv.scrollTop = resultsDiv.scrollHeight;

                let resultEntry = {
                    promptLength: length,
                    prefillTimeMs: 'N/A',
                    prefillSpeed: 'N/A',
                    outputTokens: 'N/A',
                    outputTimeMs: 'N/A',
                    outputSpeed: 'N/A',
                    status: 'å¤±è´¥',
                    concurrency: concurrency
                };

                // æš–æœºè¯·æ±‚ (å¯é€‰, ä¿ç•™)
                if (length == minLength) {
                    try {
                        console.log("[Test] å‘é€æš–æœºè¯·æ±‚...");
                        const controller = new AbortController();
                        const timeoutId = setTimeout(() => controller.abort(), 5000); // æš–æœº5ç§’è¶…æ—¶
                        await fetch(apiUrl, {
                            method: 'POST',
                            headers: {
                                'Authorization': `Bearer ${api_key}`,
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({
                                "model": modelName,
                                "messages": [ { "role": "user", "content": "hello" } ],
                                "max_tokens": 2, "stream": false
                            }),
                            signal: controller.signal
                        });
                        clearTimeout(timeoutId);
                        console.log("[Test] æš–æœºè¯·æ±‚å®Œæˆã€‚");
                    }
                    catch (error) { console.warn("æš–æœºè¯·æ±‚å¤±è´¥:", error.message); }
                    await new Promise(resolve => setTimeout(resolve, 800)); // æš–æœºåé¢å¤–ç­‰å¾…
                }


                const measurementPromises = [];

                for (let i = 0; i < concurrency; i++) {
                    //  ä¼ å…¥seedç¡®ä¿æ¯ä¸ªå¹¶å‘è¯·æ±‚çš„promptéƒ½ä¸åŒï¼Œé¿å…prefix cacheå‘½ä¸­
                    const prompt = generatePrompt(length, 'openai', i + 1);
                    const requestBody = {
                        "model": modelName,
                        "messages": [
                            { "role": "user", "content": prompt }
                        ],
                        "max_tokens": outputLength,
                        "temperature": temperature,
                        "top_p": top_p,
                        "presence_penalty": presence_penalty,
                        "frequency_penalty": frequency_penalty,
                        "stream": true
                    };

                    const fetchOptions = {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${api_key}`,
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(requestBody)
                    };

                    measurementPromises.push(
                        executeAndMeasureRequest(apiUrl, fetchOptions, timeout, length)
                    );
                }

                try {
                    const results = await Promise.allSettled(measurementPromises);

                    const concurrencyResults = [];
                    let failedMessages = [];

                    for (const result of results) {
                        if (result.status === 'fulfilled') {
                            concurrencyResults.push(result.value);
                        } else {
                            failedMessages.push(result.reason.message);
                        }
                    }

                    //
                    const avgPrefillTimeMs = concurrencyResults.reduce((sum, res) => sum + res.prefillTimeMs, 0) / concurrencyResults.length;
                    const avgOutputTokens = concurrencyResults.reduce((sum, res) => sum + res.outputTokens, 0) / concurrencyResults.length;
                    const avgOutputTimeMs = concurrencyResults.reduce((sum, res) => sum + res.outputTimeMs, 0) / concurrencyResults.length;

                    //  è·å–å®é™…çš„prompt tokenæ•°ï¼ˆAPIè¿”å›çš„å‡†ç¡®å€¼ï¼‰
                    // é˜²å¾¡æ€§ç¼–ç¨‹ï¼šå¤„ç†undefinedçš„æƒ…å†µ
                    const avgActualPromptTokens = concurrencyResults.reduce((sum, res) => {
                        const tokens = res.actualPromptTokens ?? length; // fallbackåˆ°é¢„æœŸé•¿åº¦
                        return sum + tokens;
                    }, 0) / concurrencyResults.length;

                    // è®¡ç®—æ€»åå
                    const totalPrefillSpeed = concurrencyResults.reduce((sum, res) => sum + res.prefillSpeed, 0);
                    const totalOutputSpeed = concurrencyResults.reduce((sum, res) => sum + res.outputSpeed, 0);

                    // ä»…åœ¨æˆåŠŸæ—¶æ›´æ–°ç»Ÿè®¡
                    updateConcurrencyStats(totalPrefillSpeed, totalOutputSpeed);

                    //  æ˜¾ç¤ºé¢„æœŸvså®é™…çš„tokenæ•°å·®å¼‚
                    const actualPromptLength = Math.round(avgActualPromptTokens);
                    if (actualPromptLength !== length) {
                        const diff = actualPromptLength - length;
                        const diffPercent = ((diff / length) * 100).toFixed(1);
                        console.log(`[Tokenå·®å¼‚] é¢„æœŸ: ${length}, å®é™…: ${actualPromptLength}, å·®å¼‚: ${diff > 0 ? '+' : ''}${diff} (${diffPercent}%)`);
                    }

                    resultEntry = {
                        promptLength: actualPromptLength, //  ä¿®å¤ï¼šä½¿ç”¨å®é™…tokenæ•°
                        prefillTimeMs: avgPrefillTimeMs.toFixed(2),
                        prefillSpeed: totalPrefillSpeed.toFixed(2),
                        outputTokens: avgOutputTokens.toFixed(0),
                        outputTimeMs: avgOutputTimeMs.toFixed(2),
                        outputSpeed: totalOutputSpeed.toFixed(2),
                        status: 'æˆåŠŸ',
                        concurrency: concurrency
                    };

                    cells[0].textContent = resultEntry.promptLength; //  æ›´æ–°ä¸ºå®é™…tokenæ•°
                    cells[1].textContent = resultEntry.prefillTimeMs;
                    cells[2].textContent = resultEntry.prefillSpeed;
                    cells[3].textContent = resultEntry.outputTokens;
                    cells[4].textContent = resultEntry.outputTimeMs;
                    cells[5].textContent = resultEntry.outputSpeed;
                    // æ˜¾ç¤ºéƒ¨åˆ†æˆåŠŸ
                    cells[6].textContent = `${concurrencyResults.length}/${concurrency}å¹¶å‘æˆåŠŸ`;
                    row.classList.remove('info');
                    row.classList.add('success');

                } catch (error) {
                    // F12æ§åˆ¶å°é”™è¯¯æ—¥å¿—
                    console.error(`[Test] æç¤ºè¯é•¿åº¦ ${length} æµ‹è¯•å¤±è´¥:`, error);
                    resultEntry.status = `å¤±è´¥ (${error.message})`;
                    cells[1].textContent = 'N/A';
                    cells[2].textContent = 'N/A';
                    cells[3].textContent = 'N/A';
                    cells[4].textContent = 'N/A';
                    cells[5].textContent = 'N/A';
                    cells[6].textContent = resultEntry.status;
                    row.classList.remove('info');
                    row.classList.add('error');
                }

                testResultsData.push(resultEntry); // æ— è®ºæˆåŠŸå¤±è´¥éƒ½æ¨å…¥ï¼Œä»¥ä¾¿å›¾è¡¨æ˜¾ç¤ºæ–­ç‚¹
                generateCharts(); // å®æ—¶æ›´æ–°å›¾è¡¨
                completedTests++;
                progressBar.style.width = `${(completedTests / totalTests) * 100}%`;
                resultsDiv.scrollTop = resultsDiv.scrollHeight;

                // å¢åŠ æµ‹è¯•é—´çš„å»¶è¿Ÿ
                console.log(`[Test] é•¿åº¦ ${length} æµ‹è¯•å®Œæˆã€‚ç­‰å¾… 1.5 ç§’...`);
                await new Promise(resolve => setTimeout(resolve, 1500));
            }
        }

        async function executeAndMeasureRequest(apiUrl, fetchOptions, timeout, promptLength) {

            const startTime = performance.now();
            let firstTokenTime = null;
            let outputContent = '';
            let reasoningContent = ''; //  å•ç‹¬ç»Ÿè®¡reasoningå†…å®¹
            let actualOutputTokensFromUsage = null; //  ä»usageè·å–çš„è¾“å‡ºtokenæ•°ï¼ˆæ”¯æŒæ€è€ƒæ¨¡å‹ï¼‰
            let actualPromptTokensFromUsage = null; //  ä»usageè·å–çš„å®é™…prompt tokenæ•°
            let reasoningChunkCount = 0; //  ç»Ÿè®¡reasoning chunkæ•°é‡ï¼ˆç”¨äºfallbackï¼‰
            let contentChunkCount = 0;   //  ç»Ÿè®¡content chunkæ•°é‡ï¼ˆç”¨äºfallbackï¼‰
            let serverPrefillTimeMs = null; //  æœåŠ¡å™¨è¿”å›çš„prefillçœŸå®å¤„ç†æ—¶é—´
            let serverDecodeTimeMs = null;  //  æœåŠ¡å™¨è¿”å›çš„decodeçœŸå®å¤„ç†æ—¶é—´

            const response = await createFetchPromiseWithRetry(apiUrl, fetchOptions, timeout, 3, 1500);

            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`HTTPé”™è¯¯! çŠ¶æ€: ${response.status}. å“åº”: ${errorText}`);
            }

            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            let reading = true;

            while (reading) {
                const { value, done } = await reader.read();
                if (done) {
                    reading = false;
                    break;
                }

                const chunk = decoder.decode(value, { stream: true });
                const lines = chunk.split('\n').filter(line => line.trim() !== '');

                for (const line of lines) {
                    if (line.startsWith('data: ') && !line.includes('[DONE]')) {
                        const jsonLine = line.replace('data: ', '');
                        try {
                            const data = JSON.parse(jsonLine);

                            //  è§£æusageå­—æ®µï¼ˆæµå¼å“åº”çš„æœ€åä¸€ä¸ªchunkä¼šåŒ…å«ï¼‰
                            if (data.usage) {
                                const completion = data.usage.completion_tokens || 0;
                                const reasoning = data.usage.reasoning_tokens || 0;
                                const prompt = data.usage.prompt_tokens || 0;

                                // æ€»decodeåå = æ€è€ƒtokens + ç­”æ¡ˆtokens
                                actualOutputTokensFromUsage = completion + reasoning;
                                actualPromptTokensFromUsage = prompt;

                                console.log(`[Tokenç»Ÿè®¡] prompt: ${prompt}, completion: ${completion}, reasoning: ${reasoning}, è¾“å‡ºæ€»è®¡: ${actualOutputTokensFromUsage}`);

                                //  å°è¯•æå–æœåŠ¡å™¨çš„çœŸå®å¤„ç†æ—¶é—´ï¼ˆllama.cppæ‰©å±•å­—æ®µï¼‰
                                // å¯èƒ½çš„å­—æ®µåï¼štimings, prompt_eval_duration, eval_durationç­‰
                                if (data.usage.prompt_eval_duration) {
                                    // llama.cppæ ¼å¼ï¼šçº³ç§’
                                    serverPrefillTimeMs = data.usage.prompt_eval_duration / 1_000_000;
                                } else if (data.usage.prompt_eval_time) {
                                    // å¯èƒ½æ˜¯æ¯«ç§’
                                    serverPrefillTimeMs = data.usage.prompt_eval_time;
                                }

                                if (data.usage.eval_duration) {
                                    // llama.cppæ ¼å¼ï¼šçº³ç§’
                                    serverDecodeTimeMs = data.usage.eval_duration / 1_000_000;
                                } else if (data.usage.eval_time) {
                                    // å¯èƒ½æ˜¯æ¯«ç§’
                                    serverDecodeTimeMs = data.usage.eval_time;
                                }

                                if (serverPrefillTimeMs && serverDecodeTimeMs) {
                                    console.log(`[æœåŠ¡å™¨Timing] Prefill: ${serverPrefillTimeMs.toFixed(2)}ms, Decode: ${serverDecodeTimeMs.toFixed(2)}ms`);
                                }
                            }

                            //  æ£€æŸ¥é¡¶å±‚çš„timingså­—æ®µï¼ˆæŸäº›å®ç°å¯èƒ½æ”¾åœ¨è¿™é‡Œï¼‰
                            if (data.timings) {
                                // å°è¯•å¤šç§å­—æ®µå
                                if (!serverPrefillTimeMs) {
                                    if (data.timings.prompt_eval_duration) {
                                        serverPrefillTimeMs = data.timings.prompt_eval_duration / 1_000_000; // çº³ç§’è½¬æ¯«ç§’
                                    } else if (data.timings.prompt_ms) {
                                        serverPrefillTimeMs = data.timings.prompt_ms; // å·²ç»æ˜¯æ¯«ç§’
                                    }
                                }

                                if (!serverDecodeTimeMs) {
                                    if (data.timings.eval_duration) {
                                        serverDecodeTimeMs = data.timings.eval_duration / 1_000_000; // çº³ç§’è½¬æ¯«ç§’
                                    } else if (data.timings.predicted_ms) {
                                        serverDecodeTimeMs = data.timings.predicted_ms; // å·²ç»æ˜¯æ¯«ç§’
                                    }
                                }

                                if (serverPrefillTimeMs && serverDecodeTimeMs) {
                                    console.log(`[æœåŠ¡å™¨Timing] Prefill: ${serverPrefillTimeMs.toFixed(2)}ms, Decode: ${serverDecodeTimeMs.toFixed(2)}ms (æ¥è‡ªtimingså­—æ®µ)`);
                                }
                            }

                            //  é€šç”¨fallbackï¼šæ‰“å°å®Œæ•´çš„dataç»“æ„ï¼ˆä»…åœ¨æœ€åä¸€ä¸ªchunkï¼Œä¸”æ˜¯é¦–æ¬¡æ‰“å°ï¼‰
                            if (data.usage && !window._debugDataPrinted) {
                                console.log('[è°ƒè¯•] æ”¶åˆ°usageå­—æ®µ:', JSON.stringify(data.usage, null, 2));
                                if (data.timings) {
                                    console.log('[è°ƒè¯•] æ”¶åˆ°timingså­—æ®µ:', JSON.stringify(data.timings, null, 2));
                                }
                                if (!serverPrefillTimeMs) {
                                    console.log('[è­¦å‘Š] æœªèƒ½æå–æœåŠ¡å™¨timingï¼Œä½¿ç”¨ç«¯åˆ°ç«¯æµ‹é‡ï¼ˆå«ç½‘ç»œå»¶è¿Ÿï¼‰');
                                }
                                window._debugDataPrinted = true;
                            }

                            // æ£€æŸ¥å¤šç§å¯èƒ½çš„contentä½ç½®
                            let contentText = null;
                            let isReasoningToken = false;

                            if (data.choices && data.choices[0]) {
                                const choice = data.choices[0];

                                //  æ€è€ƒæ¨¡å‹æ ¼å¼ï¼šdelta.reasoning_contentï¼ˆæ€è€ƒè¿‡ç¨‹ï¼‰
                                if (choice.delta && choice.delta.reasoning_content) {
                                    contentText = choice.delta.reasoning_content;
                                    isReasoningToken = true;
                                    reasoningChunkCount++;
                                }
                                // æ ‡å‡†OpenAIæµå¼æ ¼å¼ï¼šdelta.contentï¼ˆç­”æ¡ˆæˆ–å…¨éƒ¨å†…å®¹ï¼‰
                                else if (choice.delta && choice.delta.content) {
                                    contentText = choice.delta.content;
                                    contentChunkCount++;
                                }
                                // æŸäº›å®ç°ï¼šmessage.content
                                else if (choice.message && choice.message.content) {
                                    contentText = choice.message.content;
                                    contentChunkCount++;
                                }
                                // æŸäº›å®ç°ï¼štextå­—æ®µ
                                else if (choice.text) {
                                    contentText = choice.text;
                                    contentChunkCount++;
                                }
                            }

                            if (contentText) {
                                if (isReasoningToken) {
                                    reasoningContent += contentText;
                                } else {
                                    outputContent += contentText;
                                }

                                if (!firstTokenTime) {
                                    firstTokenTime = performance.now();
                                    const tokenType = isReasoningToken ? 'reasoning' : 'content';
                                    console.log(`[TTFT] é¦–tokenåˆ°è¾¾ï¼ˆ${tokenType}ï¼‰ï¼Œå†…å®¹: "${contentText.substring(0, 20)}..."`);
                                }
                            }
                        } catch (e) {
                            console.error('è§£æé”™è¯¯:', e, jsonLine);
                        }
                    }
                }
            }

            const endTime = performance.now();

            try {
                if (!firstTokenTime) {
                    const hasContent = (reasoningContent + outputContent).length > 0;
                    if (!hasContent) {
                       throw new Error("æœªæ”¶åˆ°ä»»ä½•token (stream ended)");
                    }
                    firstTokenTime = endTime;
                }

                //  ä¼˜å…ˆä½¿ç”¨usageä¸­çš„å‡†ç¡®tokenæ•°ï¼Œå¦‚æœæ²¡æœ‰åˆ™ä¼°ç®—/ä½¿ç”¨ä¼ å…¥å€¼
                const actualPromptTokens = actualPromptTokensFromUsage ?? promptLength; // Prefillç”¨APIè¿”å›çš„å®é™…å€¼

                //  Tokenç»Ÿè®¡ï¼šä¼˜å…ˆä½¿ç”¨usageä¸­çš„å‡†ç¡®å€¼
                let receivedTokens;

                if (actualOutputTokensFromUsage && actualOutputTokensFromUsage > 0) {
                    // ä¼˜å…ˆä½¿ç”¨APIè¿”å›çš„usage
                    receivedTokens = actualOutputTokensFromUsage;
                } else if (reasoningContent.length > 0 || outputContent.length > 0) {
                    // Fallback: ä¼°ç®—
                    const reasoningTokens = estimateTokenCount(reasoningContent);
                    const completionTokens = estimateTokenCount(outputContent);
                    receivedTokens = reasoningTokens + completionTokens;
                    console.log(`[Tokenä¼°ç®—] reasoning: ${reasoningTokens}, completion: ${completionTokens}, æ€»è®¡: ${receivedTokens}`);
                } else {
                    receivedTokens = 0;
                }

                //  è®¡ç®—æ—¶é—´ï¼šä¼˜å…ˆä½¿ç”¨æœåŠ¡å™¨çœŸå®å¤„ç†æ—¶é—´ï¼Œå¦åˆ™ä½¿ç”¨ç«¯åˆ°ç«¯æµ‹é‡
                let prefillTimeMs, outputTimeMs;
                let timeSource = '';

                if (serverPrefillTimeMs && serverDecodeTimeMs) {
                    // ä½¿ç”¨æœåŠ¡å™¨è¿”å›çš„çœŸå®GPUå¤„ç†æ—¶é—´
                    prefillTimeMs = serverPrefillTimeMs;
                    outputTimeMs = serverDecodeTimeMs;
                    timeSource = 'æœåŠ¡å™¨çœŸå®å¤„ç†æ—¶é—´';
                } else {
                    // Fallback: ä½¿ç”¨ç«¯åˆ°ç«¯æµ‹é‡ï¼ˆåŒ…å«ç½‘ç»œå»¶è¿Ÿï¼‰
                    prefillTimeMs = firstTokenTime - startTime;
                    outputTimeMs = Math.max(endTime - firstTokenTime, 1);
                    timeSource = 'ç«¯åˆ°ç«¯æµ‹é‡ï¼ˆå«ç½‘ç»œå»¶è¿Ÿï¼‰';
                }

                const prefillSpeed = (actualPromptTokens / (prefillTimeMs / 1000));
                const outputSpeed = receivedTokens > 0 ? (receivedTokens / (outputTimeMs / 1000)) : 0;

                console.log(`[é€Ÿåº¦ç»Ÿè®¡] æ—¶é—´æ¥æº: ${timeSource}`);
                console.log(`[é€Ÿåº¦ç»Ÿè®¡] Prefill: ${prefillSpeed.toFixed(2)} tok/s (${prefillTimeMs.toFixed(2)}ms), Decode: ${outputSpeed.toFixed(2)} tok/s (${outputTimeMs.toFixed(2)}ms, ${receivedTokens} tokens)`);

                return {
                    prefillTimeMs,
                    prefillSpeed,
                    outputTokens: receivedTokens,
                    outputTimeMs,
                    outputSpeed,
                    actualPromptTokens  //  è¿”å›å®é™…çš„prompt tokenæ•°
                };
            } catch (error) {
                console.error(`[Error] executeAndMeasureRequestå¼‚å¸¸:`, error);
                throw error; // é‡æ–°æŠ›å‡º
            }
        }

        function updateConcurrencyStats(prefillSpeed, outputSpeed) {

            concurrencyStats.minPrefillSpeed = Math.min(concurrencyStats.minPrefillSpeed, prefillSpeed);
            concurrencyStats.maxPrefillSpeed = Math.max(concurrencyStats.maxPrefillSpeed, prefillSpeed);
            concurrencyStats.minOutputSpeed = Math.min(concurrencyStats.minOutputSpeed, outputSpeed);
            concurrencyStats.maxOutputSpeed = Math.max(concurrencyStats.maxOutputSpeed, outputSpeed);

            // é‡æ–°ä» testResultsData è®¡ç®—å¹³å‡å€¼ï¼Œç¡®ä¿å‡†ç¡®æ€§
            const allPrefillSpeeds = testResultsData
                .filter(r => r.status === 'æˆåŠŸ' && r.prefillSpeed !== 'N/A')
                .map(r => parseFloat(r.prefillSpeed));
            if (prefillSpeed) allPrefillSpeeds.push(prefillSpeed); // åŒ…æ‹¬å½“å‰æ‰¹æ¬¡çš„

            const allOutputSpeeds = testResultsData
                .filter(r => r.status === 'æˆåŠŸ' && r.outputSpeed !== 'N/A')
                .map(r => parseFloat(r.outputSpeed));
            if (outputSpeed) allOutputSpeeds.push(outputSpeed); // åŒ…æ‹¬å½“å‰æ‰¹æ¬¡çš„

            if (allPrefillSpeeds.length > 0) {
                concurrencyStats.avgPrefillSpeed = allPrefillSpeeds.reduce((sum, speed) => sum + speed, 0) / allPrefillSpeeds.length;
            }
             if (allOutputSpeeds.length > 0) {
                concurrencyStats.avgOutputSpeed = allOutputSpeeds.reduce((sum, speed) => sum + speed, 0) / allOutputSpeeds.length;
            }
        }

        function showConcurrencyStats() {

            const statsDiv = document.createElement('div');
            statsDiv.className = 'concurrent-stats';

            // ç¡®ä¿æ˜¾ç¤ºçš„å€¼ä¸æ˜¯Infinity
            const minP = isFinite(concurrencyStats.minPrefillSpeed) ? concurrencyStats.minPrefillSpeed.toFixed(2) : 'N/A';
            const maxP = isFinite(concurrencyStats.maxPrefillSpeed) && concurrencyStats.maxPrefillSpeed > 0 ? concurrencyStats.maxPrefillSpeed.toFixed(2) : 'N/A';
            const minO = isFinite(concurrencyStats.minOutputSpeed) ? concurrencyStats.minOutputSpeed.toFixed(2) : 'N/A';
            const maxO = isFinite(concurrencyStats.maxOutputSpeed) && concurrencyStats.maxOutputSpeed > 0 ? concurrencyStats.maxOutputSpeed.toFixed(2) : 'N/A';
            const avgP = isFinite(concurrencyStats.avgPrefillSpeed) && concurrencyStats.avgPrefillSpeed > 0 ? concurrencyStats.avgPrefillSpeed.toFixed(2) : 'N/A';
            const avgO = isFinite(concurrencyStats.avgOutputSpeed) && concurrencyStats.avgOutputSpeed > 0 ? concurrencyStats.avgOutputSpeed.toFixed(2) : 'N/A';


            const t = translations[currentLang];
            statsDiv.innerHTML = `
                <h3>${t.concurrentStatsTitle} (${document.getElementById('concurrency').value} ${t.concurrentLabel})</h3>
                <div class="stat-item">
                    <span>${t.statTotalPrefillRange}</span>
                    <span class="stat-value">${minP} - ${maxP} tokens/s</span>
                </div>
                <div class="stat-item">
                    <span>${t.statTotalDecodeRange}</span>
                    <span class="stat-value">${minO} - ${maxO} tokens/s</span>
                </div>
                <div class="stat-item">
                    <span>${t.statAvgPrefill}</span>
                    <span class="stat-value">${avgP} tokens/s</span>
                </div>
                <div class="stat-item">
                    <span>${t.statAvgDecode}</span>
                    <span class="stat-value">${avgO} tokens/s</span>
                </div>
            `;
            resultsDiv.appendChild(statsDiv);
        }

        // ã€ä¿®å¤ã€‘æµ‹è¯•Ollamaæ¥å£
        async function testOllama(apiUrl, modelName, minLength, maxLength, step, outputLength, temperature, top_p, presence_penalty, frequency_penalty, concurrency, timeout) {
             for (let length = minLength; length <= maxLength; length += step) {
                if (!isTestingRunning) break;

                // F12æ§åˆ¶å°æ—¥å¿—
                console.log(`[Test] å‡†å¤‡æµ‹è¯•æç¤ºè¯é•¿åº¦: ${length}`);

                const row = document.createElement('tr');
                resultsDiv.querySelector('tbody').appendChild(row);
                const cells = [];
                for (let i = 0; i < 7; i++) {
                    const cell = document.createElement('td');
                    cells.push(cell);
                    row.appendChild(cell);
                }

                cells[0].textContent = length;
                cells[1].textContent = "æµ‹è¯•ä¸­...";
                cells[2].textContent = "æµ‹è¯•ä¸­...";
                cells[3].textContent = "æµ‹è¯•ä¸­...";
                cells[4].textContent = "æµ‹è¯•ä¸­...";
                cells[5].textContent = "æµ‹è¯•ä¸­...";
                cells[6].textContent = `${concurrency}å¹¶å‘æµ‹è¯•ä¸­...`;
                row.classList.add('info');
                resultsDiv.scrollTop = resultsDiv.scrollHeight;

                let resultEntry = {
                    promptLength: length,
                    prefillTimeMs: 'N/A',
                    prefillSpeed: 'N/A',
                    outputTokens: 'N/A',
                    outputTimeMs: 'N/A',
                    outputSpeed: 'N/A',
                    status: 'å¤±è´¥',
                    concurrency: concurrency
                };

                // æš–æœº
                if (length == minLength) {
                    try {
                        console.log("[Test] å‘é€æš–æœºè¯·æ±‚...");
                        const controller = new AbortController();
                        const timeoutId = setTimeout(() => controller.abort(), 5000);
                        await fetch(apiUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json', },
                            body: JSON.stringify({
                                "model": modelName,
                                "messages": [ { "role": "user", "content": "hello" } ],
                                "options": { "num_predict": 2 }, "stream": false
                            }),
                            signal: controller.signal
                        });
                        clearTimeout(timeoutId);
                        console.log("[Test] æš–æœºè¯·æ±‚å®Œæˆã€‚");
                    }
                    catch (error) { console.warn("æš–æœºè¯·æ±‚å¤±è´¥:", error.message); }
                    await new Promise(resolve => setTimeout(resolve, 800));
                }

                const requests = [];

                for (let i = 0; i < concurrency; i++) {
                    const prompt = generatePrompt(length, 'ollama', i + 1);
                    const requestBody = {
                        "model": modelName,
                        "messages": [
                            { "role": "user", "content": prompt }
                        ],
                        "options": {
                            "num_predict": outputLength,
                            "num_ctx": maxLength, // Ollama é€šå¸¸ç”¨ num_ctx é™åˆ¶ä¸Šä¸‹æ–‡
                            "temperature": temperature,
                            "top_p": top_p,
                            "repeat_penalty": 1.1 // åˆå¹¶ presence å’Œ frequency (Ollama ä¸åŒºåˆ†)
                        },
                        "stream": false
                    };

                    // ä½¿ç”¨å¸¦é‡è¯•çš„ fetch
                    const fetchOptions = {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(requestBody)
                    };

                    const fetchPromise = createFetchPromiseWithRetry(apiUrl, fetchOptions, timeout, 3, 1500);
                    requests.push(fetchPromise);
                }

                try {
                    const responses = await Promise.allSettled(requests);
                    const processPromises = [];
                    let failedMessages = [];

                    for (const result of responses) {
                        if (result.status === 'fulfilled' && result.value.ok) {
                            processPromises.push(processOllamaResponse(result.value, length));
                        } else {
                            if (result.status === 'rejected') {
                                failedMessages.push(result.reason.message);
                            } else {
                                failedMessages.push(`HTTP ${result.value.status}`);
                            }
                        }
                    }

                    // (v1.8 bug fix) ç­‰å¾…æ‰€æœ‰æˆåŠŸçš„å“åº”è¢«å¤„ç†
                    const concurrencyResults = [];
                    const processedResponses = await Promise.allSettled(processPromises);

                    for (const result of processedResponses) {
                        if (result.status === 'fulfilled') {
                            concurrencyResults.push(result.value);
                        } else {
                            failedMessages.push(result.reason.message);
                        }
                    }

                    if (concurrencyResults.length === 0) {
                         throw new Error(`æ‰€æœ‰å¹¶å‘è¯·æ±‚å¤±è´¥: ${failedMessages.join(', ')}`);
                    }

                    const avgPrefillTimeMs = concurrencyResults.reduce((sum, res) => sum + res.prefillTimeMs, 0) / concurrencyResults.length;
                    const avgOutputTokens = concurrencyResults.reduce((sum, res) => sum + res.outputTokens, 0) / concurrencyResults.length;
                    const avgOutputTimeMs = concurrencyResults.reduce((sum, res) => sum + res.outputTimeMs, 0) / concurrencyResults.length;

                    //  è·å–å®é™…çš„prompt tokenæ•°ï¼ˆOllama APIè¿”å›çš„å‡†ç¡®å€¼ï¼‰
                    // é˜²å¾¡æ€§ç¼–ç¨‹ï¼šå¤„ç†undefinedçš„æƒ…å†µ
                    const avgActualPromptTokens = concurrencyResults.reduce((sum, res) => {
                        const tokens = res.actualPromptTokens ?? length; // fallbackåˆ°é¢„æœŸé•¿åº¦
                        return sum + tokens;
                    }, 0) / concurrencyResults.length;

                    //
                    const totalPrefillSpeed = concurrencyResults.reduce((sum, res) => sum + res.prefillSpeed, 0);
                    const totalOutputSpeed = concurrencyResults.reduce((sum, res) => sum + res.outputSpeed, 0);

                    updateConcurrencyStats(totalPrefillSpeed, totalOutputSpeed);

                    //  æ˜¾ç¤ºé¢„æœŸvså®é™…çš„tokenæ•°å·®å¼‚
                    const actualPromptLength = Math.round(avgActualPromptTokens);
                    if (actualPromptLength !== length) {
                        const diff = actualPromptLength - length;
                        const diffPercent = ((diff / length) * 100).toFixed(1);
                        console.log(`[Ollama Tokenå·®å¼‚] é¢„æœŸ: ${length}, å®é™…: ${actualPromptLength}, å·®å¼‚: ${diff > 0 ? '+' : ''}${diff} (${diffPercent}%)`);
                    }

                    resultEntry = {
                        promptLength: actualPromptLength, //  ä¿®å¤ï¼šä½¿ç”¨å®é™…tokenæ•°
                        prefillTimeMs: avgPrefillTimeMs.toFixed(2),
                        prefillSpeed: totalPrefillSpeed.toFixed(2),
                        outputTokens: avgOutputTokens.toFixed(0),
                        outputTimeMs: avgOutputTimeMs.toFixed(2),
                        outputSpeed: totalOutputSpeed.toFixed(2),
                        status: 'æˆåŠŸ',
                        concurrency: concurrency
                    };

                    cells[0].textContent = resultEntry.promptLength; //  æ›´æ–°ä¸ºå®é™…tokenæ•°
                    cells[1].textContent = resultEntry.prefillTimeMs;
                    cells[2].textContent = resultEntry.prefillSpeed;
                    cells[3].textContent = resultEntry.outputTokens;
                    cells[4].textContent = resultEntry.outputTimeMs;
                    cells[5].textContent = resultEntry.outputSpeed;
                    cells[6].textContent = `${concurrencyResults.length}/${concurrency}å¹¶å‘æˆåŠŸ`;
                    row.classList.remove('info');
                    row.classList.add('success');

                } catch (error) {
                    // F12æ§åˆ¶å°é”™è¯¯æ—¥å¿—
                    console.error(`[Test] æç¤ºè¯é•¿åº¦ ${length} æµ‹è¯•å¤±è´¥:`, error);
                    resultEntry.status = `å¤±è´¥ (${error.message})`;
                    cells[1].textContent = 'N/A';
                    cells[2].textContent = 'N/A';
                    cells[3].textContent = 'N/A';
                    cells[4].textContent = 'N/A';
                    cells[5].textContent = 'N/A';
                    cells[6].textContent = resultEntry.status;
                    row.classList.remove('info');
                    row.classList.add('error');
                }

                testResultsData.push(resultEntry);
                generateCharts(); // å®æ—¶æ›´æ–°å›¾è¡¨
                completedTests++;
                progressBar.style.width = `${(completedTests / totalTests) * 100}%`;
                resultsDiv.scrollTop = resultsDiv.scrollHeight;

                // å¢åŠ æµ‹è¯•é—´çš„å»¶è¿Ÿ
                console.log(`[Test] é•¿åº¦ ${length} æµ‹è¯•å®Œæˆã€‚ç­‰å¾… 1.5 ç§’...`);
                await new Promise(resolve => setTimeout(resolve, 1500));
            }
        }

        async function processOllamaResponse(response, promptLength) {

            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`HTTP é”™è¯¯! çŠ¶æ€: ${response.status}. å“åº”: ${errorText}`);
            }

            const data = await response.json();

            if (data.error) {
                throw new Error(`Ollama é”™è¯¯: ${data.error}`);
            }

            if (!data.prompt_eval_duration || !data.eval_duration) {
                throw new Error("Ollama å“åº”ä¸­ç¼ºå°‘*durationå­—æ®µ");
            }

            // prompt_eval_duration å’Œ eval_duration æ˜¯çº³ç§’ (ns)
            const prefillDurationMs = data.prompt_eval_duration / 1_000_000;

            //  Ollamaçš„eval_countå·²ç»åŒ…å«æ‰€æœ‰è¾“å‡ºtokenï¼ˆå¦‚æœæ˜¯æ€è€ƒæ¨¡å‹ï¼ŒåŒ…æ‹¬æ€è€ƒ+ç­”æ¡ˆï¼‰
            // æ³¨æ„ï¼šOllamaç›®å‰æ²¡æœ‰å•ç‹¬çš„reasoning_tokenså­—æ®µï¼Œä½†eval_countæ˜¯å‡†ç¡®çš„æ€»æ•°
            const actualOutputTokens = data.eval_count;
            const outputDurationMs = Math.max(data.eval_duration / 1_000_000, 1); // ns to ms, æœ€å° 1ms

            //  Ollamaè¿”å›çš„å®é™…prompt tokenæ•°
            const actualPromptTokens = data.prompt_eval_count || promptLength;

            console.log(`[Ollama Tokenç»Ÿè®¡] prompt_eval_count: ${actualPromptTokens}, eval_count: ${actualOutputTokens}, prompt_eval_duration: ${data.prompt_eval_duration}ns`);

            //  ä¿®å¤ï¼šä½¿ç”¨å®é™…çš„prompt tokenæ•°
            const prefillSpeed = (actualPromptTokens / (prefillDurationMs / 1000));
            const outputSpeed = actualOutputTokens > 0 ? (actualOutputTokens / (outputDurationMs / 1000)) : 0;

            return {
                prefillTimeMs: prefillDurationMs,
                prefillSpeed: prefillSpeed,
                outputTokens: actualOutputTokens,
                outputTimeMs: outputDurationMs,
                outputSpeed: outputSpeed,
                actualPromptTokens: actualPromptTokens  //  è¿”å›å®é™…çš„prompt tokenæ•°
            };
        }

        startTestBtn.addEventListener('click', async () => {
            // v1.8: éšè—å¯¹æ¯”å›¾è¡¨å¹¶æ¸…ç©ºæ•°æ®
            document.getElementById('comparisonChartContainer').style.display = 'none';
            exportComparisonChartBtn.style.display = 'none'; // v1.8
            if (comparisonPrefillChartInstance) comparisonPrefillChartInstance.destroy();
            if (comparisonOutputChartInstance) comparisonOutputChartInstance.destroy();
            comparisonPrefillChartInstance = null;
            comparisonOutputChartInstance = null;
            comparisonData = [];
            importFilesInput.value = ""; // æ¸…ç©ºæ–‡ä»¶é€‰æ‹©

            currentApiType = document.querySelector('.api-option.active').dataset.type;
            const apiUrl = document.getElementById('apiUrl').value.trim();
            currentModelName = document.getElementById('modelName').value.trim();
            api_key = document.getElementById('apiKey').value.trim();
            notes = document.getElementById('notes').value.trim() || `æ— ç”¨æˆ·å¤‡æ³¨ï¼Œæ¥å£: ${currentApiType === 'openai' ? 'OpenAIå…¼å®¹æ¥å£' : 'Ollamaæ¥å£'} ï¼Œæ¨¡å‹: ${currentModelName}`;
            const minLength = parseInt(document.getElementById('minLength').value, 10);
            const maxLength = parseInt(document.getElementById('maxLength').value, 10);
            const step = parseInt(document.getElementById('step').value, 10);
            const outputLength = parseInt(document.getElementById('outputLength').value, 10);
            const concurrency = parseInt(document.getElementById('concurrency').value, 10) || 1;
            const timeout = parseInt(document.getElementById('timeout').value, 10);
            const temperature = parseFloat(document.getElementById('temperatureInput').value);
            const top_p = parseFloat(document.getElementById('topPInput').value);
            const presence_penalty = parseFloat(document.getElementById('presencePenaltyInput').value);
            const frequency_penalty = parseFloat(document.getElementById('frequencyPenaltyInput').value);

            //  ä¿å­˜å½“å‰é…ç½®åˆ° localStorageï¼ˆæ‰©å±•ä¿å­˜æ‰€æœ‰å‚æ•°ï¼‰
            try {
                localStorage.setItem('llmPerfTestApiUrl', apiUrl);
                localStorage.setItem('llmPerfTestModelName', currentModelName);
                localStorage.setItem('llmPerfTestApiType', currentApiType);
                localStorage.setItem('llmPerfTestApiKey', api_key);
                localStorage.setItem('llmPerfTestNotes', notes);
                localStorage.setItem('llmPerfTestMinLength', minLength);
                localStorage.setItem('llmPerfTestMaxLength', maxLength);
                localStorage.setItem('llmPerfTestStep', step);
                localStorage.setItem('llmPerfTestOutputLength', outputLength);
                localStorage.setItem('llmPerfTestConcurrency', concurrency);
                localStorage.setItem('llmPerfTestTimeout', timeout);
                localStorage.setItem('llmPerfTestTemperature', temperature);
                localStorage.setItem('llmPerfTestTopP', top_p);
                localStorage.setItem('llmPerfTestPresencePenalty', presence_penalty);
                localStorage.setItem('llmPerfTestFrequencyPenalty', frequency_penalty);
                console.log('[é…ç½®ä¿å­˜] å·²ä¿å­˜å½“å‰é…ç½®åˆ°localStorage');
            } catch (e) {
                console.warn("æ— æ³•ä¿å­˜é…ç½®åˆ° localStorage:", e);
            }

            // éªŒè¯è¾“å…¥
            if (!apiUrl || !currentModelName || !minLength || !maxLength || !step || !outputLength || !timeout) {
                alert("è¯·å¡«å†™æ‰€æœ‰å¿…å¡«çš„é…ç½®å‚æ•°ï¼");
                return;
            }

            totalTests = Math.floor((maxLength - minLength) / step) + 1;
            if (totalTests <= 0) {
                alert("æœ€å¤§é•¿åº¦å¿…é¡»å¤§äºæœ€å°é•¿åº¦ï¼Œæ­¥é•¿å¿…é¡»ä¸ºæ­£æ•°ã€‚");
                return;
            }
            completedTests = 0;

            concurrencyStats = {
                minPrefillSpeed: Infinity,
                maxPrefillSpeed: 0,
                minOutputSpeed: Infinity,
                maxOutputSpeed: 0,
                avgPrefillSpeed: 0,
                avgOutputSpeed: 0
            };

            startTestBtn.disabled = true;
            startTestBtn.textContent = "æµ‹è¯•ä¸­...";
            copyMarkdownBtn.style.display = 'none';
            exportCSVBtn.style.display = 'none';
            exportCombinedChartBtn.style.display = 'none'; // v1.8
            // chartContainer.style.display = 'none';
            progressBar.style.width = '0%';
            resultsDiv.innerHTML = "";
            testResultsData = [];

            // é”€æ¯æ—§å›¾è¡¨
            if (prefillChartInstance) prefillChartInstance.destroy();
            if (outputChartInstance) outputChartInstance.destroy();
            prefillChartInstance = null;
            outputChartInstance = null;

            const notesMessage = document.createElement('p');
            notesMessage.className = 'notes';
            notesMessage.textContent = `å¤‡æ³¨ï¼š${notes} | å¹¶å‘æ•°: ${concurrency} | è¶…æ—¶: ${timeout/1000}s`;
            resultsDiv.appendChild(notesMessage);

            const table = document.createElement('table');
            const thead = document.createElement('thead');
            const tbody = document.createElement('tbody');
            table.appendChild(thead);
            table.appendChild(tbody);
            resultsDiv.appendChild(table);

            const headerRow = document.createElement('tr');
            const t = translations[currentLang];
            [
                t.tableHeaderPromptLen,
                t.tableHeaderPrefillTime,
                t.tableHeaderPrefillSpeed,
                t.tableHeaderOutputLen,
                t.tableHeaderOutputTime,
                t.tableHeaderOutputSpeed,
                t.tableHeaderStatus
            ].forEach(text => {
                const th = document.createElement('th');
                th.innerHTML = text;
                headerRow.appendChild(th);
            });
            thead.appendChild(headerRow);
            chartContainer.style.display = 'block';

            stopTestBtn.disabled = false;
            stopTestBtn.textContent = translations[currentLang].btnTextStop;
            stopTestBtn.style.display = 'block';
            isTestingRunning = true;

            stopTestBtn.onclick = () => {
                isTestingRunning = false;
                stopTestBtn.disabled = true;
                stopTestBtn.textContent = "åœæ­¢ä¸­...";
            };

            try {
                if (currentApiType === 'openai') {
                    await testOpenAI(apiUrl, currentModelName, minLength, maxLength, step, outputLength, temperature, top_p, presence_penalty, frequency_penalty, concurrency, timeout);
                } else {
                    await testOllama(apiUrl, currentModelName, minLength, maxLength, step, outputLength, temperature, top_p, presence_penalty, frequency_penalty, concurrency, timeout);
                }
            } catch (e) {
                console.error('æµ‹è¯•è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯:', e);
                const errorRow = document.createElement('tr');
                errorRow.innerHTML = `<td colspan="7" class="error">æµ‹è¯•æ„å¤–ç»ˆæ­¢: ${e.message}</td>`;
                resultsDiv.querySelector('tbody').appendChild(errorRow);
            }

            //
            const wasManuallyStopped = !isTestingRunning;

            // æ— è®ºæµ‹è¯•æ˜¯å®Œæˆè¿˜æ˜¯è¢«æ‰‹åŠ¨åœæ­¢ï¼Œåªè¦æœ‰æ•°æ®å°±æ˜¾ç¤ºç»Ÿè®¡
            if (testResultsData.some(r => r.status === 'æˆåŠŸ')) {
                showConcurrencyStats();
                // generateCharts(); //
            }

            // æ ¹æ®æµ‹è¯•æ˜¯å¦è¢«æ‰‹åŠ¨åœæ­¢æ¥æ˜¾ç¤ºä¸åŒçš„æœ€ç»ˆæ¶ˆæ¯
            if (wasManuallyStopped) {
                 const stopRow = document.createElement('tr');
                stopRow.innerHTML = `<td colspan="7" class="info">æµ‹è¯•å·²æ‰‹åŠ¨åœæ­¢ã€‚</td>`;
                resultsDiv.querySelector('tbody').appendChild(stopRow);
            } else if (!testResultsData.some(r => r.status === 'æˆåŠŸ')) {
                 const noDataRow = document.createElement('tr');
                noDataRow.innerHTML = `<td colspan="7" class="info">æµ‹è¯•å®Œæˆï¼Œä½†æ²¡æœ‰æ”¶é›†åˆ°æˆåŠŸçš„æ•°æ®ã€‚</td>`;
                resultsDiv.querySelector('tbody').appendChild(noDataRow);
            }

            isTestingRunning = false; //

            // ç”ŸæˆMarkdownè¡¨æ ¼
            const apiTypeText = currentApiType === 'openai' ? t.apiOpenAI : t.apiOllama;
            let markdownTable = `## ${t.mdTestResults} (${apiTypeText} - ${currentModelName})\n\n`;
            markdownTable += `${t.mdNotes}${notes} | ${t.mdConcurrency} ${concurrency}\n\n`;
            markdownTable += `| ${t.tableHeaderPromptLen.replace('<br>', ' ')} | ${t.tableHeaderPrefillTime.replace('<br>', ' ')} | ${t.tableHeaderPrefillSpeed.replace('<br>', ' ')} | ${t.tableHeaderOutputLen.replace('<br>', ' ')} | ${t.tableHeaderOutputTime.replace('<br>', ' ')} | ${t.tableHeaderOutputSpeed.replace('<br>', ' ')} |\n`;
            markdownTable += `|---------------------|-------------------|-------------------------|-------------------|---------------|---------------------|\n`;

            testResultsData.forEach(res => {
                // Markdown ä¸­ä¹Ÿæ˜¾ç¤º N/A
                markdownTable += `| ${res.promptLength} | ${res.prefillTimeMs} | ${res.prefillSpeed} | ${res.outputTokens} | ${res.outputTimeMs} | ${res.outputSpeed} |\n`;
            });
            markdownOutputHidden.value = markdownTable;

            startTestBtn.disabled = false;
            startTestBtn.textContent = translations[currentLang].btnTextStart;
            copyMarkdownBtn.style.display = 'block';
            exportCSVBtn.style.display = 'block';
            exportCombinedChartBtn.style.display = 'block'; // v1.8
            stopTestBtn.style.display = 'none';
        });

        copyMarkdownBtn.addEventListener('click', () => {

            markdownOutputHidden.select();
            document.execCommand('copy');
            alert(translations[currentLang].alertMarkdownCopied);
        });

        exportCSVBtn.addEventListener('click', () => {
            const t = translations[currentLang];
            const apiTypeText = currentApiType === 'openai' ? t.apiOpenAI : t.apiOllama;
            let csvContent = "data:text/csv;charset=utf-8,";
            csvContent += `${apiTypeText}, ${currentModelName}\n`;
            csvContent += `${t.mdNotes}, "${notes.replace(/"/g, '""')}"\n`; // å¤„ç†å¤‡æ³¨ä¸­çš„å¼•å·
            const concurrencyValue = document.getElementById('concurrency').value; // è·å–å¹¶å‘æ•°
            csvContent += `${t.csvConcurrency}, ${concurrencyValue}\n`;
            csvContent += t.csvHeaders + "\n";
            testResultsData.forEach(res => {
                csvContent += `${res.promptLength},${res.prefillTimeMs},${res.prefillSpeed},${res.outputTokens},${res.outputTimeMs},${res.outputSpeed},"${res.status.replace(/"/g, '""')}"\n`;
            });
            const encodedUri = encodeURI(csvContent);
            const link = document.createElement("a");
            link.setAttribute("href", encodedUri);

            // è·å–å¤‡æ³¨ï¼ˆå¯èƒ½éœ€è¦å¯¹ç‰¹æ®Šå­—ç¬¦è¿›è¡Œå¤„ç†ï¼Œç¡®ä¿æ–‡ä»¶åå…¼å®¹æ€§ï¼‰
            const cleanNotes = notes // å‡è®¾notesæ˜¯åŒ…å«å¤‡æ³¨çš„å˜é‡
                .replace(/[\s\t\n\r]+/g, '_') // å°†ç©ºæ ¼å’Œæ¢è¡Œç¬¦æ›¿æ¢ä¸ºä¸‹åˆ’çº¿
                .replace(/[^a-zA-Z0-9_\-\.]/g, '') // ç§»é™¤å…¶ä»–éå­—æ¯æ•°å­—ä¸‹åˆ’çº¿è¿æ¥ç¬¦ç‚¹å·çš„å­—ç¬¦
                .substring(0, 30); // é™åˆ¶æ–‡ä»¶åä¸­çš„å¤‡æ³¨é•¿åº¦ï¼Œé˜²æ­¢è¿‡é•¿

            // æ„å»ºæ–°çš„æ–‡ä»¶å
            const filename = `${currentModelName}_${cleanNotes}_concurrency_${concurrencyValue}.csv`;
            // --- é‡ç‚¹ä¿®æ”¹éƒ¨åˆ†ç»“æŸ ---

            link.setAttribute("download", filename);
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        });


        // ===============================================================================
        // v1.8: æ–°å¢åŠŸèƒ½ï¼šå›¾è¡¨å¯¼å‡ºå’Œç»“æœå¯¹æ¯” (é‡æ„)
        // ===============================================================================

        /**
         * v1.8: å°†ä¸¤ä¸ª canvas åˆå¹¶å¹¶ä¸‹è½½ä¸ºä¸€å¼ å›¾ç‰‡
         * @param {HTMLCanvasElement} canvas1 - é¡¶éƒ¨å›¾è¡¨
         * @param {HTMLCanvasElement} canvas2 - åº•éƒ¨å›¾è¡¨
         * @param {string} filename - ä¸‹è½½çš„æ–‡ä»¶å
         * @param {string} title - (å¯é€‰) åœ¨å›¾è¡¨é¡¶éƒ¨æ·»åŠ çš„
         */
        function downloadCombinedChart(canvas1, canvas2, filename, title = null) {
            if (!canvas1 || !canvas2) {
                alert("å›¾è¡¨å°šæœªç”Ÿæˆï¼");
                return;
            }

            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');

            const padding = 20; // å›¾è¡¨é—´çš„é—´è·
            const titleHeight = title ? 60 : 0; // ä¸ºé¡¶éƒ¨å¤§æ ‡é¢˜ç•™å‡ºç©ºé—´

            // è®¾ç½®ç”»å¸ƒå°ºå¯¸
            tempCanvas.width = Math.max(canvas1.width, canvas2.width);
            tempCanvas.height = canvas1.height + canvas2.height + padding + titleHeight;

            // 1. å¡«å……ç™½è‰²èƒŒæ™¯
            tempCtx.fillStyle = '#FFFFFF';
            tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);

            // 2. (å¯é€‰) ç»˜åˆ¶å¤§æ ‡é¢˜
            if (title) {
                tempCtx.fillStyle = '#333333';
                tempCtx.font = 'bold 24px sans-serif';
                tempCtx.textAlign = 'center';
                tempCtx.fillText(title, tempCanvas.width / 2, 40);
            }

            // 3. ç»˜åˆ¶ç¬¬ä¸€ä¸ªå›¾è¡¨ (Chart.jsçš„å›¾è¡¨æ ‡é¢˜æ˜¯canvasçš„ä¸€éƒ¨åˆ†,æ‰€ä»¥ä¼šä¸€èµ·ç»˜åˆ¶)
            tempCtx.drawImage(canvas1, 0, titleHeight);

            // 4. ç»˜åˆ¶ç¬¬äºŒä¸ªå›¾è¡¨
            tempCtx.drawImage(canvas2, 0, titleHeight + canvas1.height + padding);

            // 5. è§¦å‘ä¸‹è½½
            const link = document.createElement('a');
            link.href = tempCanvas.toDataURL('image/png');
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        // v1.8: ç›‘å¬åˆå¹¶å¯¼å‡ºæŒ‰é’®
        exportCombinedChartBtn.addEventListener('click', () => {
            const modelName = currentModelName.replace(/[\/\\]/g, '_'); // æ¸…ç†æ–‡ä»¶å
            downloadCombinedChart(
                prefillChartCanvas,
                outputChartCanvas,
                `Perf_Chart_${modelName}.png`,
                `æ€§èƒ½æµ‹è¯•å›¾è¡¨ - ${currentModelName}` // å¤§æ ‡é¢˜
            );
        });

        // v1.8: ç›‘å¬å¯¹æ¯”å›¾è¡¨å¯¼å‡ºæŒ‰é’®
        exportComparisonChartBtn.addEventListener('click', () => {
            if (comparisonData.length === 0) {
                alert("æ²¡æœ‰å¯¹æ¯”æ•°æ®å¯å¯¼å‡ºã€‚");
                return;
            }
            // v1.8: ä» comparisonData åŠ¨æ€ç”Ÿæˆæ–‡ä»¶å
            const labels = comparisonData.map(d =>
                d.label.replace(/ã€.*?ã€‘/g, '') // ç§»é™¤ã€å¯¼å…¥ã€‘
                       .replace(/[\s\(\),]/g, '_') // æ›¿æ¢éæ³•å­—ç¬¦
                       .replace(/_+/g, '_') // ç§»é™¤è¿ç»­çš„ä¸‹åˆ’çº¿
            );
            // é™åˆ¶æ–‡ä»¶åé•¿åº¦ï¼Œé˜²æ­¢è¿‡é•¿
            const filename = `Comparison_${labels.join('_vs_').slice(0, 100)}.png`;

            downloadCombinedChart(
                document.getElementById('comparisonPrefillChart'),
                document.getElementById('comparisonOutputChart'),
                filename,
                "æ€§èƒ½å¯¹æ¯”å›¾è¡¨" // å¤§æ ‡é¢˜
            );
        });


        // 2. ç»“æœå¯¹æ¯”åŠŸèƒ½
        startComparisonBtn.addEventListener('click', async () => {
            const files = importFilesInput.files;
            comparisonData = []; // é‡ç½®å¯¹æ¯”æ•°æ®

            // 1. æ·»åŠ å½“å‰æµ‹è¯•æ•°æ® (å¦‚æœå­˜åœ¨)
            if (testResultsData.length > 0) {
                const currentConcurrency = document.getElementById('concurrency').value;
                // v1.8: ä¿®æ”¹å½“å‰æµ‹è¯•çš„æ ‡ç­¾
                const label = `ã€å½“å‰æµ‹è¯•ã€‘${currentModelName} (å¹¶å‘ ${currentConcurrency})`;
                comparisonData.push(formatDataForComparison(testResultsData, label));
            } else {
                alert(translations[currentLang].alertNoTestResults);
                // å³ä½¿æ²¡æœ‰å½“å‰æ•°æ®ï¼Œä¹Ÿç»§ç»­å¤„ç†å¯¼å…¥çš„æ•°æ®
            }

            // 2. æ·»åŠ å¯¼å…¥çš„CSVæ–‡ä»¶æ•°æ®
            for (const file of files) {
                try {
                    const fileContent = await file.text();
                    const parsedData = parseImportedCSV(fileContent);

                    // v1.8: ä½¿ç”¨æ–‡ä»¶åä½œä¸ºæ ‡ç­¾
                    const fileName = file.name.replace(/.csv$/i, ''); // ç§»é™¤.csv
                    const label = `ã€å¯¼å…¥ã€‘${fileName}`;

                    comparisonData.push(formatDataForComparison(parsedData.results, label));
                } catch (error) {
                    console.error(`è§£ææ–‡ä»¶ ${file.name} å¤±è´¥:`, error);
                    alert(`è§£ææ–‡ä»¶ ${file.name} å¤±è´¥: ${error.message}`);
                }
            }

            // 3. ç”Ÿæˆå¯¹æ¯”å›¾è¡¨
            if (comparisonData.length > 0) {
                generateComparisonCharts();
            } else if (testResultsData.length === 0) {
                // ä»…åœ¨æ—¢æ²¡æœ‰å½“å‰æ•°æ® *ä¹Ÿ* æ²¡æœ‰å¯¼å…¥æ•°æ®æ—¶æ‰æ˜¾ç¤ºæ­¤æ¶ˆæ¯
                alert("æ²¡æœ‰å¯ç”¨äºå¯¹æ¯”çš„æ•°æ®ã€‚");
            }
        });

        /**
         * å°† testResultsData æ ¼å¼çš„æ•°æ®è½¬æ¢ä¸ºå¯¹æ¯”å›¾è¡¨æ‰€éœ€çš„å¯¹è±¡æ•°ç»„æ ¼å¼
         * @param {Array} resultsArray - æ¥æºæ•°æ® (e.g., testResultsData)
         * @param {string} label - è¿™ä¸ªæ•°æ®é›†çš„å›¾ä¾‹æ ‡ç­¾
         * @returns {object} - { label, prefillData: [{x, y}], outputData: [{x, y}] }
         */
        function formatDataForComparison(resultsArray, label) {
            const data = {
                label: label,
                prefillData: [], // {x: promptLength, y: speed}
                outputData: []   // {x: promptLength, y: speed}
            };

            for (const res of resultsArray) {
                const promptLength = parseFloat(res.promptLength);
                const prefillSpeed = res.prefillSpeed === 'N/A' ? null : parseFloat(res.prefillSpeed);
                const outputSpeed = res.outputSpeed === 'N/A' ? null : parseFloat(res.outputSpeed);

                if (!isNaN(promptLength)) {
                    if (prefillSpeed !== null) {
                        data.prefillData.push({ x: promptLength, y: prefillSpeed });
                    }
                    if (outputSpeed !== null) {
                        data.outputData.push({ x: promptLength, y: outputSpeed });
                    }
                }
            }
            // æŒ‰ x (promptLength) æ’åºä»¥ç¡®ä¿çº¿æ¡æ­£ç¡®ç»˜åˆ¶
            data.prefillData.sort((a, b) => a.x - b.x);
            data.outputData.sort((a, b) => a.x - b.x);

            return data;
        }

        /**
         * è§£æå¯¼å…¥çš„CSVæ–‡ä»¶å†…å®¹
         * @param {string} csvContent - CSVæ–‡ä»¶æ–‡æœ¬å†…å®¹
         * @returns {object} - { modelName, notes, concurrency, results }
         */
        function parseImportedCSV(csvContent) {
            // v1.8 bug fix: åŒæ—¶å¤„ç† \n å’Œ \r\n æ¢è¡Œ
            const lines = csvContent.trim().split(/\r?\n/);
            if (lines.length < 5) throw new Error("CSVæ–‡ä»¶æ ¼å¼ä¸æ­£ç¡®ï¼Œè¡Œæ•°ä¸è¶³ã€‚");

            // ç§»é™¤\r (å†æ¬¡ç¡®ä¿)
            const cleanLines = lines.map(line => line.replace(/\r$/, ''));

            const modelName = cleanLines[0].split(',')[1]?.trim() || 'æœªçŸ¥æ¨¡å‹';
            const notes = (cleanLines[1].split(',"')[1] || '').replace(/"$/, '') || 'æ— å¤‡æ³¨';
            const concurrency = cleanLines[2].split(',')[1]?.trim() || '1';

            const headerLine = cleanLines[3];
            const headers = headerLine.split(',').map(h => h.trim());

            // æŸ¥æ‰¾åˆ—ç´¢å¼•
            const lenIdx = headers.indexOf("æç¤ºè¯é•¿åº¦(tokens)");
            const prefillSpdIdx = headers.indexOf("é¢„å¡«å……é€Ÿåº¦(tokens/s)");
            const outputSpdIdx = headers.indexOf("è¾“å‡ºé€Ÿåº¦(tokens/s)");

            if (lenIdx === -1 || prefillSpdIdx === -1 || outputSpdIdx === -1) {
                throw new Error("CSVæ–‡ä»¶ç¼ºå°‘å¿…è¦çš„åˆ— (æç¤ºè¯é•¿åº¦, é¢„å¡«å……é€Ÿåº¦, è¾“å‡ºé€Ÿåº¦)");
            }

            const results = [];
            for (let i = 4; i < cleanLines.length; i++) {
                if (cleanLines[i].trim() === "") continue;
                const values = cleanLines[i].split(',');

                if (values.length > Math.max(lenIdx, prefillSpdIdx, outputSpdIdx)) {
                    results.push({
                        promptLength: values[lenIdx],
                        prefillSpeed: values[prefillSpdIdx],
                        outputSpeed: values[outputSpdIdx],
                        prefillTimeMs: 'N/A',
                        outputTokens: 'N/A',
                        outputTimeMs: 'N/A',
                        status: 'N/A'
                    });
                }
            }

            return { modelName, notes, concurrency, results };
        }

        /**
         * ç”Ÿæˆå¯¹æ¯”å›¾è¡¨
         */
        function generateComparisonCharts() {
            const comparisonChartContainer = document.getElementById('comparisonChartContainer');
            const compPrefillCanvas = document.getElementById('comparisonPrefillChart').getContext('2d');
            const compOutputCanvas = document.getElementById('comparisonOutputChart').getContext('2d');

            if (comparisonData.length === 0) {
                comparisonChartContainer.style.display = 'none';
                return;
            }

            comparisonChartContainer.style.display = 'block';

            // å®šä¹‰ä¸€ç»„é¢œè‰²
            const colors = [
                '#E41A1C', '#377EB8', '#4DAF4A', '#984EA3', '#FF7F00', '#FFFF33',
                '#A65628', '#F781BF', '#999999', '#1B9E77', '#D95F02', '#7570B3'
            ];

            // 1. åˆ›å»º Prefill å¯¹æ¯”å›¾è¡¨
            const prefillDatasets = comparisonData.map((dataset, index) => {
                return {
                    label: dataset.label, // v1.8: æ ‡ç­¾å·²åœ¨è°ƒç”¨æ—¶æ ¼å¼åŒ–
                    data: dataset.prefillData,
                    borderColor: colors[index % colors.length],
                    backgroundColor: colors[index % colors.length] + '33', // 20% é€æ˜åº¦
                    tension: 0.1,
                    spanGaps: false, // åœ¨ null æ•°æ®ç‚¹å¤„æ–­å¼€
                    fill: false // çº¿æ¡ä¸å¡«å……
                };
            });

            const t = translations[currentLang];
            if (comparisonPrefillChartInstance) comparisonPrefillChartInstance.destroy();
            comparisonPrefillChartInstance = new Chart(compPrefillCanvas, {
                type: 'line',
                data: { datasets: prefillDatasets },
                options: {
                    responsive: true,
                    plugins: {
                        legend: { position: 'top' },
                        title: { display: true, text: t.chartComparisonPrefillThroughput }
                    },
                    scales: {
                        x: {
                            type: 'linear', // Xè½´ä½¿ç”¨çº¿æ€§åˆ»åº¦
                            position: 'bottom',
                            title: { display: true, text: t.chartAxisPromptLen }
                        },
                        y: {
                            title: { display: true, text: t.chartAxisThroughput },
                            beginAtZero: true
                        }
                    }
                }
            });

            // 2. åˆ›å»º Output å¯¹æ¯”å›¾è¡¨
            const outputDatasets = comparisonData.map((dataset, index) => {
                return {
                    label: dataset.label,
                    data: dataset.outputData,
                    borderColor: colors[index % colors.length],
                    backgroundColor: colors[index % colors.length] + '33',
                    tension: 0.1,
                    spanGaps: false,
                    fill: false
                };
            });

            if (comparisonOutputChartInstance) comparisonOutputChartInstance.destroy();
            comparisonOutputChartInstance = new Chart(compOutputCanvas, {
                type: 'line',
                data: { datasets: outputDatasets },
                options: {
                    responsive: true,
                    plugins: {
                        legend: { position: 'top' },
                        title: { display: true, text: t.chartComparisonDecodeThroughput }
                    },
                    scales: {
                        x: {
                            type: 'linear',
                            position: 'bottom',
                            title: { display: true, text: t.chartAxisPromptLen }
                        },
                        y: {
                            title: { display: true, text: t.chartAxisThroughput },
                            beginAtZero: true
                        }
                    }
                }
            });

            // v1.8: æ˜¾ç¤ºå¯¹æ¯”å›¾è¡¨å¯¼å‡ºæŒ‰é’®
            exportComparisonChartBtn.style.display = 'block';
        }


        // ===============================================================================
        // åŸæœ‰å›¾è¡¨ç”Ÿæˆ
        // ===============================================================================

        // ç”Ÿæˆå›¾è¡¨ (ç°åœ¨æ˜¯ä¸¤å¼ å›¾)
        function generateCharts() {
            if (testResultsData.length === 0) {
                //
                if (prefillChartInstance) prefillChartInstance.clear();
                if (outputChartInstance) outputChartInstance.clear();
                return;
            }

            const t = translations[currentLang];
            // ä»æ•°æ®ä¸­æå–æ ‡ç­¾å’Œæ•°æ®é›†
            const labels = testResultsData.map(d => d.promptLength);
            // å°† 'N/A' è½¬æ¢ä¸º nullï¼Œä»¥ä¾¿ Chart.js çŸ¥é“åœ¨ä½•å¤„æ–­å¼€çº¿æ¡
            const prefillDataTotal = testResultsData.map(d => d.prefillSpeed === 'N/A' ? null : parseFloat(d.prefillSpeed));
            const outputDataTotal = testResultsData.map(d => d.outputSpeed === 'N/A' ? null : parseFloat(d.outputSpeed));

            chartContainer.style.display = 'block';

            // é”€æ¯æ—§å›¾è¡¨
            if (prefillChartInstance) {
                prefillChartInstance.data.labels = labels;
                prefillChartInstance.data.datasets[0].data = prefillDataTotal;
                prefillChartInstance.update('none');
            } else {
                // å›¾è¡¨1: é¢„å¡«å……é€Ÿåº¦
                const prefillCtx = prefillChartCanvas.getContext('2d');
                prefillChartInstance = new Chart(prefillCtx, {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: [
                            {
                                label: t.chartLabelPrefillThroughput,
                                data: prefillDataTotal,
                                borderColor: 'rgb(75, 192, 192)',
                                backgroundColor: 'rgba(75, 192, 192, 0.2)',
                                tension: 0.1,
                                fill: true,
                                spanGaps: false // åœ¨ null æ•°æ®ç‚¹å¤„æ–­å¼€
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        plugins: {
                            legend: {
                                position: 'top',
                            },
                            title: {
                                display: true,
                                text: `${t.chartTitlePrefillThroughput} - ${currentModelName}`
                            }
                        },
                        scales: {
                            x: {
                                title: {
                                    display: true,
                                    text: t.chartAxisPromptLen
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: t.chartAxisThroughput
                                },
                                beginAtZero: true
                            }
                        }
                    }
                });
            }

            // å›¾è¡¨2: è¾“å‡ºé€Ÿåº¦
            if (outputChartInstance) {
                outputChartInstance.data.labels = labels;
                outputChartInstance.data.datasets[0].data = outputDataTotal;
                outputChartInstance.update('none');
            } else {
                const outputCtx = outputChartCanvas.getContext('2d');
                outputChartInstance = new Chart(outputCtx, {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: [
                            {
                                label: t.chartLabelDecodeThroughput,
                                data: outputDataTotal,
                                borderColor: 'rgb(255, 99, 132)',
                                backgroundColor: 'rgba(255, 99, 132, 0.2)',
                                tension: 0.1,
                                fill: true,
                                spanGaps: false // åœ¨ null æ•°æ®ç‚¹å¤„æ–­å¼€
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        plugins: {
                            legend: {
                                position: 'top',
                            },
                            title: {
                                display: true,
                                text: `${t.chartTitleDecodeThroughput} - ${currentModelName}`
                            }
                        },
                        scales: {
                            x: {
                                title: {
                                    display: true,
                                    text: t.chartAxisPromptLen
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: t.chartAxisThroughput
                                },
                                beginAtZero: true
                            }
                        }
                    }
                });
            }
        }

        //  ä»localStorageåŠ è½½ä¸Šæ¬¡ä¿å­˜çš„é…ç½®
        function setDefaultValues() {
            // ä» localStorage åŠ è½½ä¿å­˜çš„ API ç±»å‹ã€åœ°å€å’Œæ¨¡å‹åç§°
            const savedApiType = localStorage.getItem('llmPerfTestApiType') || 'openai';
            const savedApiUrl = localStorage.getItem('llmPerfTestApiUrl');
            const savedModelName = localStorage.getItem('llmPerfTestModelName');
            const savedApiKey = localStorage.getItem('llmPerfTestApiKey');
            const savedNotes = localStorage.getItem('llmPerfTestNotes');
            const savedMinLength = localStorage.getItem('llmPerfTestMinLength');
            const savedMaxLength = localStorage.getItem('llmPerfTestMaxLength');
            const savedStep = localStorage.getItem('llmPerfTestStep');
            const savedOutputLength = localStorage.getItem('llmPerfTestOutputLength');
            const savedConcurrency = localStorage.getItem('llmPerfTestConcurrency');
            const savedTimeout = localStorage.getItem('llmPerfTestTimeout');
            const savedTemperature = localStorage.getItem('llmPerfTestTemperature');
            const savedTopP = localStorage.getItem('llmPerfTestTopP');
            const savedPresencePenalty = localStorage.getItem('llmPerfTestPresencePenalty');
            const savedFrequencyPenalty = localStorage.getItem('llmPerfTestFrequencyPenalty');

            // è®¾ç½® API ç±»å‹çš„ active çŠ¶æ€
            apiOptions.forEach(o => o.classList.remove('active'));
            const activeOption = document.querySelector(`.api-option[data-type="${savedApiType}"]`);
            if (activeOption) {
                activeOption.classList.add('active');
            }
            updateApiDescription(savedApiType);

            // å¦‚æœ localStorage æœ‰æ•°æ®åˆ™ä½¿ç”¨ï¼Œå¦åˆ™ä½¿ç”¨é»˜è®¤æ•°æ®
            document.getElementById('apiUrl').value = savedApiUrl || ((savedApiType === 'openai') ? d_openai_apiUrl : d_ollama_apiUrl);
            document.getElementById('modelName').value = savedModelName || ((savedApiType === 'openai') ? d_openai_modelName : d_ollama_modelName);
            document.getElementById('apiKey').value = savedApiKey || d_api_key;
            document.getElementById('notes').value = savedNotes || '';
            document.getElementById('minLength').value = savedMinLength || d_minLength;
            document.getElementById('maxLength').value = savedMaxLength || d_maxLength;
            document.getElementById('step').value = savedStep || d_step;
            document.getElementById('outputLength').value = savedOutputLength || d_outputLength;
            document.getElementById('concurrency').value = savedConcurrency || 1;
            document.getElementById('timeout').value = savedTimeout || d_timeout;
            document.getElementById('temperatureInput').value = savedTemperature || d_temperature;
            document.getElementById('topPInput').value = savedTopP || d_top_p;
            document.getElementById('presencePenaltyInput').value = savedPresencePenalty || d_presence_penalty;
            document.getElementById('frequencyPenaltyInput').value = savedFrequencyPenalty || d_frequency_penalty;

            // æç¤ºç”¨æˆ·å·²åŠ è½½é…ç½®
            if (savedApiUrl) {
                console.log('[é…ç½®åŠ è½½] å·²ä»localStorageæ¢å¤ä¸Šæ¬¡çš„é…ç½®');
            }
        }

        // 
        window.onload = function () { setDefaultValues(); };
    </script>
</body>

</html>