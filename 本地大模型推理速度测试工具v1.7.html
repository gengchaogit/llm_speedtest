<!DOCTYPE html>
<html lang="zh-CN">
<!-- åŸä½œè€…ï¼šçº¸é¸¢éšé£ï¼ˆBç«™ï¼‰ã€DeepSeek-R1-0528-->
<!-- v1.7 (chaoåŸºäºåŸç‰ˆé­”æ”¹ç‰ˆ-qqç¾¤:1028429001):
    å¯ä»¥åœ¨ä¸‹é¢çš„githubåœ°å€è·å–æœ€æ–°ç‰ˆçš„æ›´æ–°
    https://github.com/gengchaogit/llm_speedtest
    1. ä¸ºæ¯ä¸ªè¯·æ±‚å¢åŠ 3æ¬¡é‡è¯•ï¼ˆé—´éš”1.5ç§’ï¼‰ï¼Œä»¥è¿‡æ»¤æ‰ç¬æ—¶/å¶å‘çš„æœåŠ¡å™¨å¤±è´¥ã€‚
    2. è‡ªåŠ¨æ˜¾ç¤ºå›¾è¡¨ï¼Œæ— éœ€ç‚¹å‡»
    3. å°† Prefill å’Œ Decode é€Ÿåº¦åˆ†ç¦»åˆ°ä¸¤å¼ å›¾è¡¨
    4. ä¿®å¤é«˜å¹¶å‘ä¸‹ Promise.all ç†”æ–­é—®é¢˜ (ä½¿ç”¨ Promise.allSettled)
    5. å¢åŠ  AbortController å®ç°çš„è¯·æ±‚è¶…æ—¶
    6. ä¿å­˜å½“å‰é…ç½®åˆ° localStorage
-->
<!-- æœ¬å·¥å…·é€šè¿‡æµè§ˆå™¨æœ¬åœ°ç¦»çº¿è¿è¡Œ -->

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æœ¬åœ°å¤§æ¨¡å‹æ¨ç†é€Ÿåº¦æµ‹è¯•å·¥å…· v1.7</title>
    <!-- å¼•å…¥ Chart.js ç”¨äºç»˜å›¾ -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
    <style>
        :root {
            --primary-color: #1a73e8;
            --success-color: #98c379;
            --error-color: #e06c75;
            --info-color: #61afef;
            --dark-bg: #282c34;
            --dark-row: #2f343a;
            --light-bg: #f4f7f9;
            --border-color: #e0e0e0;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background-color: var(--light-bg);
            color: #333;
            line-height: 1.6;
            padding: 20px;
            max-width: 1000px;
            margin: 0 auto;
        }

        .container {
            background: #fff;
            padding: 25px;
            border-radius: 8px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
            margin-bottom: 30px;
        }

        h1 {
            color: var(--primary-color);
            padding-bottom: 10px;
            margin-top: 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .api-selector {
            display: flex;
            margin-bottom: 20px;
            border-radius: 5px;
            overflow: hidden;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        .api-option {
            flex: 1;
            text-align: center;
            padding: 12px;
            background: #fff;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 1px solid var(--border-color);
        }

        .api-option:first-child {
            border-radius: 5px 0 0 5px;
        }

        .api-option:last-child {
            border-radius: 0 5px 5px 0;
        }

        .api-option.active {
            background-color: var(--primary-color);
            color: white;
            font-weight: bold;
            border-color: var(--primary-color);
        }

        .api-option:hover:not(.active) {
            background-color: #f0f7ff;
        }

        .config-section {
            margin-bottom: 20px;
        }

        h2 {
            color: #444;
            font-size: 1.2em;
            margin-bottom: 15px;
            padding-bottom: 5px;
            border-bottom: 1px dashed var(--border-color);
        }

        .form-row {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 15px;
        }

        .form-group {
            flex: 1;
            min-width: 200px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
        }

        .form-group input,
        .form-group select {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 1em;
        }

        button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 12px 20px;
            font-size: 1em;
            font-weight: 600;
            border-radius: 5px;
            cursor: pointer;
            transition: filter 0.1s, transform 0.1s;
            margin-top: 10px;
        }

        button:hover {
            filter: brightness(0.95);
        }

        button:active {
            transform: scale(0.98);
        }

        button:disabled {
            background-color: #a0a0a0 !important;
            cursor: not-allowed;
        }

        #results {
            background-color: var(--dark-bg);
            color: #abb2bf;
            padding: 15px;
            border-radius: 5px;
            min-height: 150px;
            margin-top: 20px;
            overflow-x: auto;
        }

        #results table {
            width: 100%;
            border-collapse: collapse;
            margin: 0;
            font-family: "Courier New", Courier, monospace;
            font-size: 0.9em;
            table-layout: fixed;
        }

        #results th,
        #results td {
            border: 1px solid #444;
            padding: 8px;
            text-align: left;
            color: #abb2bf;
            white-space: normal;
        }

        #results th {
            background-color: #333;
            color: #f8f8f2;
            position: sticky;
            top: 0;
            z-index: 1;
        }

        /* æç¤ºè¯é•¿åº¦ */
        #results th:nth-child(1),
        #results td:nth-child(1) {
            width: 14%;
        }

        /* é¢„å¡«å……è€—æ—¶ */
        #results th:nth-child(2),
        #results td:nth-child(2) {
            width: 16%;
        }

        /* é¢„å¡«å……é€Ÿåº¦ */
        #results th:nth-child(3),
        #results td:nth-child(3) {
            width: 14%;
        }

        /* è¾“å‡ºé•¿åº¦ */
        #results th:nth-child(4),
        #results td:nth-child(4) {
            width: 14%;
        }

        /* è¾“å‡ºè€—æ—¶ */
        #results th:nth-child(5),
        #results td:nth-child(5) {
            width: 16%;
        }

        /* è¾“å‡ºé€Ÿåº¦ */
        #results th:nth-child(6),
        #results td:nth-child(6) {
            width: 14%;
        }

        /* çŠ¶æ€ */
        #results th:nth-child(7),
        #results td:nth-child(7) {
            width: 12%;
        }

        #results tr:nth-child(even) {
            background-color: var(--dark-row);
        }

        .success {
            color: var(--success-color);
        }

        .error {
            color: var(--error-color);
        }

        .info {
            color: var(--info-color);
            padding: 5px 0;
            text-align: center;
        }

        .notes {
            color: var(--info-color);
            padding-bottom: 5px;
        }

        #markdownOutputHidden {
            position: absolute;
            left: -9999px;
            width: 1px;
            height: 1px;
            overflow: hidden;
            white-space: pre;
        }

        .progress-container {
            margin: 15px 0;
            background-color: #e0e0e0;
            border-radius: 5px;
            height: 10px;
            overflow: hidden;
        }

        .progress-bar {
            height: 100%;
            background-color: var(--primary-color);
            transition: width 0.3s ease;
        }

        .action-buttons {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .action-buttons button {
            flex: 1;
        }

        .api-description {
            margin-top: 10px;
            margin-bottom: 10px;
            padding: 15px;
            background-color: #f0f7ff;
            border-radius: 5px;
            border-left: 4px solid var(--primary-color);
        }

        .api-description h3 {
            color: var(--primary-color);
            margin-bottom: 10px;
        }

        .api-description ul {
            padding-left: 20px;
        }

        .api-description li {
            margin-bottom: 8px;
        }

        .logo {
            font-size: 24px;
        }

        .concurrent-stats {
            background-color: #2c3e50;
            padding: 10px;
            border-radius: 5px;
            margin-top: 15px;
            font-family: monospace;
        }

        .concurrent-stats h3 {
            color: #61afef;
            margin-bottom: 8px;
            font-size: 1.1em;
        }

        .concurrent-stats .stat-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }

        .concurrent-stats .stat-value {
            color: #98c379;
        }

        #chartContainer {
            margin-top: 30px;
            background: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
        }

        #chartContainer h3 {
             color: #333;
             margin-bottom: 10px;
             text-align: center;
        }

        #outputChart {
            margin-top: 25px;
        }

        @media (max-width: 768px) {
            .form-row {
                flex-direction: column;
                gap: 10px;
            }

            .action-buttons {
                flex-direction: column;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <h1><span class="logo">ğŸš€</span> å¤§æ¨¡å‹ Prefill & Decode æ€§èƒ½æµ‹è¯•å·¥å…· v1.7 (chaoé­”æ”¹ç‰ˆ-åŠ ç»˜å›¾ä¿®bug-è‡ªåŠ¨ä¿å­˜api)</h1>

        <div class="api-selector">
            <div class="api-option active" data-type="openai">OpenAIå…¼å®¹æ¥å£</div>
            <div class="api-option" data-type="ollama">Ollamaæ¥å£</div>
        </div>

        <div class="api-description" id="apiDescription">
            <h3>OpenAIå…¼å®¹æ¥å£æµ‹è¯•è¯´æ˜</h3>
            <ul>
                <li>ä½¿ç”¨æµå¼å“åº”(stream=true)æµ‹é‡é¦–å­—å»¶è¿Ÿ</li>
                <li>é¢„å¡«å……é€Ÿåº¦ = æç¤ºè¯é•¿åº¦ / (é¦–å­—åˆ°è¾¾æ—¶é—´ - è¯·æ±‚å¼€å§‹æ—¶é—´)</li>
                <li>è¾“å‡ºé€Ÿåº¦ = è¾“å‡ºtokenæ•° / (è¾“å‡ºå®Œæˆæ—¶é—´ - é¦–å­—åˆ°è¾¾æ—¶é—´)</li>
                <li>é€‚ç”¨äºæ‰€æœ‰å…¼å®¹OpenAI APIçš„å¤§æ¨¡å‹æœåŠ¡</li>
            </ul>
        </div>

        <div class="config-section">
            <h2>API ä¿¡æ¯</h2>
            <div class="form-row">
                <div class="form-group">
                    <label for="apiUrl">API åœ°å€</label>
                    <input type="text" id="apiUrl" value="">
                </div>
                <div class="form-group">
                    <label for="modelName">æ¨¡å‹åç§°</label>
                    <input type="text" id="modelName" value="">
                </div>
            </div>
            <div class="form-row">
                <div class="form-group">
                    <label for="apiKey">API-Key</label>
                    <input type="text" id="apiKey" value="" placeholder="æœªè®¾ç½® API-Key åˆ™ç•™ç©º">
                </div>
            </div>
            <div class="form-row">
                <div class="form-group">
                    <label for="notes">å¤‡æ³¨</label>
                    <input type="text" id="notes" value="" placeholder="è¯·å¡«å†™è®¾å¤‡ä¿¡æ¯ã€æ¨¡å‹ä¿¡æ¯ã€æ¨¡å‹æ¨ç†æ¡†æ¶ï¼Œä»¥ä¾¿åœ¨ç»“æœä¸­æ˜¾ç¤º">
                </div>
            </div>
        </div>

        <div class="config-section">
            <h2>æµ‹è¯•å‚æ•°é…ç½®</h2>
            <div class="form-row">
                <div class="form-group">
                    <label for="minLength">æœ€å°æç¤ºè¯é•¿åº¦</label>
                    <input type="number" id="minLength" value="" step="128">
                </div>
                <div class="form-group">
                    <label for="maxLength">æœ€å¤§æç¤ºè¯é•¿åº¦</label>
                    <input type="number" id="maxLength" value="" step="128">
                </div>
                <div class="form-group">
                    <label for="step">æ­¥é•¿</label>
                    <input type="number" id="step" value="" step="128">
                </div>
                <div class="form-group">
                    <label for="outputLength">æœŸæœ›è¾“å‡ºé•¿åº¦</label>
                    <input type="number" id="outputLength" value="" min="1">
                </div>
            </div>
            <div class="form-row">
                <div class="form-group">
                    <label for="concurrency">å¹¶å‘æ•°</label>
                    <input type="number" id="concurrency" value="1" min="1" max="50">
                </div>
                <div class="form-group">
                    <label for="timeout">è¯·æ±‚è¶…æ—¶ (ms)</label>
                    <input type="number" id="timeout" value="" min="1000" step="1000">
                </div>
                <div class="form-group">
                    <label for="temperatureInput">Temperature</label>
                    <input type="number" id="temperatureInput" value="" step="0.1" min="0" max="2">
                </div>
                <div class="form-group">
                    <label for="topPInput">Top P</label>
                    <input type="number" id="topPInput" value="" step="0.01" min="0" max="1">
                </div>
            </div>
            <div class="form-row">
                 <div class="form-group">
                    <label for="presencePenaltyInput">Presence Penalty</label>
                    <input type="number" id="presencePenaltyInput" value="" step="0.1" min="-2" max="2">
                </div>
                <div class="form-group">
                    <label for="frequencyPenaltyInput">Frequency Penalty</label>
                    <input type="number" id="frequencyPenaltyInput" value="" step="0.1" min="-2" max="2">
                </div>
            </div>
        </div>

        <h2>æ‰§è¡Œæµ‹è¯•</h2>
        <div class="action-buttons">
            <button id="startTest" style="background: #349bea;">å¼€å§‹æµ‹è¯•</button>
            <button id="stopTest" style="display: none; background: #E74C3C;">åœæ­¢æµ‹è¯•</button>
            <button id="copyMarkdown" style="display: none; background: #4CAF50;">å¤åˆ¶ Markdown è¡¨æ ¼</button>
            <button id="exportCSV" style="display: none; background: #4eb8a6;">å¯¼å‡º CSV æ•°æ®</button>
            <!-- â€œç”Ÿæˆå›¾è¡¨â€æŒ‰é’®å·²ç§»é™¤ï¼Œæ”¹ä¸ºè‡ªåŠ¨æ˜¾ç¤º -->
        </div>
        <div class="progress-container">
            <div id="progressBar" class="progress-bar" style="width: 0%"></div>
        </div>

        <div id="results">
            <p class="info">ç­‰å¾…å¼€å§‹æµ‹è¯•...</p>
        </div>

        <!-- ç»˜å›¾åŒºåŸŸï¼šåŒ…å«ä¸¤ä¸ª canvas -->
        <div id="chartContainer" style="display: none;">
            <h3>é¢„å¡«å…… (Prefill) åå</h3>
            <canvas id="prefillChart"></canvas>

            <h3 style="margin-top: 25px;">è¾“å‡º (Decode) åå</h3>
            <canvas id="outputChart"></canvas>
        </div>

        <textarea id="markdownOutputHidden"></textarea>
    </div>

    <script>
        // é»˜è®¤å‚æ•°è®¾ç½®
        // ===============================================================================
        // API ç«¯ç‚¹å’Œæ¨¡å‹åç§°é…ç½®
        let d_openai_apiUrl = 'http://10.0.0.50:8000/v1/chat/completions';          // OpenAI å…¼å®¹ API çš„ URL åœ°å€
        let d_openai_modelName = 'Qwen3-30B-A3B-Instruct-2507-Int4-W4A16';                                          // OpenAI å…¼å®¹ API æ‰€ä½¿ç”¨çš„æ¨¡å‹åç§°æˆ–è·¯å¾„
        let d_ollama_apiUrl = 'http://localhost:11434/api/chat';                    // Ollama API çš„ URL åœ°å€
        let d_ollama_modelName = 'Qwen3-32B-AWQ';                                      // Ollama API æ‰€ä½¿ç”¨çš„æ¨¡å‹åç§°
        let d_api_key = '';                                                         // è®¿é—® API æ‰€éœ€çš„è®¤è¯å¯†é’¥ï¼Œå¦‚æœä¸éœ€è¦åˆ™å¯ä»¥ç•™ç©º
        // æ–‡æœ¬ç”Ÿæˆé•¿åº¦æ§åˆ¶å‚æ•° (æ•´æ•°)
        let d_minLength = 512;                                                      // ç”Ÿæˆæ–‡æœ¬çš„æœ€å°é•¿åº¦ï¼ˆä¾‹å¦‚ï¼Œtoken æˆ–å­—ç¬¦æ•°ï¼‰
        let d_maxLength = 8192;                                                     // ç”Ÿæˆæ–‡æœ¬çš„æœ€å¤§é•¿åº¦ï¼ˆä¾‹å¦‚ï¼Œtoken æˆ–å­—ç¬¦æ•°ï¼‰
        let d_step = 512;                                                           // æ¯æ¬¡æç¤ºè¯é•¿åº¦å¢åŠ çš„æ­¥é•¿
        let d_outputLength = 128;                                                   // æœŸæœ›è¾“å‡ºçš„æ–‡æœ¬é•¿åº¦
        let d_timeout = 30000;                                                      // è¯·æ±‚è¶…æ—¶æ—¶é—´ (ms)
        // æ–‡æœ¬ç”Ÿæˆé‡‡æ ·å‚æ•° (æµ®ç‚¹æ•°)
        let d_temperature = 1.0;                                                    // æ§åˆ¶ç”Ÿæˆæ–‡æœ¬çš„éšæœºæ€§ã€‚å€¼è¶Šé«˜ï¼Œæ–‡æœ¬è¶Šéšæœºï¼ˆ0.0è¡¨ç¤ºç¡®å®šæ€§ï¼Œ1.0è¡¨ç¤ºè¾ƒé«˜éšæœºæ€§ï¼‰
        let d_top_p = 0.1;                                                          // æ§åˆ¶ç”Ÿæˆæ–‡æœ¬çš„å¤šæ ·æ€§ã€‚åªè€ƒè™‘ç´¯ç§¯æ¦‚ç‡è¾¾åˆ° top_p çš„è¯æ±‡ï¼ˆ0.0-1.0ï¼‰
        let d_presence_penalty = -1.0;                                              // å¯¹ç”Ÿæˆæ–‡æœ¬ä¸­å·²ç»å‡ºç°çš„è¯æ±‡è¿›è¡Œæƒ©ç½šï¼Œå‡å°‘é‡å¤ï¼ˆé€šå¸¸åœ¨ -2.0 åˆ° 2.0 ä¹‹é—´ï¼‰
        let d_frequency_penalty = -1.0;                                             // å¯¹ç”Ÿæˆæ–‡æœ¬ä¸­è¯æ±‡å‡ºç°çš„é¢‘ç‡è¿›è¡Œæƒ©ç½šï¼Œå‡å°‘å¸¸ç”¨è¯çš„é‡å¤ï¼ˆé€šå¸¸åœ¨ -2.0 åˆ° 2.0 ä¹‹é—´ï¼‰
        // ===============================================================================

        // APIç±»å‹åˆ‡æ¢
        const apiOptions = document.querySelectorAll('.api-option');
        const apiDescription = document.getElementById('apiDescription');

        apiOptions.forEach(option => {
            option.addEventListener('click', () => {
                apiOptions.forEach(o => o.classList.remove('active'));
                option.classList.add('active');

                const apiType = option.dataset.type;
                updateApiDescription(apiType);
                updateDefaultValues(apiType);
            });
        });

        function updateApiDescription(apiType) {
            if (apiType === 'openai') {
                apiDescription.innerHTML = `
                    <h3>OpenAIå…¼å®¹æ¥å£æµ‹è¯•è¯´æ˜</h3>
                    <ul>
                        <li>ä½¿ç”¨æµå¼å“åº”(stream=true)æµ‹é‡é¦–å­—å»¶è¿Ÿ</li>
                        <li>é¢„å¡«å……é€Ÿåº¦ = æç¤ºè¯é•¿åº¦ / (é¦–å­—åˆ°è¾¾æ—¶é—´ - è¯·æ±‚å¼€å§‹æ—¶é—´)</li>
                        <li>è¾“å‡ºé€Ÿåº¦ = è¾“å‡ºtokenæ•° / (è¾“å‡ºå®Œæˆæ—¶é—´ - é¦–å­—åˆ°è¾¾æ—¶é—´)</li>
                        <li>é€‚ç”¨äºæ‰€æœ‰å…¼å®¹OpenAI APIçš„å¤§æ¨¡å‹æœåŠ¡</li>
                    </ul>
                `;
            } else {
                apiDescription.innerHTML = `
                    <h3>Ollamaæ¥å£æµ‹è¯•è¯´æ˜</h3>
                    <ul>
                        <li>ä½¿ç”¨éæµå¼è¯·æ±‚(stream=false)</li>
                        <li>ç›´æ¥ä½¿ç”¨APIè¿”å›çš„prompt_eval_durationå’Œeval_durationæŒ‡æ ‡</li>
                        <li>é¢„å¡«å……é€Ÿåº¦ = æç¤ºè¯é•¿åº¦ / (prompt_eval_duration / 1000)</li>
                        <li>è¾“å‡ºé€Ÿåº¦ = è¾“å‡ºtokenæ•° / (eval_duration / 1000)</li>
                    </ul>
                `;
            }
        }

        function updateDefaultValues(apiType) {
            const apiUrl = document.getElementById('apiUrl');
            const modelName = document.getElementById('modelName');

            if (apiType === 'openai') {
                apiUrl.value = d_openai_apiUrl;
                modelName.value = d_openai_modelName;
            } else {
                apiUrl.value = d_ollama_apiUrl;
                modelName.value = d_ollama_modelName;
            }
        }

        // åˆå§‹åŒ–
        updateApiDescription('openai');

        // å•è¯åº“ç”¨äºç”Ÿæˆæç¤ºè¯
        const wordList = [
            "active", "project", "quality", "develop", "example", "explore", "journey", "library",
            "advance", "another", "because", "believe", "between", "central", "channel", "charity",
            "collect", "company", "compare", "compete", "compute", "concept", "concern", "confirm",
            "contact", "contain", "content", "context", "control", "country", "culture", "current",
            "digital", "discuss", "document", "economy", "element", "energy", "engine", "enhance",
            "evening", "exactly", "examine", "execute", "explain", "express", "feature", "federal",
            "feeling", "finance"
        ];

        // æ ¹æ®æŒ‡å®šé•¿åº¦ç”Ÿæˆæç¤ºè¯
        function generatePrompt(length, apiType) {
            let prompt = [];
            for (let i = 0; i < length - 20; i++) {
                const randomIndex = Math.floor(Math.random() * wordList.length);
                prompt.push(wordList[randomIndex]);
            }

            return prompt.join(' ') + `\n\nRepeat the above text 100 times`;
        }

        const startTestBtn = document.getElementById('startTest');
        const stopTestBtn = document.getElementById('stopTest');
        const copyMarkdownBtn = document.getElementById('copyMarkdown');
        const exportCSVBtn = document.getElementById('exportCSV');
        const resultsDiv = document.getElementById('results');
        const markdownOutputHidden = document.getElementById('markdownOutputHidden');
        const progressBar = document.getElementById('progressBar');

        // è·å–å›¾è¡¨å…ƒç´ 
        const chartContainer = document.getElementById('chartContainer');
        const prefillChartCanvas = document.getElementById('prefillChart');
        const outputChartCanvas = document.getElementById('outputChart');
        let prefillChartInstance = null; //
        let outputChartInstance = null;  //

        let testResultsData = [];
        let totalTests = 0;
        let completedTests = 0;
        let isTestingRunning = false;
        let currentApiType = 'openai';
        let currentModelName = '/model';
        let api_key = '';
        let notes = '';
        let concurrencyStats = {
            minPrefillSpeed: Infinity,
            maxPrefillSpeed: 0,
            minOutputSpeed: Infinity,
            maxOutputSpeed: 0,
            avgPrefillSpeed: 0,
            avgOutputSpeed: 0
        };

        // å¸¦é‡è¯•çš„ fetch è¾…åŠ©å‡½æ•°
        /**
         * Fetches a resource with retry logic.
         * @param {string} apiUrl - The URL to fetch.
         * @param {object} fetchOptions - The options for the fetch call (method, headers, body).
         * @param {number} timeout - The timeout for each attempt in milliseconds.
         * @param {number} retries - The total number of attempts.
         * @param {number} delay - The delay between retries in milliseconds.
         * @returns {Promise<Response>} - A promise that resolves with the Response object.
         */
        async function createFetchPromiseWithRetry(apiUrl, fetchOptions, timeout, retries = 3, delay = 1500) {
            for (let i = 0; i < retries; i++) {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), timeout);

                try {
                    const response = await fetch(apiUrl, {
                        ...fetchOptions,
                        signal: controller.signal
                    });

                    clearTimeout(timeoutId); // Success, clear timeout

                    // Note: We return the response even if !response.ok
                    // The processing function (e.g., processOpenAIStreamResponse) is responsible for checking response.ok
                    return response; // Return the successful response

                } catch (error) {
                    clearTimeout(timeoutId); // Failed attempt

                    // Log the attempt
                    console.warn(`[RetryLogic] Attempt ${i + 1}/${retries} for ${fetchOptions.body.length} bytes failed: ${error.message}`);

                    if (i === retries - 1) {
                        // This was the last attempt, re-throw the error to be caught by allSettled
                        console.error(`[RetryLogic] All ${retries} attempts failed.`);
                        throw error;
                    }

                    // Wait before the next retry
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            }
        }


        // ã€ä¿®å¤ã€‘æµ‹è¯•OpenAIå…¼å®¹æ¥å£
        async function testOpenAI(apiUrl, modelName, minLength, maxLength, step, outputLength, temperature, top_p, presence_penalty, frequency_penalty, concurrency, timeout) {
            for (let length = minLength; length <= maxLength; length += step) {
                if (!isTestingRunning) break;

                // F12æ§åˆ¶å°æ—¥å¿—
                console.log(`[Test] å‡†å¤‡æµ‹è¯•æç¤ºè¯é•¿åº¦: ${length}`);

                const row = document.createElement('tr');
                resultsDiv.querySelector('tbody').appendChild(row);
                const cells = [];
                for (let i = 0; i < 7; i++) {
                    const cell = document.createElement('td');
                    cells.push(cell);
                    row.appendChild(cell);
                }

                cells[0].textContent = length;
                cells[1].textContent = "æµ‹è¯•ä¸­...";
                cells[2].textContent = "æµ‹è¯•ä¸­...";
                cells[3].textContent = "æµ‹è¯•ä¸­...";
                cells[4].textContent = "æµ‹è¯•ä¸­...";
                cells[5].textContent = "æµ‹è¯•ä¸­...";
                cells[6].textContent = `${concurrency}å¹¶å‘æµ‹è¯•ä¸­...`;
                row.classList.add('info');
                resultsDiv.scrollTop = resultsDiv.scrollHeight;

                let resultEntry = {
                    promptLength: length,
                    prefillTimeMs: 'N/A',
                    prefillSpeed: 'N/A',
                    outputTokens: 'N/A',
                    outputTimeMs: 'N/A',
                    outputSpeed: 'N/A',
                    status: 'å¤±è´¥',
                    concurrency: concurrency
                };

                // æš–æœºè¯·æ±‚ (å¯é€‰, ä¿ç•™)
                if (length == minLength) {
                    try {
                        console.log("[Test] å‘é€æš–æœºè¯·æ±‚...");
                        const controller = new AbortController();
                        const timeoutId = setTimeout(() => controller.abort(), 5000); // æš–æœº5ç§’è¶…æ—¶
                        await fetch(apiUrl, {
                            method: 'POST',
                            headers: {
                                'Authorization': `Bearer ${api_key}`,
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({
                                "model": modelName,
                                "messages": [ { "role": "user", "content": "hello" } ],
                                "max_tokens": 2, "stream": false
                            }),
                            signal: controller.signal
                        });
                        clearTimeout(timeoutId);
                        console.log("[Test] æš–æœºè¯·æ±‚å®Œæˆã€‚");
                    }
                    catch (error) { console.warn("æš–æœºè¯·æ±‚å¤±è´¥:", error.message); }
                    await new Promise(resolve => setTimeout(resolve, 800)); // æš–æœºåé¢å¤–ç­‰å¾…
                }


                const measurementPromises = [];

                for (let i = 0; i < concurrency; i++) {
                    const prompt = generatePrompt(length, 'openai');
                    const requestBody = {
                        "model": modelName,
                        "messages": [
                            { "role": "user", "content": prompt }
                        ],
                        "max_tokens": outputLength,
                        "temperature": temperature,
                        "top_p": top_p,
                        "presence_penalty": presence_penalty,
                        "frequency_penalty": frequency_penalty,
                        "stream": true
                    };

                    const fetchOptions = {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${api_key}`,
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(requestBody)
                    };

                    measurementPromises.push(
                        executeAndMeasureRequest(apiUrl, fetchOptions, timeout, length)
                    );
                }

                try {
                    const results = await Promise.allSettled(measurementPromises);

                    const concurrencyResults = [];
                    let failedMessages = [];

                    for (const result of results) {
                        if (result.status === 'fulfilled') {
                            concurrencyResults.push(result.value);
                        } else {
                            failedMessages.push(result.reason.message);
                        }
                    }

                    //
                    const avgPrefillTimeMs = concurrencyResults.reduce((sum, res) => sum + res.prefillTimeMs, 0) / concurrencyResults.length;
                    const avgOutputTokens = concurrencyResults.reduce((sum, res) => sum + res.outputTokens, 0) / concurrencyResults.length;
                    const avgOutputTimeMs = concurrencyResults.reduce((sum, res) => sum + res.outputTimeMs, 0) / concurrencyResults.length;

                    // è®¡ç®—æ€»åå
                    const totalPrefillSpeed = concurrencyResults.reduce((sum, res) => sum + res.prefillSpeed, 0);
                    const totalOutputSpeed = concurrencyResults.reduce((sum, res) => sum + res.outputSpeed, 0);

                    // ä»…åœ¨æˆåŠŸæ—¶æ›´æ–°ç»Ÿè®¡
                    updateConcurrencyStats(totalPrefillSpeed, totalOutputSpeed);

                    resultEntry = {
                        promptLength: length,
                        prefillTimeMs: avgPrefillTimeMs.toFixed(2),
                        prefillSpeed: totalPrefillSpeed.toFixed(2),
                        outputTokens: avgOutputTokens.toFixed(0),
                        outputTimeMs: avgOutputTimeMs.toFixed(2),
                        outputSpeed: totalOutputSpeed.toFixed(2),
                        status: 'æˆåŠŸ',
                        concurrency: concurrency
                    };

                    cells[1].textContent = resultEntry.prefillTimeMs;
                    cells[2].textContent = resultEntry.prefillSpeed;
                    cells[3].textContent = resultEntry.outputTokens;
                    cells[4].textContent = resultEntry.outputTimeMs;
                    cells[5].textContent = resultEntry.outputSpeed;
                    // æ˜¾ç¤ºéƒ¨åˆ†æˆåŠŸ
                    cells[6].textContent = `${concurrencyResults.length}/${concurrency}å¹¶å‘æˆåŠŸ`;
                    row.classList.remove('info');
                    row.classList.add('success');

                } catch (error) {
                    // F12æ§åˆ¶å°é”™è¯¯æ—¥å¿—
                    console.error(`[Test] æç¤ºè¯é•¿åº¦ ${length} æµ‹è¯•å¤±è´¥:`, error);
                    resultEntry.status = `å¤±è´¥ (${error.message})`;
                    cells[1].textContent = 'N/A';
                    cells[2].textContent = 'N/A';
                    cells[3].textContent = 'N/A';
                    cells[4].textContent = 'N/A';
                    cells[5].textContent = 'N/A';
                    cells[6].textContent = resultEntry.status;
                    row.classList.remove('info');
                    row.classList.add('error');
                }

                testResultsData.push(resultEntry); // æ— è®ºæˆåŠŸå¤±è´¥éƒ½æ¨å…¥ï¼Œä»¥ä¾¿å›¾è¡¨æ˜¾ç¤ºæ–­ç‚¹
                generateCharts(); // å®æ—¶æ›´æ–°å›¾è¡¨
                completedTests++;
                progressBar.style.width = `${(completedTests / totalTests) * 100}%`;
                resultsDiv.scrollTop = resultsDiv.scrollHeight;

                // å¢åŠ æµ‹è¯•é—´çš„å»¶è¿Ÿ
                console.log(`[Test] é•¿åº¦ ${length} æµ‹è¯•å®Œæˆã€‚ç­‰å¾… 1.5 ç§’...`);
                await new Promise(resolve => setTimeout(resolve, 1500));
            }
        }

        async function executeAndMeasureRequest(apiUrl, fetchOptions, timeout, promptLength) {

            const startTime = performance.now();
            let firstTokenTime = null;
            let outputContent = '';
            let receivedTokens = 0;

            const response = await createFetchPromiseWithRetry(apiUrl, fetchOptions, timeout, 3, 1500);

            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`HTTPé”™è¯¯! çŠ¶æ€: ${response.status}. å“åº”: ${errorText}`);
            }

            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            let reading = true;

            while (reading) {
                const { value, done } = await reader.read();
                if (done) {
                    reading = false;
                    break;
                }

                const chunk = decoder.decode(value, { stream: true });
                const lines = chunk.split('\n').filter(line => line.trim() !== '');

                for (const line of lines) {
                    if (line.startsWith('data: ') && !line.includes('[DONE]')) {
                        const jsonLine = line.replace('data: ', '');
                        try {
                            const data = JSON.parse(jsonLine);
                            if (data.choices && data.choices[0].delta && data.choices[0].delta.content) {
                                const token = data.choices[0].delta.content;
                                outputContent += token;
                                receivedTokens++;

                                if (!firstTokenTime) {
                                    firstTokenTime = performance.now();
                                }
                            }
                        } catch (e) {
                            console.error('è§£æé”™è¯¯:', e, jsonLine);
                        }
                    }
                }
            }

            const endTime = performance.now();

            if (!firstTokenTime) {
                if (receivedTokens === 0) {
                   throw new Error("æœªæ”¶åˆ°ä»»ä½•token (stream ended)");
                }
                firstTokenTime = endTime;
            }

            const prefillTimeMs = firstTokenTime - startTime;
            const outputTimeMs = Math.max(endTime - firstTokenTime, 1);
            const prefillSpeed = (promptLength / (prefillTimeMs / 1000));
            const outputSpeed = receivedTokens > 0 ? (receivedTokens / (outputTimeMs / 1000)) : 0;

            return {
                prefillTimeMs,
                prefillSpeed,
                outputTokens: receivedTokens,
                outputTimeMs,
                outputSpeed
            };
        }

        function updateConcurrencyStats(prefillSpeed, outputSpeed) {

            concurrencyStats.minPrefillSpeed = Math.min(concurrencyStats.minPrefillSpeed, prefillSpeed);
            concurrencyStats.maxPrefillSpeed = Math.max(concurrencyStats.maxPrefillSpeed, prefillSpeed);
            concurrencyStats.minOutputSpeed = Math.min(concurrencyStats.minOutputSpeed, outputSpeed);
            concurrencyStats.maxOutputSpeed = Math.max(concurrencyStats.maxOutputSpeed, outputSpeed);

            // é‡æ–°ä» testResultsData è®¡ç®—å¹³å‡å€¼ï¼Œç¡®ä¿å‡†ç¡®æ€§
            const allPrefillSpeeds = testResultsData
                .filter(r => r.status === 'æˆåŠŸ' && r.prefillSpeed !== 'N/A')
                .map(r => parseFloat(r.prefillSpeed));
            if (prefillSpeed) allPrefillSpeeds.push(prefillSpeed); // åŒ…æ‹¬å½“å‰æ‰¹æ¬¡çš„

            const allOutputSpeeds = testResultsData
                .filter(r => r.status === 'æˆåŠŸ' && r.outputSpeed !== 'N/A')
                .map(r => parseFloat(r.outputSpeed));
            if (outputSpeed) allOutputSpeeds.push(outputSpeed); // åŒ…æ‹¬å½“å‰æ‰¹æ¬¡çš„

            if (allPrefillSpeeds.length > 0) {
                concurrencyStats.avgPrefillSpeed = allPrefillSpeeds.reduce((sum, speed) => sum + speed, 0) / allPrefillSpeeds.length;
            }
             if (allOutputSpeeds.length > 0) {
                concurrencyStats.avgOutputSpeed = allOutputSpeeds.reduce((sum, speed) => sum + speed, 0) / allOutputSpeeds.length;
            }
        }

        function showConcurrencyStats() {

            const statsDiv = document.createElement('div');
            statsDiv.className = 'concurrent-stats';

            // ç¡®ä¿æ˜¾ç¤ºçš„å€¼ä¸æ˜¯Infinity
            const minP = isFinite(concurrencyStats.minPrefillSpeed) ? concurrencyStats.minPrefillSpeed.toFixed(2) : 'N/A';
            const maxP = isFinite(concurrencyStats.maxPrefillSpeed) && concurrencyStats.maxPrefillSpeed > 0 ? concurrencyStats.maxPrefillSpeed.toFixed(2) : 'N/A';
            const minO = isFinite(concurrencyStats.minOutputSpeed) ? concurrencyStats.minOutputSpeed.toFixed(2) : 'N/A';
            const maxO = isFinite(concurrencyStats.maxOutputSpeed) && concurrencyStats.maxOutputSpeed > 0 ? concurrencyStats.maxOutputSpeed.toFixed(2) : 'N/A';
            const avgP = isFinite(concurrencyStats.avgPrefillSpeed) && concurrencyStats.avgPrefillSpeed > 0 ? concurrencyStats.avgPrefillSpeed.toFixed(2) : 'N/A';
            const avgO = isFinite(concurrencyStats.avgOutputSpeed) && concurrencyStats.avgOutputSpeed > 0 ? concurrencyStats.avgOutputSpeed.toFixed(2) : 'N/A';


            statsDiv.innerHTML = `
                <h3>æ€»ååé‡æ€§èƒ½ç»Ÿè®¡ (${document.getElementById('concurrency').value}å¹¶å‘)</h3>
                <div class="stat-item">
                    <span>æ€»é¢„å¡«å……ååèŒƒå›´:</span>
                    <span class="stat-value">${minP} - ${maxP} tokens/s</span>
                </div>
                <div class="stat-item">
                    <span>æ€»è¾“å‡ºååèŒƒå›´:</span>
                    <span class="stat-value">${minO} - ${maxO} tokens/s</span>
                </div>
                <div class="stat-item">
                    <span>å¹³å‡æ€»é¢„å¡«å……åå:</span>
                    <span class="stat-value">${avgP} tokens/s</span>
                </div>
                <div class="stat-item">
                    <span>å¹³å‡æ€»è¾“å‡ºåå:</span>
                    <span class="stat-value">${avgO} tokens/s</span>
                </div>
            `;
            resultsDiv.appendChild(statsDiv);
        }

        // ã€ä¿®å¤ã€‘æµ‹è¯•Ollamaæ¥å£
        async function testOllama(apiUrl, modelName, minLength, maxLength, step, outputLength, temperature, top_p, presence_penalty, frequency_penalty, concurrency, timeout) {
             for (let length = minLength; length <= maxLength; length += step) {
                if (!isTestingRunning) break;

                // F12æ§åˆ¶å°æ—¥å¿—
                console.log(`[Test] å‡†å¤‡æµ‹è¯•æç¤ºè¯é•¿åº¦: ${length}`);

                const row = document.createElement('tr');
                resultsDiv.querySelector('tbody').appendChild(row);
                const cells = [];
                for (let i = 0; i < 7; i++) {
                    const cell = document.createElement('td');
                    cells.push(cell);
                    row.appendChild(cell);
                }

                cells[0].textContent = length;
                cells[1].textContent = "æµ‹è¯•ä¸­...";
                cells[2].textContent = "æµ‹è¯•ä¸­...";
                cells[3].textContent = "æµ‹è¯•ä¸­...";
                cells[4].textContent = "æµ‹è¯•ä¸­...";
                cells[5].textContent = "æµ‹è¯•ä¸­...";
                cells[6].textContent = `${concurrency}å¹¶å‘æµ‹è¯•ä¸­...`;
                row.classList.add('info');
                resultsDiv.scrollTop = resultsDiv.scrollHeight;

                let resultEntry = {
                    promptLength: length,
                    prefillTimeMs: 'N/A',
                    prefillSpeed: 'N/A',
                    outputTokens: 'N/A',
                    outputTimeMs: 'N/A',
                    outputSpeed: 'N/A',
                    status: 'å¤±è´¥',
                    concurrency: concurrency
                };

                // æš–æœº
                if (length == minLength) {
                    try {
                        console.log("[Test] å‘é€æš–æœºè¯·æ±‚...");
                        const controller = new AbortController();
                        const timeoutId = setTimeout(() => controller.abort(), 5000);
                        await fetch(apiUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json', },
                            body: JSON.stringify({
                                "model": modelName,
                                "messages": [ { "role": "user", "content": "hello" } ],
                                "options": { "num_predict": 2 }, "stream": false
                            }),
                            signal: controller.signal
                        });
                        clearTimeout(timeoutId);
                        console.log("[Test] æš–æœºè¯·æ±‚å®Œæˆã€‚");
                    }
                    catch (error) { console.warn("æš–æœºè¯·æ±‚å¤±è´¥:", error.message); }
                    await new Promise(resolve => setTimeout(resolve, 800));
                }

                const requests = [];

                for (let i = 0; i < concurrency; i++) {
                    const prompt = generatePrompt(length, 'ollama');
                    const requestBody = {
                        "model": modelName,
                        "messages": [
                            { "role": "user", "content": prompt }
                        ],
                        "options": {
                            "num_predict": outputLength,
                            "num_ctx": maxLength, // Ollama é€šå¸¸ç”¨ num_ctx é™åˆ¶ä¸Šä¸‹æ–‡
                            "temperature": temperature,
                            "top_p": top_p,
                            "repeat_penalty": 1.1 // åˆå¹¶ presence å’Œ frequency (Ollama ä¸åŒºåˆ†)
                        },
                        "stream": false
                    };

                    // ä½¿ç”¨å¸¦é‡è¯•çš„ fetch
                    const fetchOptions = {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(requestBody)
                    };

                    const fetchPromise = createFetchPromiseWithRetry(apiUrl, fetchOptions, timeout, 3, 1500);
                    requests.push(fetchPromise);
                }

                try {
                    const responses = await Promise.allSettled(requests);
                    const processPromises = [];
                    let failedMessages = [];

                    for (const result of responses) {
                        if (result.status === 'fulfilled' && result.value.ok) {
                            processPromises.push(processOllamaResponse(result.value, length));
                        } else {
                            if (result.status === 'rejected') {
                                failedMessages.push(result.reason.message);
                            } else {
                                failedMessages.push(`HTTP ${result.value.status}`);
                            }
                        }
                    }

                    const avgPrefillTimeMs = concurrencyResults.reduce((sum, res) => sum + res.prefillTimeMs, 0) / concurrencyResults.length;
                    const avgPrefillSpeed = concurrencyResults.reduce((sum, res) => sum + res.prefillSpeed, 0) / concurrencyResults.length;
                    const avgOutputTokens = concurrencyResults.reduce((sum, res) => sum + res.outputTokens, 0) / concurrencyResults.length;
                    const avgOutputTimeMs = concurrencyResults.reduce((sum, res) => sum + res.outputTimeMs, 0) / concurrencyResults.length;
                    const avgOutputSpeed = concurrencyResults.reduce((sum, res) => sum + res.outputSpeed, 0) / concurrencyResults.length;

                    //
                    const totalPrefillSpeed = concurrencyResults.reduce((sum, res) => sum + res.prefillSpeed, 0);
                    const totalOutputSpeed = concurrencyResults.reduce((sum, res) => sum + res.outputSpeed, 0);

                    updateConcurrencyStats(totalPrefillSpeed, totalOutputSpeed);

                    resultEntry = {
                        promptLength: length,
                        prefillTimeMs: avgPrefillTimeMs.toFixed(2),
                        prefillSpeed: totalPrefillSpeed.toFixed(2),
                        outputTokens: avgOutputTokens.toFixed(0),
                        outputTimeMs: avgOutputTimeMs.toFixed(2),
                        outputSpeed: totalOutputSpeed.toFixed(2),
                        status: 'æˆåŠŸ',
                        concurrency: concurrency
                    };

                    cells[1].textContent = resultEntry.prefillTimeMs;
                    cells[2].textContent = resultEntry.prefillSpeed;
                    cells[3].textContent = resultEntry.outputTokens;
                    cells[4].textContent = resultEntry.outputTimeMs;
                    cells[5].textContent = resultEntry.outputSpeed;
                    cells[6].textContent = `${concurrencyResults.length}/${concurrency}å¹¶å‘æˆåŠŸ`;
                    row.classList.remove('info');
                    row.classList.add('success');

                } catch (error) {
                    // F12æ§åˆ¶å°é”™è¯¯æ—¥å¿—
                    console.error(`[Test] æç¤ºè¯é•¿åº¦ ${length} æµ‹è¯•å¤±è´¥:`, error);
                    resultEntry.status = `å¤±è´¥ (${error.message})`;
                    cells[1].textContent = 'N/A';
                    cells[2].textContent = 'N/A';
                    cells[3].textContent = 'N/A';
                    cells[4].textContent = 'N/A';
                    cells[5].textContent = 'N/A';
                    cells[6].textContent = resultEntry.status;
                    row.classList.remove('info');
                    row.classList.add('error');
                }

                testResultsData.push(resultEntry);
                generateCharts(); // å®æ—¶æ›´æ–°å›¾è¡¨
                completedTests++;
                progressBar.style.width = `${(completedTests / totalTests) * 100}%`;
                resultsDiv.scrollTop = resultsDiv.scrollHeight;

                // å¢åŠ æµ‹è¯•é—´çš„å»¶è¿Ÿ
                console.log(`[Test] é•¿åº¦ ${length} æµ‹è¯•å®Œæˆã€‚ç­‰å¾… 1.5 ç§’...`);
                await new Promise(resolve => setTimeout(resolve, 1500));
            }
        }

        async function processOllamaResponse(response, promptLength) {

            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`HTTP é”™è¯¯! çŠ¶æ€: ${response.status}. å“åº”: ${errorText}`);
            }

            const data = await response.json();

            if (data.error) {
                throw new Error(`Ollama é”™è¯¯: ${data.error}`);
            }

            if (!data.prompt_eval_duration || !data.eval_duration) {
                throw new Error("Ollama å“åº”ä¸­ç¼ºå°‘*durationå­—æ®µ");
            }

            // prompt_eval_duration å’Œ eval_duration æ˜¯çº³ç§’ (ns)
            const prefillDurationMs = data.prompt_eval_duration / 1_000_000;
            const actualOutputTokens = data.eval_count;
            const outputDurationMs = Math.max(data.eval_duration / 1_000_000, 1); // ns to ms, æœ€å° 1ms

            // promptLength æ˜¯ç”¨æˆ·è¾“å…¥çš„æç¤ºè¯ token æ•°ï¼ŒOllama è¿”å›çš„ prompt_eval_count æ˜¯å®é™…å¤„ç†çš„
            // ä¸ºä¿æŒä¸€è‡´æ€§ï¼Œæˆ‘ä»¬ä½¿ç”¨ç”¨æˆ·è¾“å…¥çš„ length
            const prefillSpeed = (promptLength / (prefillDurationMs / 1000));
            const outputSpeed = actualOutputTokens > 0 ? (actualOutputTokens / (outputDurationMs / 1000)) : 0;

            return {
                prefillTimeMs: prefillDurationMs,
                prefillSpeed: prefillSpeed,
                outputTokens: actualOutputTokens,
                outputTimeMs: outputDurationMs,
                outputSpeed: outputSpeed
            };
        }

        startTestBtn.addEventListener('click', async () => {
            currentApiType = document.querySelector('.api-option.active').dataset.type;
            const apiUrl = document.getElementById('apiUrl').value.trim();
            currentModelName = document.getElementById('modelName').value.trim();
            api_key = document.getElementById('apiKey').value.trim();
            notes = document.getElementById('notes').value.trim() || `æ— ç”¨æˆ·å¤‡æ³¨ï¼Œæ¥å£: ${currentApiType === 'openai' ? 'OpenAIå…¼å®¹æ¥å£' : 'Ollamaæ¥å£'} ï¼Œæ¨¡å‹: ${currentModelName}`;
            const minLength = parseInt(document.getElementById('minLength').value, 10);
            const maxLength = parseInt(document.getElementById('maxLength').value, 10);
            const step = parseInt(document.getElementById('step').value, 10);
            const outputLength = parseInt(document.getElementById('outputLength').value, 10);
            const concurrency = parseInt(document.getElementById('concurrency').value, 10) || 1;
            const timeout = parseInt(document.getElementById('timeout').value, 10);
            const temperature = parseFloat(document.getElementById('temperatureInput').value);
            const top_p = parseFloat(document.getElementById('topPInput').value);
            const presence_penalty = parseFloat(document.getElementById('presencePenaltyInput').value);
            const frequency_penalty = parseFloat(document.getElementById('frequencyPenaltyInput').value);

            // ä¿å­˜å½“å‰é…ç½®åˆ° localStorage
            try {
                localStorage.setItem('llmPerfTestApiUrl', apiUrl);
                localStorage.setItem('llmPerfTestModelName', currentModelName);
                localStorage.setItem('llmPerfTestApiType', currentApiType);
            } catch (e) {
                console.warn("æ— æ³•ä¿å­˜é…ç½®åˆ° localStorage:", e);
            }

            // éªŒè¯è¾“å…¥
            if (!apiUrl || !currentModelName || !minLength || !maxLength || !step || !outputLength || !timeout) {
                alert("è¯·å¡«å†™æ‰€æœ‰å¿…å¡«çš„é…ç½®å‚æ•°ï¼");
                return;
            }

            totalTests = Math.floor((maxLength - minLength) / step) + 1;
            if (totalTests <= 0) {
                alert("æœ€å¤§é•¿åº¦å¿…é¡»å¤§äºæœ€å°é•¿åº¦ï¼Œæ­¥é•¿å¿…é¡»ä¸ºæ­£æ•°ã€‚");
                return;
            }
            completedTests = 0;

            concurrencyStats = {
                minPrefillSpeed: Infinity,
                maxPrefillSpeed: 0,
                minOutputSpeed: Infinity,
                maxOutputSpeed: 0,
                avgPrefillSpeed: 0,
                avgOutputSpeed: 0
            };

            startTestBtn.disabled = true;
            startTestBtn.textContent = "æµ‹è¯•ä¸­...";
            copyMarkdownBtn.style.display = 'none';
            exportCSVBtn.style.display = 'none';
            // chartContainer.style.display = 'none'; //
            progressBar.style.width = '0%';
            resultsDiv.innerHTML = "";
            testResultsData = [];

            // é”€æ¯æ—§å›¾è¡¨
            if (prefillChartInstance) prefillChartInstance.destroy();
            if (outputChartInstance) outputChartInstance.destroy();
            prefillChartInstance = null;
            outputChartInstance = null;

            const notesMessage = document.createElement('p');
            notesMessage.className = 'notes';
            notesMessage.textContent = `å¤‡æ³¨ï¼š${notes} | å¹¶å‘æ•°: ${concurrency} | è¶…æ—¶: ${timeout/1000}s`;
            resultsDiv.appendChild(notesMessage);

            const table = document.createElement('table');
            const thead = document.createElement('thead');
            const tbody = document.createElement('tbody');
            table.appendChild(thead);
            table.appendChild(tbody);
            resultsDiv.appendChild(table);

            const headerRow = document.createElement('tr');
            [
                'æç¤ºè¯é•¿åº¦<br>(tokens)',
                'é¢„å¡«å……è€—æ—¶<br>(ms)',
                'é¢„å¡«å……é€Ÿåº¦<br>(tokens/s)',
                'è¾“å‡ºé•¿åº¦<br>(tokens)',
                'è¾“å‡ºè€—æ—¶<br>(ms)',
                'è¾“å‡ºé€Ÿåº¦<br>(tokens/s)',
                'çŠ¶æ€'
            ].forEach(text => {
                const th = document.createElement('th');
                th.innerHTML = text;
                headerRow.appendChild(th);
            });
            thead.appendChild(headerRow);
            chartContainer.style.display = 'block'; //

            stopTestBtn.disabled = false;
            stopTestBtn.textContent = "åœæ­¢";
            stopTestBtn.style.display = 'block';
            isTestingRunning = true;

            stopTestBtn.onclick = () => {
                isTestingRunning = false;
                stopTestBtn.disabled = true;
                stopTestBtn.textContent = "åœæ­¢ä¸­...";
            };

            try {
                if (currentApiType === 'openai') {
                    await testOpenAI(apiUrl, currentModelName, minLength, maxLength, step, outputLength, temperature, top_p, presence_penalty, frequency_penalty, concurrency, timeout);
                } else {
                    await testOllama(apiUrl, currentModelName, minLength, maxLength, step, outputLength, temperature, top_p, presence_penalty, frequency_penalty, concurrency, timeout);
                }
            } catch (e) {
                console.error('æµ‹è¯•è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯:', e);
                const errorRow = document.createElement('tr');
                errorRow.innerHTML = `<td colspan="7" class="error">æµ‹è¯•æ„å¤–ç»ˆæ­¢: ${e.message}</td>`;
                resultsDiv.querySelector('tbody').appendChild(errorRow);
            }

            //
            const wasManuallyStopped = !isTestingRunning;

            // æ— è®ºæµ‹è¯•æ˜¯å®Œæˆè¿˜æ˜¯è¢«æ‰‹åŠ¨åœæ­¢ï¼Œåªè¦æœ‰æ•°æ®å°±æ˜¾ç¤ºç»Ÿè®¡
            if (testResultsData.some(r => r.status === 'æˆåŠŸ')) {
                showConcurrencyStats();
                // generateCharts(); //
            }

            // æ ¹æ®æµ‹è¯•æ˜¯å¦è¢«æ‰‹åŠ¨åœæ­¢æ¥æ˜¾ç¤ºä¸åŒçš„æœ€ç»ˆæ¶ˆæ¯
            if (wasManuallyStopped) {
                 const stopRow = document.createElement('tr');
                stopRow.innerHTML = `<td colspan="7" class="info">æµ‹è¯•å·²æ‰‹åŠ¨åœæ­¢ã€‚</td>`;
                resultsDiv.querySelector('tbody').appendChild(stopRow);
            } else if (!testResultsData.some(r => r.status === 'æˆåŠŸ')) {
                 const noDataRow = document.createElement('tr');
                noDataRow.innerHTML = `<td colspan="7" class="info">æµ‹è¯•å®Œæˆï¼Œä½†æ²¡æœ‰æ”¶é›†åˆ°æˆåŠŸçš„æ•°æ®ã€‚</td>`;
                resultsDiv.querySelector('tbody').appendChild(noDataRow);
            }

            isTestingRunning = false; //

            // ç”ŸæˆMarkdownè¡¨æ ¼
            let markdownTable = `## æµ‹è¯•ç»“æœ (${currentApiType === 'openai' ? 'OpenAIå…¼å®¹æ¥å£' : 'Ollamaæ¥å£'} - ${currentModelName})\n\n`;
            markdownTable += `å¤‡æ³¨ï¼š${notes} | å¹¶å‘æ•°: ${concurrency}\n\n`;
            markdownTable += `| æç¤ºè¯é•¿åº¦ (tokens) | é¢„å¡«å……è€—æ—¶ (ms) | æ€»é¢„å¡«å……åå (tokens/s) | è¾“å‡ºé•¿åº¦ (tokens) | è¾“å‡ºè€—æ—¶ (ms) | æ€»è¾“å‡ºåå (tokens/s) |\n`;
            markdownTable += `|---------------------|-------------------|-------------------------|-------------------|---------------|---------------------|\n`;

            testResultsData.forEach(res => {
                // Markdown ä¸­ä¹Ÿæ˜¾ç¤º N/A
                markdownTable += `| ${res.promptLength} | ${res.prefillTimeMs} | ${res.prefillSpeed} | ${res.outputTokens} | ${res.outputTimeMs} | ${res.outputSpeed} |\n`;
            });
            markdownOutputHidden.value = markdownTable;

            startTestBtn.disabled = false;
            startTestBtn.textContent = "å¼€å§‹æµ‹è¯•";
            copyMarkdownBtn.style.display = 'block';
            exportCSVBtn.style.display = 'block';
            stopTestBtn.style.display = 'none';
        });

        copyMarkdownBtn.addEventListener('click', () => {

            markdownOutputHidden.select();
            document.execCommand('copy');
            alert('Markdownè¡¨æ ¼å·²å¤åˆ¶åˆ°å‰ªè´´æ¿ï¼');
        });

        exportCSVBtn.addEventListener('click', () => {

            let csvContent = "data:text/csv;charset=utf-8,";
            csvContent += `${currentApiType === 'openai' ? 'OpenAIå…¼å®¹æ¥å£' : 'Ollamaæ¥å£'}, ${currentModelName}\n`;
            csvContent += `å¤‡æ³¨ï¼š, "${notes.replace(/"/g, '""')}"\n`; // å¤„ç†å¤‡æ³¨ä¸­çš„å¼•å·
            csvContent += `å¹¶å‘æ•°ï¼š, ${document.getElementById('concurrency').value}\n`;
            csvContent += "æç¤ºè¯é•¿åº¦(tokens),é¢„å¡«å……è€—æ—¶(ms),é¢„å¡«å……é€Ÿåº¦(tokens/s),è¾“å‡ºé•¿åº¦(tokens),è¾“å‡ºè€—æ—¶(ms),è¾“å‡ºé€Ÿåº¦(tokens/s),çŠ¶æ€\n";
            testResultsData.forEach(res => {
                csvContent += `${res.promptLength},${res.prefillTimeMs},${res.prefillSpeed},${res.outputTokens},${res.outputTimeMs},${res.outputSpeed},"${res.status.replace(/"/g, '""')}"\n`;
            });
            const encodedUri = encodeURI(csvContent);
            const link = document.createElement("a");
            link.setAttribute("href", encodedUri);
            link.setAttribute("download", `model_perf_${currentApiType}_${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.csv`);
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        });

        // ç”Ÿæˆå›¾è¡¨ (ç°åœ¨æ˜¯ä¸¤å¼ å›¾)
        function generateCharts() {
            if (testResultsData.length === 0) {
                //
                if (prefillChartInstance) prefillChartInstance.clear();
                if (outputChartInstance) outputChartInstance.clear();
                return;
            }

            // ä»æ•°æ®ä¸­æå–æ ‡ç­¾å’Œæ•°æ®é›†
            const labels = testResultsData.map(d => d.promptLength);
            // å°† 'N/A' è½¬æ¢ä¸º nullï¼Œä»¥ä¾¿ Chart.js çŸ¥é“åœ¨ä½•å¤„æ–­å¼€çº¿æ¡
            const prefillDataTotal = testResultsData.map(d => d.prefillSpeed === 'N/A' ? null : parseFloat(d.prefillSpeed));
            const outputDataTotal = testResultsData.map(d => d.outputSpeed === 'N/A' ? null : parseFloat(d.outputSpeed));

            chartContainer.style.display = 'block';

            // é”€æ¯æ—§å›¾è¡¨
            if (prefillChartInstance) {
                prefillChartInstance.data.labels = labels;
                prefillChartInstance.data.datasets[0].data = prefillDataTotal;
                prefillChartInstance.update('none');
            } else {
                // å›¾è¡¨1: é¢„å¡«å……é€Ÿåº¦
                const prefillCtx = prefillChartCanvas.getContext('2d');
                prefillChartInstance = new Chart(prefillCtx, {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: [
                            {
                                label: 'æ€»é¢„å¡«å……åå (tokens/s)',
                                data: prefillDataTotal,
                                borderColor: 'rgb(75, 192, 192)',
                                backgroundColor: 'rgba(75, 192, 192, 0.2)',
                                tension: 0.1,
                                fill: true,
                                spanGaps: false // åœ¨ null æ•°æ®ç‚¹å¤„æ–­å¼€
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        plugins: {
                            legend: {
                                position: 'top',
                            },
                            title: {
                                display: true,
                                text: `æ€»é¢„å¡«å…… (Prefill) åå - ${currentModelName}`
                            }
                        },
                        scales: {
                            x: {
                                title: {
                                    display: true,
                                    text: 'æç¤ºè¯é•¿åº¦ (tokens)'
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: 'æ€»åå (tokens/s)'
                                },
                                beginAtZero: true
                            }
                        }
                    }
                });
            }

            // å›¾è¡¨2: è¾“å‡ºé€Ÿåº¦
            if (outputChartInstance) {
                outputChartInstance.data.labels = labels;
                outputChartInstance.data.datasets[0].data = outputDataTotal;
                outputChartInstance.update('none');
            } else {
                const outputCtx = outputChartCanvas.getContext('2d');
                outputChartInstance = new Chart(outputCtx, {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: [
                            {
                                label: 'æ€»è¾“å‡ºåå (tokens/s)',
                                data: outputDataTotal,
                                borderColor: 'rgb(255, 99, 132)',
                                backgroundColor: 'rgba(255, 99, 132, 0.2)',
                                tension: 0.1,
                                fill: true,
                                spanGaps: false // åœ¨ null æ•°æ®ç‚¹å¤„æ–­å¼€
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        plugins: {
                            legend: {
                                position: 'top',
                            },
                            title: {
                                display: true,
                                text: `æ€»è¾“å‡º (Decode) åå - ${currentModelName}`
                            }
                        },
                        scales: {
                            x: {
                                title: {
                                    display: true,
                                    text: 'æç¤ºè¯é•¿åº¦ (tokens)'
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: 'æ€»åå (tokens/s)'
                                },
                                beginAtZero: true
                            }
                        }
                    }
                });
            }
        }

        // 
        function setDefaultValues() {
            // ä» localStorage åŠ è½½ä¿å­˜çš„ API ç±»å‹ã€åœ°å€å’Œæ¨¡å‹åç§°
            const savedApiType = localStorage.getItem('llmPerfTestApiType') || 'openai';
            const savedApiUrl = localStorage.getItem('llmPerfTestApiUrl');
            const savedModelName = localStorage.getItem('llmPerfTestModelName');

            // è®¾ç½® API ç±»å‹çš„ active çŠ¶æ€
            apiOptions.forEach(o => o.classList.remove('active'));
            const activeOption = document.querySelector(`.api-option[data-type="${savedApiType}"]`);
            if (activeOption) {
                activeOption.classList.add('active');
            }
            updateApiDescription(savedApiType);

            // å¦‚æœ localStroage æœ‰æ•°æ®åˆ™ä½¿ç”¨ï¼Œå¦åˆ™ä½¿ç”¨é»˜è®¤æ•°æ®
            if (savedApiUrl) {
                document.getElementById('apiUrl').value = savedApiUrl;
            } else {
                document.getElementById('apiUrl').value = (savedApiType === 'openai') ? d_openai_apiUrl : d_ollama_apiUrl;
            }

            if (savedModelName) {
                document.getElementById('modelName').value = savedModelName;
            } else {
                document.getElementById('modelName').value = (savedApiType === 'openai') ? d_openai_modelName : d_ollama_modelName;
            }

            // è®¾ç½®å…¶ä»–é»˜è®¤å€¼
            document.getElementById('apiKey').value = d_api_key;
            document.getElementById('minLength').value = d_minLength;
            document.getElementById('maxLength').value = d_maxLength;
            document.getElementById('step').value = d_step;
            document.getElementById('outputLength').value = d_outputLength;
            document.getElementById('concurrency').value = 1;
            document.getElementById('timeout').value = d_timeout;
            document.getElementById('temperatureInput').value = d_temperature;
            document.getElementById('topPInput').value = d_top_p;
            document.getElementById('presencePenaltyInput').value = d_presence_penalty;
            document.getElementById('frequencyPenaltyInput').value = d_frequency_penalty;
        }

        // 
        window.onload = function () { setDefaultValues(); };
    </script>
</body>

</html>